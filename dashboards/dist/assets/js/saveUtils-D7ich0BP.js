import{cB as I,cC as v,W as g,o as b,cD as k,_ as h}from"./uuid-De2V3pkO.js";import{getSiblingOfSameTypeI as B,contentToBlob as f}from"./resourceUtils-C3XmBys0.js";async function T(e,t,o=null){const r=await l(e,t,o);await m(r,t,o)}async function _(e,t,o,r,a=null){const n=await l(o,r,a);await e.update({data:t}),await m(n,r,a)}async function l(e,t,o=null){if(!t?.resources)return;const r=t.portalItem===e.portalItem?new Set(e.paths):new Set;e.paths.length=0,e.portalItem=t.portalItem;const a=new Set(t.resources.toKeep.map((s=>s.resource.path))),n=new Set,c=[];a.forEach((s=>{r.delete(s),e.paths.push(s)}));for(const s of t.resources.toUpdate)if(r.delete(s.resource.path),a.has(s.resource.path)||n.has(s.resource.path)){const{resource:w,content:d,finish:y,error:S}=s,p=B(w,I());e.paths.push(p.path),c.push(i({resource:p,content:d,compress:s.compress,finish:y,error:S},o))}else e.paths.push(s.resource.path),c.push(F(s,o)),n.add(s.resource.path);for(const s of t.resources.toAdd)e.paths.push(s.resource.path),r.has(s.resource.path)?r.delete(s.resource.path):c.push(i(s,o));if(c.length===0)return r;const u=await v(c);if(g(o),u.length>0)throw new b("save:resources","Failed to save one or more resources",{errors:u});return r}async function m(e,t,o=null){if(!e||!t.portalItem)return;const r=[];for(const a of e){const n=t.portalItem.resourceFromPath(a);r.push(n.portalItem.removeResource(n,o))}await k(r)}async function i(e,t){const o={...t??{},compress:e.compress},r=await h(e.resource.portalItem.addResource(e.resource,await f(e.content),o));if(r.ok!==!0)throw e.error?.(r.error),r.error;e.finish?.(e.resource)}async function F(e,t){const o=await h(e.resource.update(await f(e.content),t));if(o.ok!==!0)throw e.error?.(o.error),o.error;e.finish?.(e.resource)}async function x(e){const t=[];for(const o of e.allLayers)if("beforeSave"in o&&typeof o.beforeSave=="function"){const r=o.beforeSave();r&&t.push(r)}await Promise.allSettled(t)}export{x as m,_ as p,T as u};

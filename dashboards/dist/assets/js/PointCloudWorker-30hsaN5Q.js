import{dR as O,h as C,N as I,dS as k}from"./uuid-De2V3pkO.js";import{O as x}from"./quat-LWK6AbpX.js";import{e as R}from"./quatf64-QCogZAoR.js";import{r as D,n as A}from"./vec3f32-CYGJTZYG.js";import{n as F}from"./arcgisLayerUrl-DMpJLG2u.js";import{a as $,b as N,d as U}from"./PointCloudUniqueValueRenderer-ermevk0a.js";import{w as z,l as B,c as J,I as V}from"./I3SBinaryReader-BOhAOq47.js";import"./index-OAJD89tD.js";import"./mat3f64-BVJGbF0t.js";import"./LegendOptions-FRTnoArL.js";import"./ColorStop-B_V1vtMl.js";import"./VertexAttribute-CY64ESNu.js";function T(c,t,l,r){const{rendererJSON:s,isRGBRenderer:p}=c;let n=null,a=null;if(t&&p)n=t;else if(t&&s?.type==="pointCloudUniqueValueRenderer"){a=$.fromJSON(s);const e=a.colorUniqueValueInfos;n=new Uint8Array(3*r);const f=g(a.fieldTransformType);for(let o=0;o<r;o++){const u=(f?f(t[o]):t[o])+"";for(let i=0;i<e.length;i++)if(e[i].values.includes(u)){n[3*o]=e[i].color.r,n[3*o+1]=e[i].color.g,n[3*o+2]=e[i].color.b;break}}}else if(t&&s?.type==="pointCloudStretchRenderer"){a=N.fromJSON(s);const e=a.stops;n=new Uint8Array(3*r);const f=g(a.fieldTransformType);for(let o=0;o<r;o++){const u=f?f(t[o]):t[o],i=e.length-1;if(u<e[0].value)n[3*o]=e[0].color.r,n[3*o+1]=e[0].color.g,n[3*o+2]=e[0].color.b;else if(u>=e[i].value)n[3*o]=e[i].color.r,n[3*o+1]=e[i].color.g,n[3*o+2]=e[i].color.b;else for(let b=1;b<e.length;b++)if(u<e[b].value){const m=(u-e[b-1].value)/(e[b].value-e[b-1].value);n[3*o]=e[b].color.r*m+e[b-1].color.r*(1-m),n[3*o+1]=e[b].color.g*m+e[b-1].color.g*(1-m),n[3*o+2]=e[b].color.b*m+e[b-1].color.b*(1-m);break}}}else if(t&&s?.type==="pointCloudClassBreaksRenderer"){a=U.fromJSON(s);const e=a.colorClassBreakInfos;n=new Uint8Array(3*r);const f=g(a.fieldTransformType);for(let o=0;o<r;o++){const u=f?f(t[o]):t[o];for(let i=0;i<e.length;i++)if(u>=e[i].minValue&&u<=e[i].maxValue){n[3*o]=e[i].color.r,n[3*o+1]=e[i].color.g,n[3*o+2]=e[i].color.b;break}}}else n=new Uint8Array(3*r).fill(255);if(l&&a?.colorModulation){const e=a.colorModulation.minValue,f=a.colorModulation.maxValue,o=.3;for(let u=0;u<r;u++){const i=l[u],b=i>=f?1:i<=e?o:o+(1-o)*(i-e)/(f-e);n[3*u]=b*n[3*u],n[3*u+1]=b*n[3*u+1],n[3*u+2]=b*n[3*u+2]}}return n}function _(c,t){if(c.encoding==null||c.encoding===""){const l=z(t,c);if(l.vertexAttributes.position==null)return;const r=B(t,l.vertexAttributes.position),s=l.header.fields,p=[s.offsetX,s.offsetY,s.offsetZ],n=[s.scaleX,s.scaleY,s.scaleZ],a=r.length/3,e=new Float64Array(3*a);for(let f=0;f<a;f++)e[3*f]=r[3*f]*n[0]+p[0],e[3*f+1]=r[3*f+1]*n[1]+p[1],e[3*f+2]=r[3*f+2]*n[2]+p[2];return e}if(c.encoding==="lepcc-xyz")return J(t).result}function h(c,t,l){return c?.attributeInfo.useElevation?t?q(t,l):null:c?.attributeInfo.storageInfo?V(c.attributeInfo.storageInfo,c.buffer,l):null}function q(c,t){const l=new Float64Array(t);for(let r=0;r<t;r++)l[r]=c[3*r+2];return l}function E(c,t,l,r,s){const p=c.length/3;let n=0;for(let a=0;a<p;a++){let e=!0;for(let f=0;f<r.length&&e;f++){const{filterJSON:o}=r[f],u=s[f].values[a];switch(o.type){case"pointCloudValueFilter":{const i=o.mode==="exclude";o.values.includes(u)===i&&(e=!1);break}case"pointCloudBitfieldFilter":{const i=S(o.requiredSetBits),b=S(o.requiredClearBits);(u&i)===i&&(u&b)==0||(e=!1);break}case"pointCloudReturnFilter":{const i=15&u,b=u>>>4&15,m=b>1,M=i===1,y=i===b;let v=!1;for(const d of o.includedReturns)if(d==="last"&&y||d==="firstOfMany"&&M&&m||d==="lastOfMany"&&y&&m||d==="single"&&!m){v=!0;break}v||(e=!1);break}}}e&&(l[n]=a,c[3*n]=c[3*a],c[3*n+1]=c[3*a+1],c[3*n+2]=c[3*a+2],t[3*n]=t[3*a],t[3*n+1]=t[3*a+1],t[3*n+2]=t[3*a+2],n++)}return n}function g(c){switch(c){default:case null:case"none":return t=>t;case"low-four-bit":return t=>15&t;case"high-four-bit":return t=>(240&t)>>4;case"absolute-value":return t=>Math.abs(t);case"modulo-ten":return t=>t%10}}function S(c){let t=0;for(const l of c||[])t|=1<<l;return t}class P{transform(t){const l=this._transform(t),r=[l.points.buffer,l.rgb.buffer];l.pointIdFilterMap!=null&&r.push(l.pointIdFilterMap.buffer);for(const s of l.attributes)"buffer"in s.values&&O(s.values.buffer)&&s.values.buffer!==l.rgb.buffer&&r.push(s.values.buffer);return Promise.resolve({result:l,transferList:r})}_transform(t){const l=_(t.schema,t.geometryBuffer);let r=l.length/3,s=null;const p=new Array,n=h(t.primaryAttributeData,l,r);t.primaryAttributeData!=null&&n&&p.push({attributeInfo:t.primaryAttributeData.attributeInfo,values:n});const a=h(t.modulationAttributeData,l,r);t.modulationAttributeData!=null&&a&&p.push({attributeInfo:t.modulationAttributeData.attributeInfo,values:a});let e=T(t.rendererInfo,n,a,r);if(t.filterInfo&&t.filterInfo.length>0&&t.filterAttributesData!=null){const o=t.filterAttributesData.filter(C).map((u=>{const i=h(u,l,r),b={attributeInfo:u.attributeInfo,values:i};return p.push(b),b}));s=new Uint32Array(r),r=E(l,e,s,t.filterInfo,o)}for(const o of t.userAttributesData){const u=h(o,l,r);p.push({attributeInfo:o.attributeInfo,values:u})}3*r<e.length&&(e=new Uint8Array(e.buffer.slice(0,3*r))),this._applyElevationOffsetInPlace(l,r,t.elevationOffset);const f=this._transformCoordinates(l,r,t.obb,I.fromJSON(t.inSR),I.fromJSON(t.outSR));return{obb:t.obb,points:f,rgb:e,attributes:p,pointIdFilterMap:s}}_transformCoordinates(t,l,r,s,p){if(!F(t,s,0,t,p,0,l))throw new Error("Can't reproject");const n=D(r.center[0],r.center[1],r.center[2]),a=A(),e=A();x(w,r.quaternion);const f=new Float32Array(3*l);for(let o=0;o<l;o++)a[0]=t[3*o]-n[0],a[1]=t[3*o+1]-n[1],a[2]=t[3*o+2]-n[2],k(e,a,w),r.halfSize[0]=Math.max(r.halfSize[0],Math.abs(e[0])),r.halfSize[1]=Math.max(r.halfSize[1],Math.abs(e[1])),r.halfSize[2]=Math.max(r.halfSize[2],Math.abs(e[2])),f[3*o]=a[0],f[3*o+1]=a[1],f[3*o+2]=a[2];return f}_applyElevationOffsetInPlace(t,l,r){if(r!==0)for(let s=0;s<l;s++)t[3*s+2]+=r}}const w=R();function ot(){return new P}export{ot as default};

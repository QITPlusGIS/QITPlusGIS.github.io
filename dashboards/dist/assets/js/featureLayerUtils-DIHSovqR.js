import{h as Y,o as u,cq as _}from"./uuid-De2V3pkO.js";import{i as A}from"./originUtils-Bf8nVymy.js";import{Z as z}from"./FeatureLayer-XPLTGHtu.js";import{I as B,y as P,w as E,u as G,v as j,b as k,l as N,d as q,m as I}from"./utils-CTjaBH2v.js";import{p as y}from"./arcgisLayerUrl-DMpJLG2u.js";import{r as V}from"./fetchService-DqRbh7i6.js";import{h as Z}from"./layerUtils-D8dZn4eh.js";import{o as x}from"./jsonContext-BvsZzvt8.js";import{l as L,a as b,u as v,f as m,i as S}from"./portalItemUtils-2ng-Kvae.js";import"./index-OAJD89tD.js";import"./multiOriginJSONSupportUtils-C0wm8_Yw.js";import"./UniqueValueRenderer-DdZymv08.js";import"./LegendOptions-FRTnoArL.js";import"./diffUtils-B9GaWVUW.js";import"./SizeVariable-CEwBbtT1.js";import"./colorRamps-BC6MwlXc.js";import"./compilerUtils-BndV9QTL.js";import"./lengthUtils-C4EPlNSZ.js";import"./ColorStop-B_V1vtMl.js";import"./jsonUtils-CqYY9-3B.js";import"./styleUtils-IlLdeGfy.js";import"./jsonUtils-CshCi2EU.js";import"./DictionaryLoader-Bl9OQ4Ss.js";import"./LRUCache-DMLtX-OB.js";import"./FieldsIndex-dTLkFgHd.js";import"./heatmapUtils-DncJMPvQ.js";import"./vec4f64-Jk3PXxMO.js";import"./MultiOriginJSONSupport-Df7Mn0iX.js";import"./commonProperties-7y88ic0r.js";import"./ElevationInfo-C7w4yfnq.js";import"./FeatureLayerBase-Vxy7-5Ka.js";import"./Field-CpwGNSHU.js";import"./fieldType-CQ9t6Wui.js";import"./featureLayerUtils-JQb3hLRE.js";import"./Query-CEg5oX17.js";import"./FullTextSearch-C1te3nF2.js";import"./QuantizationParameters-DrrRb5JH.js";import"./AttachmentQuery-BX_2HFsg.js";import"./RelationshipQuery-CSVnFDD7.js";import"./LayerFloorInfo-DRZBdyCP.js";import"./serviceCapabilitiesUtils-BVYFxrwG.js";import"./workers-Dp_XhR59.js";import"./queryZScale-BHsgP0Ac.js";import"./FeatureSet-B32diVNL.js";import"./APIKeyMixin-CcEMCMh8.js";import"./ArcGISService-B9AkhE_C.js";import"./BlendLayer-4Nq3kFEk.js";import"./jsonUtils-Ds9cu0Qh.js";import"./parser-CQvYRaWk.js";import"./mat4f32-BYh1DbDV.js";import"./mat4-DR7ljCfE.js";import"./CustomParametersMixin-B-WvQlLz.js";import"./EditBusLayer-Z-bxRsy2.js";import"./FeatureEffectLayer-C-VkqhLI.js";import"./FeatureEffect-D6mxFSco.js";import"./FeatureReductionLayer-CMPQavUU.js";import"./clusterUtils-CBl3uOAm.js";import"./MD5-MtSiOt06.js";import"./FeatureReductionSelection-BdTwQHJB.js";import"./LabelClass-5BgkMgGD.js";import"./labelUtils-Dph0uXsk.js";import"./defaultsJSON-CHAaurhX.js";import"./OperationalLayer-Bx6pTHh7.js";import"./OrderedLayer-CDjvvtKC.js";import"./PortalLayer-DU1TFOEn.js";import"./PortalItem-C8IOgJp9.js";import"./RefreshableLayer-BEFOmf5k.js";import"./ScaleRangeLayer-cDV6S-UX.js";import"./TemporalLayer-B6MVRSR-.js";import"./FeatureTemplate-CuIcCtQS.js";import"./FeatureType-okWbna3M.js";import"./fieldProperties-BBmuKf7F.js";import"./labelingInfo-C5rI8Tdf.js";import"./versionUtils-go49xXEj.js";import"./styleUtils-CfnOzvk7.js";import"./TopFeaturesQuery-BR6kql40.js";import"./popupUtils-tKvJKde2.js";import"./interfaces-CL2NbQte.js";import"./saveAPIKeyUtils-C5NwgnmH.js";import"./requestPresets-CRFOpV8D.js";const d="Feature Service",h="feature-layer-utils",C=`${h}-save`,H=`${h}-save-as`,c=`${h}-saveall`,f=`${h}-saveall-as`;function w(r){return{isValid:Z(r)&&(r.type!=="feature"||!r.dynamicDataSource),errorMessage:"Feature layer should be a layer or table in a map or feature service"}}function g(r){const t=[],e=[];for(const{layer:o,layerJSON:s}of r)o.isTable?e.push(s):t.push(s);return{layers:t,tables:e}}function O(r){return g([r])}async function J(r,t){return/\/\d+\/?$/.test(r.url)?O(t[0]):M(t,r)}async function M(r,t){if(!t)return r.reverse(),g(r);const{layer:{url:e,customParameters:o,apiKey:s}}=r[0];let a=await t.fetchData("json");a?.layers!=null&&a?.tables!=null||(a=await Q(a,{url:e??"",customParameters:o,apiKey:s},r.map((i=>i.layer.layerId))));for(const i of r)R(i.layer,i.layerJSON,a);return a}async function Q(r,t,e){r||={},r.layers||=[],r.tables||=[];const{url:o,customParameters:s,apiKey:a}=t,{serviceJSON:i,layersJSON:l}=await V(o,{customParameters:s,apiKey:a}),n=T(r.layers,i.layers,e),p=T(r.tables,i.tables,e);r.layers=n.itemResources,r.tables=p.itemResources;const F=[...n.added,...p.added],K=l?[...l.layers,...l.tables]:[];return await W(r,F,o,K),r}function T(r,t,e){const o=_(r,t,((a,i)=>a.id===i.id));r=r.filter((a=>!o.removed.some((i=>i.id===a.id))));const s=o.added.map((({id:a})=>({id:a})));return s.forEach((({id:a})=>{r.push({id:a})})),{itemResources:r,added:s.filter((({id:a})=>!e.includes(a)))}}async function W(r,t,e,o){const s=t.map((({id:a})=>new z({url:e,layerId:a,sourceJSON:o.find((({id:i})=>i===a))})));await Promise.allSettled(s.map((a=>a.load()))),s.forEach((a=>{const{layerId:i,loaded:l,defaultPopupTemplate:n}=a;!l||n==null||R(a,{id:i,popupInfo:n.toJSON()},r)}))}function R(r,t,e){r.isTable?$(e.tables,t):$(e.layers,t)}function $(r,t){const e=r.findIndex((({id:o})=>o===t.id));e===-1?r.push(t):r[e]=t}function D(r,t){if(!r.length)throw new u(`${t}:missing-parameters`,"'layers' array should contain at least one feature layer")}function X(r,t){const e=r.map((o=>o.portalItem.id));if(new Set(e).size>1)throw new u(`${t}:invalid-parameters`,"All layers in the 'layers' array should be loaded from the same portal item")}function U(r,t){const e=r.map((o=>o.layerId));if(new Set(e).size!==e.length)throw new u(`${t}:invalid-parameters`,"'layers' array should contain only one instance each of layer or table in a feature service")}async function rr(r){D(r,c),await Promise.all(r.map((t=>t.load())));for(const t of r)N(t,c,w),q({layer:t,itemType:d,errorNamePrefix:c});X(r,c),U(r,c)}async function tr(r,t){const{url:e,layerId:o,title:s,fullExtent:a,isTable:i}=r,l=y(e);t.url=l?.serverType==="FeatureServer"?e:`${e}/${o}`,t.title||=s,t.extent=null,i||a==null||(t.extent=await L(a)),b(t,m.METADATA),b(t,m.MULTI_LAYER),S(t,m.SINGLE_LAYER),i&&S(t,m.TABLE)}function er(r,t){for(const a of r){const i=a.parsedUrl.path,l=y(i);if(!l?.url.path)throw new u(`${t}:invalid-parameters`,I(a,`has unsupported url pattern: ${i}`),{layer:a});const p=l?.serverType;if(p!=="FeatureServer"&&p!=="MapServer")throw new u(`${t}:invalid-parameters`,I(a,`has unsupported server type: ${p}`),{layer:a});if(p==="MapServer"&&r.length>1)throw new u(`${t}:invalid-parameters`,"Only one layer or table in a map service can be saved")}const e=y(r[0].parsedUrl.path),o=e?.url.path;if(!r.every((a=>y(a.parsedUrl.path)?.url.path===o)))throw new u(`${t}:invalid-parameters`,"'layers' array should only contain layers or tables that belong to the same feature service")}async function ar(r){D(r,f),await Promise.all(r.map((t=>t.load())));for(const t of r)N(t,f,w);er(r,f),U(r,f)}async function or(r,t){let e=0,o=0;for(const{isTable:i}of t)i?o++:e++;const s=t[0].parsedUrl.path,a=y(s);if(r.url=a?.serverType==="FeatureServer"?a.url.path:s,r.title||=a.title,r.extent=null,e>0){const i=t.map((l=>l.fullExtent)).filter(Y).reduce(((l,n)=>l.clone().union(n)));i&&(r.extent=await L(i))}b(r,m.METADATA),v(r,m.MULTI_LAYER,t.length>1),v(r,m.SINGLE_LAYER,t.length===1),v(r,m.TABLE,o>0&&e===0),E(r)}async function Ot(r,t){return B({layer:r,itemType:d,validateLayer:w,createItemData:(e,o)=>J(o,[e]),errorNamePrefix:C},t)}async function Jt(r,t){await rr(r);const e=r[0].portalItem,o=x(e),s=await Promise.all(r.map((i=>P(i,o,t)))),a=await J(e,r.map(((i,l)=>({layer:i,layerJSON:s[l]}))));return E(e),await e.update({data:a}),await Promise.all(r.slice(1).map((i=>i.portalItem.reload()))),A(o),e.clone()}async function Mt(r,t,e){return k({layer:r,itemType:d,validateLayer:w,createItemData:(o,s)=>Promise.resolve(O(o)),errorNamePrefix:H,newItem:t,setItemProperties:tr},e)}async function Rt(r,t,e){await ar(r);const o=G({itemType:d,errorNamePrefix:f,newItem:t}),s=x(o),a=await Promise.all(r.map((l=>P(l,s,e)))),i=await M(r.map(((l,n)=>({layer:l,layerJSON:a[n]}))));await or(o,r),await j(o,i,e);for(const l of r)l.portalItem=o.clone();return A(s),o}export{Ot as save,Jt as saveAll,Rt as saveAllAs,Mt as saveAs};

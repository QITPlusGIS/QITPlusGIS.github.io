import{G as t}from"./geometryEngineBase-bb31a5ba.js";import{hydratedAdapter as r}from"./hydrated-5c768c60.js";import"./commonjsHelpers-2f3e7994.js";import"./uuid-fb53ae2e.js";import"./index-e42a63f9.js";function i(e){return Array.isArray(e)?e[0].spatialReference:e&&e.spatialReference}function h(e){return t.extendedSpatialReferenceInfo(e)}function w(e,n){return t.clip(r,i(e),e,n)}function R(e,n){return t.cut(r,i(e),e,n)}function x(e,n){return t.contains(r,i(e),e,n)}function y(e,n){return t.crosses(r,i(e),e,n)}function S(e,n,a){return t.distance(r,i(e),e,n,a)}function A(e,n){return t.equals(r,i(e),e,n)}function D(e,n){return t.intersects(r,i(e),e,n)}function L(e,n){return t.touches(r,i(e),e,n)}function T(e,n){return t.within(r,i(e),e,n)}function V(e,n){return t.disjoint(r,i(e),e,n)}function v(e,n){return t.overlaps(r,i(e),e,n)}function z(e,n,a){return t.relate(r,i(e),e,n,a)}function H(e){return t.isSimple(r,i(e),e)}function I(e){return t.simplify(r,i(e),e)}function J(e,n=!1){return t.convexHull(r,i(e),e,n)}function N(e,n){return t.difference(r,i(e),e,n)}function O(e,n){return t.symmetricDifference(r,i(e),e,n)}function b(e,n){return t.intersect(r,i(e),e,n)}function j(e,n=null){return t.union(r,i(e),e,n)}function q(e,n,a,s,c,u){return t.offset(r,i(e),e,n,a,s,c,u)}function B(e,n,a,s=!1){return t.buffer(r,i(e),e,n,a,s)}function C(e,n,a,s,c,u){return t.geodesicBuffer(r,i(e),e,n,a,s,c,u)}function E(e,n,a=!0){return t.nearestCoordinate(r,i(e),e,n,a)}function P(e,n){return t.nearestVertex(r,i(e),e,n)}function G(e,n,a,s){return t.nearestVertices(r,i(e),e,n,a,s)}function f(e){var n;return"xmin"in e?"center"in e?e.center:null:"x"in e?e:"extent"in e?((n=e.extent)==null?void 0:n.center)??null:null}function $(e,n,a){if(e==null)throw new o;const s=e.spatialReference;if((a=a??f(e))==null)throw new o;const c=e.constructor.fromJSON(t.rotate(e,n,a));return c.spatialReference=s,c}function k(e,n){if(e==null)throw new o;const a=e.spatialReference;if((n=n??f(e))==null)throw new o;const s=e.constructor.fromJSON(t.flipHorizontal(e,n));return s.spatialReference=a,s}function F(e,n){if(e==null)throw new o;const a=e.spatialReference;if((n=n??f(e))==null)throw new o;const s=e.constructor.fromJSON(t.flipVertical(e,n));return s.spatialReference=a,s}function K(e,n,a,s){return t.generalize(r,i(e),e,n,a,s)}function M(e,n,a){return t.densify(r,i(e),e,n,a)}function Q(e,n,a,s=0){return t.geodesicDensify(r,i(e),e,n,a,s)}function U(e,n){return t.planarArea(r,i(e),e,n)}function W(e,n){return t.planarLength(r,i(e),e,n)}function X(e,n,a){return t.geodesicArea(r,i(e),e,n,a)}function Y(e,n,a){return t.geodesicLength(r,i(e),e,n,a)}function Z(e,n){return t.intersectLinesToPoints(r,i(e),e,n)}function _(e,n){t.changeDefaultSpatialReferenceTolerance(e,n)}function ee(e){t.clearDefaultSpatialReferenceTolerance(e)}class o extends Error{constructor(){super("Illegal Argument Exception")}}export{B as buffer,_ as changeDefaultSpatialReferenceTolerance,ee as clearDefaultSpatialReferenceTolerance,w as clip,x as contains,J as convexHull,y as crosses,R as cut,M as densify,N as difference,V as disjoint,S as distance,A as equals,h as extendedSpatialReferenceInfo,k as flipHorizontal,F as flipVertical,K as generalize,X as geodesicArea,C as geodesicBuffer,Q as geodesicDensify,Y as geodesicLength,b as intersect,Z as intersectLinesToPoints,D as intersects,H as isSimple,E as nearestCoordinate,P as nearestVertex,G as nearestVertices,q as offset,v as overlaps,U as planarArea,W as planarLength,z as relate,$ as rotate,I as simplify,O as symmetricDifference,L as touches,j as union,T as within};

import{D as b,dm as R,W as _,aT as E,X as $,cD as N,c$ as z,aX as H,a as h,y as m,c as T}from"./uuid-De2V3pkO.js";import{j as I}from"./TileInfo-ybWiFFHA.js";import{b as j}from"./Bitmap-CWIo4k0z.js";import{h as q,e as B}from"./TileInfoView-CccucBWX.js";const C=Math.PI/180;function D(e){return e*C}function X(e,i){const s=D(i.rotation),t=Math.abs(Math.cos(s)),r=Math.abs(Math.sin(s)),[o,n]=i.size;return e[0]=Math.round(n*r+o*t),e[1]=Math.round(n*t+o*r),e}function k(e,i,s,t){const[r,o]=i,[n,a]=t,c=.5*s;return e[0]=r-c*n,e[1]=o-c*a,e[2]=r+c*n,e[3]=o+c*a,e}const u=H(),l=[0,0],v=new B(0,0,0,0),y={imageMaxWidth:2048,imageMaxHeight:2048,imageRotationSupported:!1,imageNormalizationSupported:!1,hidpi:!1};let p=class extends b{constructor(e){super(e),this._imagePromise=null,this.bitmaps=[],this.hidpi=y.hidpi,this.imageMaxWidth=y.imageMaxWidth,this.imageMaxHeight=y.imageMaxHeight,this.imageRotationSupported=y.imageRotationSupported,this.imageNormalizationSupported=y.imageNormalizationSupported,this.update=R((async(i,s)=>{if(_(s),!i.stationary||this.destroyed)return;const t=i.state,r=E(t.spatialReference),o=this.hidpi?i.pixelRatio:1,n=this.imageNormalizationSupported&&t.worldScreenWidth&&t.worldScreenWidth<t.size[0],a=this.imageMaxWidth??0,c=this.imageMaxHeight??0;n?(l[0]=t.worldScreenWidth,l[1]=t.size[1]):this.imageRotationSupported?(l[0]=t.size[0],l[1]=t.size[1]):X(l,t);const M=Math.floor(l[0]*o)>a||Math.floor(l[1]*o)>c,S=r&&(t.extent.xmin<r.valid[0]||t.extent.xmax>r.valid[1]),f=!this.imageNormalizationSupported&&S,w=!M&&!f,x=this.imageRotationSupported?t.rotation:0,W=this.container.children.slice();if(w){const d=n?t.paddedViewState.center:t.center;this._imagePromise&&console.error("Image promise was not defined!"),this._imagePromise=this._singleExport(t,l,d,t.resolution,x,o,s)}else{let d=Math.min(a,c);f&&(d=Math.min(t.worldScreenWidth,d)),this._imagePromise=this._tiledExport(t,d,o,s)}try{const d=await this._imagePromise??[];_(s);const P=[];if(this._imagePromise=null,this.destroyed)return;this.bitmaps=d;for(const g of W)d.includes(g)||P.push(g.fadeOut().then((()=>{g.remove(),g.destroy()})));for(const g of d)P.push(g.fadeIn());await Promise.all(P)}catch(d){this._imagePromise=null,$(d)}}),5e3),this.updateExports=R((async i=>{const s=[];for(const t of this.container.children){if(!t.visible||!t.stage)return;s.push(i(t).then((()=>{t.invalidateTexture(),t.requestRender()})))}this._imagePromise=N(s).then((()=>this._imagePromise=null)),await this._imagePromise}))}destroy(){this.bitmaps.forEach((e=>e.destroy())),this.bitmaps=[]}get updating(){return!this.destroyed&&this._imagePromise!==null}async _export(e,i,s,t,r,o){const n=await this.fetchSource(e,Math.floor(i*r),Math.floor(s*r),{rotation:t,pixelRatio:r,signal:o});_(o);const a=new j(null,!0);return a.x=e.xmin,a.y=e.ymax,a.resolution=e.width/i,a.rotation=t,a.pixelRatio=r,a.opacity=0,this.container.addChild(a),await a.setSourceAsync(n,o),_(o),a}async _singleExport(e,i,s,t,r,o,n){k(u,s,t,i);const a=z(u,e.spatialReference);return[await this._export(a,i[0],i[1],r,o,n)]}_tiledExport(e,i,s,t){const r=I.create({size:i,spatialReference:e.spatialReference,scales:[e.scale]}),o=new q(r),n=o.getTileCoverage(e);if(!n)return null;const a=[];return n.forEach(((c,M,S,f)=>{v.set(c,M,S,0),o.getTileBounds(u,v);const w=z(u,e.spatialReference);a.push(this._export(w,i,i,0,s,t).then((x=>(f!==0&&(v.set(c,M,S,f),o.getTileBounds(u,v),x.x=u[0],x.y=u[3]),x))))})),Promise.all(a)}};h([m()],p.prototype,"_imagePromise",void 0),h([m()],p.prototype,"bitmaps",void 0),h([m()],p.prototype,"container",void 0),h([m()],p.prototype,"fetchSource",void 0),h([m()],p.prototype,"hidpi",void 0),h([m()],p.prototype,"imageMaxWidth",void 0),h([m()],p.prototype,"imageMaxHeight",void 0),h([m()],p.prototype,"imageRotationSupported",void 0),h([m()],p.prototype,"imageNormalizationSupported",void 0),h([m()],p.prototype,"requestUpdate",void 0),h([m()],p.prototype,"updating",null),p=h([T("esri.views.2d.layers.support.ExportStrategy")],p);const V=p;export{V as v};

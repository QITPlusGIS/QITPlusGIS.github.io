import{s as Y,o as h,a5 as k,e9 as C}from"./uuid-De2V3pkO.js";import{n as w}from"./capabilities-BeSycj8J.js";import{A as K,c as E,P as a,B as I,G as u,M as x,U as L,L as R,D as N,V as F}from"./enums-BFYfP9qy.js";const q=Y.getLogger("esri.views.webgl.checkWebGLError");function j(t,e){switch(e){case t.INVALID_ENUM:return"Invalid Enum. An unacceptable value has been specified for an enumerated argument.";case t.INVALID_VALUE:return"Invalid Value. A numeric argument is out of range.";case t.INVALID_OPERATION:return"Invalid Operation. The specified command is not allowed for the current state.";case t.INVALID_FRAMEBUFFER_OPERATION:return"Invalid Framebuffer operation. The currently bound framebuffer is not framebuffer complete when trying to render to or to read from it.";case t.OUT_OF_MEMORY:return"Out of memory. Not enough memory is left to execute the command.";case t.CONTEXT_LOST_WEBGL:return"WebGL context has been lost";default:return"Unknown error"}}const H=!!k("enable-feature:webgl-debug");function Z(){return H}function le(){return H}function b(t){if(Z()){const e=t.getError();if(e){const r=j(t,e),o=new Error().stack;q.error(new h("webgl-error","WebGL error occurred",{message:r,stack:o}))}}}var O;(function(t){t[t.Texture=0]="Texture",t[t.RenderBuffer=1]="RenderBuffer"})(O||(O={}));function _e(t){const e=t.gl;switch(e.getError()){case e.NO_ERROR:return null;case e.INVALID_ENUM:return"An unacceptable value has been specified for an enumerated argument";case e.INVALID_VALUE:return"An unacceptable value has been specified for an argument";case e.INVALID_OPERATION:return"The specified command is not allowed for the current state";case e.INVALID_FRAMEBUFFER_OPERATION:return"The currently bound framebuffer is not framebuffer complete";case e.OUT_OF_MEMORY:return"Not enough memory is left to execute the command";case e.CONTEXT_LOST_WEBGL:return"WebGL context is lost"}return"Unknown error"}function de(t,e,r,o,s=0){const n=t.gl;t.bindBuffer(r);for(const i of o){const c=e.get(i.name);c===void 0&&console.error(`There is no location for vertex attribute '${i.name}' defined.`);const _=s*i.stride;if(i.count<=4)n.vertexAttribPointer(c,i.count,i.type,i.normalized,i.stride,i.offset+_),n.enableVertexAttribArray(c),i.divisor>0&&t.gl2?.vertexAttribDivisor(c,i.divisor);else if(i.count===9)for(let l=0;l<3;l++)n.vertexAttribPointer(c+l,3,i.type,i.normalized,i.stride,i.offset+12*l+_),n.enableVertexAttribArray(c+l),i.divisor>0&&t.gl2?.vertexAttribDivisor(c+l,i.divisor);else if(i.count===16)for(let l=0;l<4;l++)n.vertexAttribPointer(c+l,4,i.type,i.normalized,i.stride,i.offset+16*l+_),n.enableVertexAttribArray(c+l),i.divisor>0&&t.gl2?.vertexAttribDivisor(c+l,i.divisor);else console.error("Unsupported vertex attribute element count: "+i.count)}}function ue(t,e,r,o){const s=t.gl;t.bindBuffer(r);for(const n of o){const i=e.get(n.name);if(n.count<=4)s.disableVertexAttribArray(i),n.divisor&&n.divisor>0&&t.gl2?.vertexAttribDivisor(i,0);else if(n.count===9)for(let c=0;c<3;c++)s.disableVertexAttribArray(i+c),n.divisor&&n.divisor>0&&t.gl2?.vertexAttribDivisor(i+c,0);else if(n.count===16)for(let c=0;c<4;c++)s.disableVertexAttribArray(i+c),n.divisor&&n.divisor>0&&t.gl2?.vertexAttribDivisor(i+c,0);else console.error("Unsupported vertex attribute element count: "+n.count)}t.unbindBuffer(K.ARRAY_BUFFER)}function J(t){switch(t){case u.ALPHA:case u.LUMINANCE:case u.RED:case u.RED_INTEGER:case a.R8:case a.R8I:case a.R8UI:case a.R8_SNORM:case I.STENCIL_INDEX8:return 1;case u.LUMINANCE_ALPHA:case u.RG:case u.RG_INTEGER:case a.RGBA4:case a.R16F:case a.R16I:case a.R16UI:case a.RG8:case a.RG8I:case a.RG8UI:case a.RG8_SNORM:case a.RGB565:case a.RGB5_A1:case I.DEPTH_COMPONENT16:return 2;case u.DEPTH_COMPONENT:case u.RGB:case u.RGB_INTEGER:case a.RGB8:case a.RGB8I:case a.RGB8UI:case a.RGB8_SNORM:case a.SRGB8:case I.DEPTH_COMPONENT24:return 3;case u.DEPTH_STENCIL:case u.DEPTH24_STENCIL8:case u.RGBA:case u.RGBA_INTEGER:case a.RGBA8:case a.R32F:case a.R11F_G11F_B10F:case a.RG16F:case a.R32I:case a.R32UI:case a.RG16I:case a.RG16UI:case a.RGBA8I:case a.RGBA8UI:case a.RGBA8_SNORM:case a.SRGB8_ALPHA8:case a.RGB9_E5:case a.RGB10_A2UI:case a.RGB10_A2:case I.DEPTH_STENCIL:case I.DEPTH_COMPONENT32F:case I.DEPTH24_STENCIL8:return 4;case I.DEPTH32F_STENCIL8:return 5;case a.RGB16F:case a.RGB16I:case a.RGB16UI:return 6;case a.RG32F:case a.RG32I:case a.RG32UI:case a.RGBA16F:case a.RGBA16I:case a.RGBA16UI:return 8;case a.RGB32F:case a.RGB32I:case a.RGB32UI:return 12;case a.RGBA32F:case a.RGBA32I:case a.RGBA32UI:return 16;case E.COMPRESSED_RGB_S3TC_DXT1_EXT:case E.COMPRESSED_RGBA_S3TC_DXT1_EXT:return .5;case E.COMPRESSED_RGBA_S3TC_DXT3_EXT:case E.COMPRESSED_RGBA_S3TC_DXT5_EXT:return 1;case E.COMPRESSED_R11_EAC:case E.COMPRESSED_SIGNED_R11_EAC:case E.COMPRESSED_RGB8_ETC2:case E.COMPRESSED_SRGB8_ETC2:case E.COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2:case E.COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2:return .5;case E.COMPRESSED_RG11_EAC:case E.COMPRESSED_SIGNED_RG11_EAC:case E.COMPRESSED_RGBA8_ETC2_EAC:case E.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC:return 1}return 0}class Q{constructor(e=0,r=e){this.width=e,this.height=r,this.target=x.TEXTURE_2D,this.pixelFormat=u.RGBA,this.dataType=L.UNSIGNED_BYTE,this.samplingMode=R.LINEAR,this.wrapMode=N.REPEAT,this.maxAnisotropy=1,this.flipped=!1,this.hasMipmap=!1,this.isOpaque=!1,this.unpackAlignment=4,this.preMultiplyAlpha=!1,this.depth=1,this.isImmutable=!1}}function ee(t){return t.width<=0||t.height<=0?0:t.width*t.height*(t.hasMipmap?4/3:1)*(t.internalFormat==null?4:J(t.internalFormat))}class B extends Q{constructor(e,r){switch(super(),this.context=e,Object.assign(this,r),this.internalFormat){case a.R16F:case a.R16I:case a.R16UI:case a.R32F:case a.R32I:case a.R32UI:case a.R8_SNORM:case a.R8:case a.R8I:case a.R8UI:this.pixelFormat=u.RED}}static validate(e,r){return new B(e,r)}}const v=4;let g=class{constructor(e,r=null,o=null){if(this.type=O.Texture,this._glName=null,this._samplingModeDirty=!1,this._wrapModeDirty=!1,this._wasImmutablyAllocated=!1,"context"in e)this._descriptor=e,o=r;else{const s=B.validate(e,r);if(!s)throw new h("Texture descriptor invalid");this._descriptor=s}if(this._descriptor.context.type!==w.WEBGL2&&(this._descriptor.isImmutable&&(this._descriptor.isImmutable=!1),M(this._descriptor.target)))throw new h("3D and array textures are not supported in WebGL1");this._descriptor.target===x.TEXTURE_CUBE_MAP?this._setDataCubeMap(o):this.setData(o)}get glName(){return this._glName}get descriptor(){return this._descriptor}get gpuMemoryUsage(){return ae.delete(this),ee(this._descriptor)}get isDirty(){return this._samplingModeDirty||this._wrapModeDirty}dispose(){this._glName&&this._descriptor.context.instanceCounter.decrement(F.Texture,this),this._descriptor.context.gl&&this._glName&&(this._descriptor.context.unbindTexture(this),this._descriptor.context.gl.deleteTexture(this._glName),this._glName=null)}release(){this.dispose()}resize(e,r){const o=this._descriptor;if(o.width!==e||o.height!==r){if(this._wasImmutablyAllocated)throw new h("Immutable textures can't be resized!");o.width=e,o.height=r,this._descriptor.target===x.TEXTURE_CUBE_MAP?this._setDataCubeMap(null):this.setData(null)}}_setDataCubeMap(e=null){for(let r=x.TEXTURE_CUBE_MAP_POSITIVE_X;r<=x.TEXTURE_CUBE_MAP_NEGATIVE_Z;r++)this._setData(e,r)}setData(e){this._setData(e)}_setData(e,r){if(!this._descriptor.context?.gl)return;const o=this._descriptor.context.gl;b(o),this._glName||(this._glName=o.createTexture(),this._glName&&this._descriptor.context.instanceCounter.increment(F.Texture,this)),e===void 0&&(e=null);const s=this._descriptor,n=r??s.target,i=M(n);e===null&&(s.width=s.width||v,s.height=s.height||v,i&&(s.depth=s.depth??1));const c=this._descriptor.context.bindTexture(this,g.TEXTURE_UNIT_FOR_UPDATES);this._descriptor.context.setActiveTexture(g.TEXTURE_UNIT_FOR_UPDATES),G(this._descriptor.context,s),this._configurePixelStorage(),b(o);const _=this._deriveInternalFormat();if(U(e)){let l="width"in e?e.width:e.codedWidth,d="height"in e?e.height:e.codedHeight;const p=1;e instanceof HTMLVideoElement&&(l=e.videoWidth,d=e.videoHeight),s.width&&s.height,i&&s.depth,s.isImmutable&&!this._wasImmutablyAllocated&&this._texStorage(n,_,s.hasMipmap,l,d,p),this._texImage(n,0,_,l,d,p,e),b(o),s.hasMipmap&&this.generateMipmap(),s.width||(s.width=l),s.height||(s.height=d),i&&!s.depth&&(s.depth=p)}else{const{width:l,height:d,depth:p}=s;if(l==null||d==null)throw new h("Width and height must be specified!");if(i&&p==null)throw new h("Depth must be specified!");if(s.isImmutable&&!this._wasImmutablyAllocated&&this._texStorage(n,_,s.hasMipmap,l,d,p),S(e)){const m=e.levels,A=W(n,l,d,p),f=Math.min(A-1,m.length-1);this._descriptor.context.gl2!=null?o.texParameteri(s.target,this._descriptor.context.gl2.TEXTURE_MAX_LEVEL,f):s.hasMipmap=s.hasMipmap&&A===m.length;const T=_;if(!se(T))throw new h("Attempting to use compressed data with an uncompressed format!");this._forEachMipmapLevel(((D,P,V,$)=>{const z=m[Math.min(D,m.length-1)];this._compressedTexImage(n,D,T,P,V,$,z)}),f)}else this._texImage(n,0,_,l,d,p,e),b(o),s.hasMipmap&&this.generateMipmap()}y(o,this._descriptor),X(o,this._descriptor),te(this._descriptor.context,this._descriptor),b(o),this._descriptor.context.bindTexture(c,g.TEXTURE_UNIT_FOR_UPDATES)}updateData(e,r,o,s,n,i,c=0){i||console.error("An attempt to use uninitialized data!"),this._glName||console.error("An attempt to update uninitialized texture!");const _=this._descriptor.context.gl,l=this._descriptor.context.gl2,d=this._descriptor,p=this._deriveInternalFormat(),{pixelFormat:m,dataType:A,target:f,isImmutable:T}=d;if(T&&!this._wasImmutablyAllocated)throw new h("Cannot update immutable texture before allocation!");const D=this._descriptor.context.bindTexture(this,g.TEXTURE_UNIT_FOR_UPDATES,!0);if((r<0||o<0||s>d.width||n>d.height||r+s>d.width||o+n>d.height)&&console.error("An attempt to update out of bounds of the texture!"),this._configurePixelStorage(),c){if(!l)return void console.error("Webgl2 must be enabled to use dataRowOffset!");_.pixelStorei(l.UNPACK_SKIP_ROWS,c)}if(U(i)?l?l.texSubImage2D(f,e,r,o,s,n,m,A,i):_.texSubImage2D(f,e,r,o,m,A,i):S(i)?_.compressedTexSubImage2D(f,e,r,o,s,n,p,i.levels[e]):_.texSubImage2D(f,e,r,o,s,n,m,A,i),c){if(!l)return void console.error("Webgl2 must be enabled to use dataRowOffset!");_.pixelStorei(l.UNPACK_SKIP_ROWS,0)}this._descriptor.context.bindTexture(D,g.TEXTURE_UNIT_FOR_UPDATES)}updateData3D(e,r,o,s,n,i,c,_){_||console.error("An attempt to use uninitialized data!"),this._glName||console.error("An attempt to update uninitialized texture!");const l=this._descriptor.context.gl2;if(l==null)throw new h("3D textures are not supported in WebGL1");const d=this._descriptor,p=this._deriveInternalFormat(),{pixelFormat:m,dataType:A,isImmutable:f,target:T}=d;if(f&&!this._wasImmutablyAllocated)throw new h("Cannot update immutable texture before allocation!");M(T)||console.warn("Attempting to set 3D texture data on a non-3D texture");const D=this._descriptor.context.bindTexture(this,g.TEXTURE_UNIT_FOR_UPDATES);if(this._descriptor.context.setActiveTexture(g.TEXTURE_UNIT_FOR_UPDATES),(r<0||o<0||s<0||n>d.width||i>d.height||c>d.depth||r+n>d.width||o+i>d.height||s+c>d.depth)&&console.error("An attempt to update out of bounds of the texture!"),this._configurePixelStorage(),S(_))_=_.levels[e],l.compressedTexSubImage3D(T,e,r,o,s,n,i,c,p,_);else{const P=_;l.texSubImage3D(T,e,r,o,s,n,i,c,m,A,P)}this._descriptor.context.bindTexture(D,g.TEXTURE_UNIT_FOR_UPDATES)}generateMipmap(){const e=this._descriptor;if(!e.hasMipmap){if(this._wasImmutablyAllocated)throw new h("Cannot add mipmaps to immutable texture after allocation");e.hasMipmap=!0,this._samplingModeDirty=!0,G(this._descriptor.context,e)}e.samplingMode===R.LINEAR?(this._samplingModeDirty=!0,e.samplingMode=R.LINEAR_MIPMAP_NEAREST):e.samplingMode===R.NEAREST&&(this._samplingModeDirty=!0,e.samplingMode=R.NEAREST_MIPMAP_NEAREST);const r=this._descriptor.context.bindTexture(this,g.TEXTURE_UNIT_FOR_UPDATES);this._descriptor.context.setActiveTexture(g.TEXTURE_UNIT_FOR_UPDATES),this._descriptor.context.gl.generateMipmap(e.target),this._descriptor.context.bindTexture(r,g.TEXTURE_UNIT_FOR_UPDATES)}setSamplingMode(e){e!==this._descriptor.samplingMode&&(this._descriptor.samplingMode=e,this._samplingModeDirty=!0)}setWrapMode(e){e!==this._descriptor.wrapMode&&(this._descriptor.wrapMode=e,G(this._descriptor.context,this._descriptor),this._wrapModeDirty=!0)}applyChanges(){const e=this._descriptor.context.gl,r=this._descriptor;this._samplingModeDirty&&(y(e,r),this._samplingModeDirty=!1),this._wrapModeDirty&&(X(e,r),this._wrapModeDirty=!1)}_deriveInternalFormat(){if(this._descriptor.context.type===w.WEBGL1)return this._descriptor.internalFormat=this._descriptor.pixelFormat;if(this._descriptor.internalFormat!=null)return this._descriptor.internalFormat===u.DEPTH_STENCIL&&(this._descriptor.internalFormat=u.DEPTH24_STENCIL8),this._descriptor.internalFormat;switch(this._descriptor.dataType){case L.FLOAT:switch(this._descriptor.pixelFormat){case u.RGBA:return this._descriptor.internalFormat=a.RGBA32F;case u.RGB:return this._descriptor.internalFormat=a.RGB32F;default:throw new h("Unable to derive format")}case L.UNSIGNED_BYTE:switch(this._descriptor.pixelFormat){case u.RGBA:return this._descriptor.internalFormat=a.RGBA8;case u.RGB:return this._descriptor.internalFormat=a.RGB8}}return this._descriptor.internalFormat=this._descriptor.pixelFormat===u.DEPTH_STENCIL?u.DEPTH24_STENCIL8:this._descriptor.pixelFormat}_configurePixelStorage(){const e=this._descriptor.context.gl,{unpackAlignment:r,flipped:o,preMultiplyAlpha:s}=this._descriptor;e.pixelStorei(e.UNPACK_ALIGNMENT,r),e.pixelStorei(e.UNPACK_FLIP_Y_WEBGL,o?1:0),e.pixelStorei(e.UNPACK_PREMULTIPLY_ALPHA_WEBGL,s?1:0)}_texStorage(e,r,o,s,n,i){const c=this._descriptor.context.gl2;if(c==null)throw new h("Immutable textures are not supported in WebGL1");if(!re(r))throw new h("Immutable textures must have a sized internal format");if(!this._descriptor.isImmutable)return;const _=o?W(e,s,n,i):1;if(M(e)){if(i==null)throw new h("Missing depth dimension for 3D texture upload");c.texStorage3D(e,_,r,s,n,i)}else c.texStorage2D(e,_,r,s,n);this._wasImmutablyAllocated=!0}_texImage(e,r,o,s,n,i,c){const _=this._descriptor.context.gl,l=M(e),{isImmutable:d,pixelFormat:p,dataType:m}=this._descriptor,A=this._descriptor.context.type===w.WEBGL2,f=A?_:null;if(A||!U(c))if(d){if(c!=null){const T=c;if(l){if(i==null)throw new h("Missing depth dimension for 3D texture upload");f.texSubImage3D(e,r,0,0,0,s,n,i,p,m,T)}else _.texSubImage2D(e,r,0,0,s,n,p,m,T)}}else{const T=c;if(l){if(i==null)throw new h("Missing depth dimension for 3D texture upload");f.texImage3D(e,r,o,s,n,i,0,p,m,T)}else _.texImage2D(e,r,o,s,n,0,p,m,T)}else _.texImage2D(e,0,o,p,m,c)}_compressedTexImage(e,r,o,s,n,i,c){const _=this._descriptor.context.gl;let l=null;const d=M(e),p=this._descriptor.isImmutable;if(d){if(this._descriptor.context.type!==w.WEBGL2)throw new h("3D textures are not supported in WebGL1");l=_}if(p){if(c!=null)if(d){if(i==null)throw new h("Missing depth dimension for 3D texture upload");l.compressedTexSubImage3D(e,r,0,0,0,s,n,i,o,c)}else _.compressedTexSubImage2D(e,r,0,0,s,n,o,c)}else if(d){if(i==null)throw new h("Missing depth dimension for 3D texture upload");l.compressedTexImage3D(e,r,o,s,n,i,0,c)}else _.compressedTexImage2D(e,r,o,s,n,0,c)}_forEachMipmapLevel(e,r=1/0){let{width:o,height:s,depth:n,hasMipmap:i,target:c}=this._descriptor;const _=c===x.TEXTURE_3D;if(o==null||s==null||_&&n==null)throw new h("Missing texture dimensions for mipmap calculation");for(let l=0;e(l,o,s,n),i&&(o!==1||s!==1||_&&n!==1)&&!(l>=r);++l)o=Math.max(1,o>>1),s=Math.max(1,s>>1),_&&(n=Math.max(1,n>>1))}};function G(t,e){(e.width!=null&&e.width<0||e.height!=null&&e.height<0||e.depth!=null&&e.depth<0)&&console.error("Negative dimension parameters are not allowed!");const r=t.type===w.WEBGL2;r||!e.isImmutable&&!M(e.target)||console.error("Immutable and 3D-like textures are not supported in WebGL1!"),!r&&(e.width!=null&&C(e.width)&&e.height!=null&&C(e.height)||(typeof e.wrapMode=="number"?e.wrapMode!==N.CLAMP_TO_EDGE&&console.error("Non-power-of-two textures must have a wrap mode of CLAMP_TO_EDGE!"):e.wrapMode.s===N.CLAMP_TO_EDGE&&e.wrapMode.t===N.CLAMP_TO_EDGE||console.error("Non-power-of-two textures must have a wrap mode of CLAMP_TO_EDGE!"),e.hasMipmap&&console.error("Mipmapping requires power-of-two textures!")))}function y(t,e){let r=e.samplingMode,o=e.samplingMode;r===R.LINEAR_MIPMAP_NEAREST||r===R.LINEAR_MIPMAP_LINEAR?(r=R.LINEAR,e.hasMipmap||(o=R.LINEAR)):r!==R.NEAREST_MIPMAP_NEAREST&&r!==R.NEAREST_MIPMAP_LINEAR||(r=R.NEAREST,e.hasMipmap||(o=R.NEAREST)),t.texParameteri(e.target,t.TEXTURE_MAG_FILTER,r),t.texParameteri(e.target,t.TEXTURE_MIN_FILTER,o)}function X(t,e){typeof e.wrapMode=="number"?(t.texParameteri(e.target,t.TEXTURE_WRAP_S,e.wrapMode),t.texParameteri(e.target,t.TEXTURE_WRAP_T,e.wrapMode)):(t.texParameteri(e.target,t.TEXTURE_WRAP_S,e.wrapMode.s),t.texParameteri(e.target,t.TEXTURE_WRAP_T,e.wrapMode.t))}function te(t,e){const r=t.capabilities.textureFilterAnisotropic;r&&t.gl.texParameterf(e.target,r.TEXTURE_MAX_ANISOTROPY,e.maxAnisotropy??1)}function re(t){return t in a}function se(t){return t in E}function S(t){return t!=null&&"type"in t&&t.type==="compressed"}function ie(t){return t!=null&&"byteLength"in t}function U(t){return t!=null&&!S(t)&&!ie(t)}function M(t){return t===x.TEXTURE_3D||t===x.TEXTURE_2D_ARRAY}function W(t,e,r,o=1){let s=Math.max(e,r);return t===x.TEXTURE_3D&&(s=Math.max(s,o)),Math.round(Math.log(s)/Math.LN2)+1}g.TEXTURE_UNIT_FOR_UPDATES=0;const ae=new Map;export{J as E,g as T,O as a,Z as b,le as c,_e as d,Q as e,de as i,ue as o,b as u};

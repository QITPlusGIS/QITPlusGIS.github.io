import{s as Ge,n as ke,o as qe}from"./mat2df32-Y88URbH1.js";import{s as je,i as We}from"./mat3-Riwg5JNu.js";import{e as fe}from"./mat3f32-BPgNI_lm.js";import{c as pe,d as ze,S as ye,E as me,F as xe,G as ge,H as _e,I as q,J as j,K as be,P as Qe,R as Xe,Q as Ze,U as et}from"./definitions-DYuD04dF.js";import{r as tt}from"./TiledDisplayObject-BVLmQerJ.js";import{a5 as k,s as ne,o as y,ez as Ee,bs as st,al as Te,h as rt,b1 as it}from"./uuid-De2V3pkO.js";import{a as nt}from"./diffUtils-B9GaWVUW.js";import{c as Ce}from"./labelingInfo-C5rI8Tdf.js";import{L as B,E as z,S as _,V as at,W as J,K as ot}from"./color-cT1-Ge3_.js";import{b as lt}from"./WGLContainer-CCreaUuQ.js";import{h as ut,n as dt,b as ct,f as Re}from"./visualVariablesUtils-CsTrhTSw.js";import{n as ht}from"./ExpandedCIM-Dnfk4gBv.js";import{f as C,_ as Me,A as ft}from"./GeometryUtils-CzofDDjY.js";import"./vec2-C6Y96AwR.js";import"./vec2f32-DJy8k_UQ.js";import{a as te}from"./capabilities-BeSycj8J.js";import{f as pt,c as yt}from"./clusterUtils-CBl3uOAm.js";import{e as Oe}from"./util-Co9CNf_x.js";import{D as Ve,L as De,U as mt}from"./enums-BFYfP9qy.js";import{E as xt}from"./FramebufferObject-BKEPrhyG.js";import{e as Ie,T as Le}from"./Texture-BUpON3bN.js";class T{constructor(e){if(this.next=null,!Array.isArray(e))return void(this.data=e);this.data=e[0];let t=this;for(let s=1;s<e.length;s++)t.next=new T([e[s]]),t=t.next}*values(){let e=this;for(;e;)yield e.data,e=e.next}forEach(e){let t=this;for(;t;)e(t.data),t=t.next}find(e){return e(this.data)?this:this.next?.find(e)}max(e,t=this){const s=e(this.data)>e(t.data)?this:t;return this.next?this.next.max(e,s):s}remove(e,t=null){return this===e?t?(t.next=this.next,t):this.next:this.next?.remove(e,this)??null}get last(){return this.next?this.next.last:this}}let ps=class{constructor(e){this._head=null,e!=null&&(this._head=new T(e))}get head(){return this._head}maxAvailableSpace(){if(this._head==null)return 0;const e=this._head.max((t=>t.end-t.start));return e.data.end-e.data.start}firstFit(e){if(this._head==null)return null;let t=null,s=this._head;for(;s;){const i=s.data.end-s.data.start;if(i===e)return t?t.next=s.next:this._head=s.next,s.data.start;if(i>e){const n=s.data.start;return s.data.start+=e,n}t=s,s=s.next}return null}free(e,t){const s=e+t;if(this._head==null){const o=new T({start:e,end:s});return void(this._head=o)}if(s<=this._head.data.start){if(s===this._head.data.start)return void(this._head.data.start-=t);const o=new T({start:e,end:s});return o.next=this._head,void(this._head=o)}let i=this._head,n=i.next;for(;n;){if(n.data.start>=s){if(i.data.end===e){if(i.data.end+=t,i.data.end===n.data.start){const l=n.data.end-n.data.start;return i.data.end+=l,void(i.next=n.next)}return}if(n.data.start===s)return void(n.data.start-=t);const o=new T({start:e,end:s});return o.next=i.next,void(i.next=o)}i=n,n=n.next}if(e===i.data.end)return void(i.data.end+=t);const a=new T({start:e,end:s});i.next=a}},gt=class{acquire(e){return{refCount:1,version:-1,labelMat2d:ke(),tileMat3:fe(),dvs:fe()}}release(e){}},_t=class se extends tt{constructor(e,t,s,i){super(e,t,s,i,pe,pe)}destroy(){super.destroy(),this._transforms&&se.TransformCache.release(this.key.hash)}setTransform(e){const t=this.resolution/e.resolution,s=this.transforms.tileMat3,[i,n]=e.toScreenNoRotation([0,0],[this.x,this.y]),a=this.width/this.rangeX*t,o=this.height/this.rangeY*t;je(s,a,0,0,0,o,0,i,n,1),We(this.transforms.dvs,e.displayViewMat3,s);const l=this.transforms.labelMat2d,u=window.devicePixelRatio,d=Ge(ke(),a*u,0,0,o*u,i*u,n*u);qe(l,e.viewMat2d,d)}_createTransforms(){return se.TransformCache.acquire(this.key.hash)}};_t.TransformCache=new gt;let L=class{constructor(e,t,s,i,n){this.target=e,this.geometryType=t,this.materialKey=s,this.indexFrom=i,this.indexCount=n}get indexEnd(){return this.indexFrom+this.indexCount}extend(e){this.indexCount+=e}},gs=class Ne{constructor(e,t){this.geometryType=0,this._target=e,this.geometryType=t}static from(e,t,s,i){const n=new Ne(e,t);if(i!=null)for(const a of i)s.seekIndex(a),n.addRecord(s);else for(;s.next();)n.addRecord(s);return n}addRecord(e){const t=this._target,s=this.geometryType,i=e.materialKey;let n=e.indexFrom,a=e.indexCount;const o=e.vertexFrom,l=e.vertexCount;if(a||(n=o,a=l),this._head==null){const c=new L(t,s,i,n,a);return void(this._head=new T(c))}let u=null,d=this._head;for(;d;){if(n<d.data.indexFrom)return this._insert(i,n,a,u,d);u=d,d=d.next}this._insert(i,n,a,u,null)}forEach(e){this._head!=null&&this._head.forEach(e)}*infos(){if(this._head!=null)for(const e of this._head.values())yield e}_insert(e,t,s,i,n){if(i==null&&n==null){const a=new L(this._target,this.geometryType,e,t,s);this._head=new T(a)}return i==null&&n!=null?this._insertAtHead(e,t,s,n):i!=null&&n==null?this._insertAtEnd(e,t,s,i):i!=null&&n!=null?this._insertAtMiddle(e,t,s,i,n):void 0}_insertAtHead(e,t,s,i){const n=t+s;if(e===i.data.materialKey&&n===i.data.indexFrom)i.data.indexFrom=t,i.data.indexCount+=s;else{const a=new L(this._target,this.geometryType,e,t,s);this._head=new T(a),this._head.next=i}}_insertAtEnd(e,t,s,i){if(i.data.materialKey===e&&i.data.indexEnd===t)i.data.indexCount+=s;else{const n=new L(this._target,this.geometryType,e,t,s),a=new T(n);i.next=a}}_insertAtMiddle(e,t,s,i,n){const a=t+s;if(i.data.materialKey===e&&i.data.indexEnd===t)i.data.indexCount+=s,i.data.materialKey===n.data.materialKey&&i.data.indexEnd===n.data.indexFrom&&(i.data.indexCount+=n.data.indexCount,i.next=n.next);else if(e===n.data.materialKey&&a===n.data.indexFrom)n.data.indexFrom=t,n.data.indexCount+=s;else{const o=new L(this._target,this.geometryType,e,t,s),l=new T(o);i.next=l,l.next=n}}};const H=2147483647;class N{constructor(e){this._head=e,this._cursor=e}static from(e,t=0,s=e.byteLength/w.BYTES_PER_RECORD-t){const i=new w(new Int32Array(e,t*w.BYTES_PER_RECORD,s*w.ELEMENTS_PER_RECORD));return new N(i)}size(){let e=this._cursor,t=0;for(;e;)t+=e.size(),e=e._link;return t}get id(){return this._cursor.id}set id(e){this._cursor.id=e}get materialKey(){return this._cursor.materialKey}set materialKey(e){this._cursor.materialKey=e}get insertAfter(){return this._cursor.insertAfter}get indexFrom(){return this._cursor.indexFrom}set indexFrom(e){this._cursor.indexFrom=e}get indexCount(){return this._cursor.indexCount}set indexCount(e){this._cursor.indexCount=e}get vertexFrom(){return this._cursor.vertexFrom}set vertexFrom(e){this._cursor.vertexFrom=e}get vertexCount(){return this._cursor.vertexCount}set vertexCount(e){this._cursor.vertexCount=e}get sortKey(){return this._cursor.sortKey}set sortKey(e){this._cursor.sortKey=e}get index(){return this._cursor._indexStart+this._cursor._index}seekIndex(e){let t=e;for(this._cursor=this._head;this._cursor;){const s=this._cursor.size();if(t<s)return this._cursor._index=t,!0;t-=s,this._cursor=this._cursor._link}return!1}forEach(e){const t=this.getCursor();for(;t.next();)e(t)}link(e){if(!this._head)return void(this._head=e._head);let t=this._head;for(;t._link;)t=t._link;t._link=e._head,t._link._indexStart=t._indexStart+t.size()}getCursor(){return this.copy()}getDrawInfo(e,t){return new L(e,t,this.materialKey,this.indexFrom,this.indexCount)}lookup(e){for(this._cursor=this._head;this._cursor&&!this._cursor.lookup(e);){if(!this._cursor._link)return!1;this._cursor=this._cursor._link}return!!this._cursor}copy(){const e=new N(this._head?.copy());if(!e._head)return e;let t=e._head,s=e._head._link;for(;s;)t._link=s.copy(),t=s,s=t._link;return e}next(){return!!this._cursor&&(!!this._cursor.next()||!!this._cursor._link&&(this._cursor=this._cursor._link,this.next()))}peekId(){return this._cursor.peekId()??this._cursor._link.peekId()}delete(e){let t=this._head,s=null;for(;t;){if(t.delete(e))return t.isEmpty()&&(s!=null&&(s._link=t._link),t===this._head&&(this._head=t._link),t===this._cursor&&(this._cursor=t._link)),!0;s=t,t=t._link}return!1}}N.ELEMENTS_PER_RECORD=ze,N.BYTES_PER_RECORD=N.ELEMENTS_PER_RECORD*Int32Array.BYTES_PER_ELEMENT;let w=class f{constructor(e){this._link=null,this._index=-1,this._indexStart=0,this._packedRecordsF32=null,this._deletedCount=0,this._offsets={instance:null},this._packedRecords=e}static from(e,t=0,s=e.byteLength/this.BYTES_PER_RECORD-t){return new f(new Int32Array(e,t*this.BYTES_PER_RECORD,s*this.ELEMENTS_PER_RECORD))}delete(e){const t=this._index,s=this.lookup(e);if(s)for(this.id=H,++this._deletedCount;this.next()&&this.id===e;)this.id=H,++this._deletedCount;return this._index=t,s}isEmpty(){return this._deletedCount===this.size()}link(e){this._link?this._link.link(e):this._link=e}lookup(e){if(this._offsets.instance==null){this._offsets.instance=new Map;const s=this.copy();s._index=-1;let i=0;for(;s.next();)s.id!==i&&(this._offsets.instance.set(s.id,s._index),i=s.id)}if(!this._offsets.instance.has(e))return!1;const t=this._index;return this._index=this._offsets.instance.get(e),this.id!==H||(this._index=t,!1)}get id(){return this._packedRecords[this._index*f.ELEMENTS_PER_RECORD]}set id(e){this._packedRecords[this._index*f.ELEMENTS_PER_RECORD]=e}get materialKey(){return this._packedRecords[this._index*f.ELEMENTS_PER_RECORD+1]}set materialKey(e){this._packedRecords[this._index*f.ELEMENTS_PER_RECORD+1]=e}get insertAfter(){return this._packedRecords[this._index*f.ELEMENTS_PER_RECORD+2]}get indexFrom(){return this._packedRecords[this._index*f.ELEMENTS_PER_RECORD+3]}set indexFrom(e){this._packedRecords[this._index*f.ELEMENTS_PER_RECORD+3]=e}get indexCount(){return this._packedRecords[this._index*f.ELEMENTS_PER_RECORD+4]}set indexCount(e){this._packedRecords[this._index*f.ELEMENTS_PER_RECORD+4]=e}get vertexFrom(){return this._packedRecords[this._index*f.ELEMENTS_PER_RECORD+5]}set vertexFrom(e){this._packedRecords[this._index*f.ELEMENTS_PER_RECORD+5]=e}get vertexCount(){return this._packedRecords[this._index*f.ELEMENTS_PER_RECORD+6]}set vertexCount(e){this._packedRecords[this._index*f.ELEMENTS_PER_RECORD+6]=e}get sortKey(){return this._packedRecordsF32||(this._packedRecordsF32=new Float32Array(this._packedRecords.buffer)),this._packedRecordsF32[this._index*f.ELEMENTS_PER_RECORD+7]}set sortKey(e){this._packedRecordsF32||(this._packedRecordsF32=new Float32Array(this._packedRecords.buffer)),this._packedRecordsF32[this._index*f.ELEMENTS_PER_RECORD+7]=e}get index(){return this._index}size(){return this._packedRecords.length/f.ELEMENTS_PER_RECORD}next(){for(;++this._index<this.size()&&this.id===H;);return this._index<this.size()}peekId(){const e=(this._index+1)*f.ELEMENTS_PER_RECORD;return e>=this._packedRecords.length?0:this._packedRecords[e]}getCursor(){return this.copy()}copy(){const e=new f(this._packedRecords);return e._indexStart=this._indexStart,e._link=this._link,e._index=this._index,e._offsets=this._offsets,e._deletedCount=this._deletedCount,e}};w.ELEMENTS_PER_RECORD=ze,w.BYTES_PER_RECORD=w.ELEMENTS_PER_RECORD*Int32Array.BYTES_PER_ELEMENT;function $e(r){if(!r)return B.NONE;let e=0;for(const t of r)if(t.type==="size"){const s=ut(t);e|=s,t.target==="outline"&&(e|=s<<4)}else t.type==="color"?e|=B.COLOR:t.type==="opacity"?e|=B.OPACITY:t.type==="rotation"&&(e|=B.ROTATION);return e}function M(r){return r.type==="line-marker"?{type:"line-marker",color:r.color?.toJSON(),placement:r.placement,style:r.style}:r.constructor.fromJSON(r.toJSON()).toJSON()}function O(r){return ft(r)}function g(r,e,t=!1){if(!r)return null;switch(r.type){case"simple-fill":case"picture-fill":return Et(r,e,t);case"simple-marker":case"picture-marker":return Rt(r,e,t);case"simple-line":return Tt(r,e,t);case"text":return vt(r,e,t);case"label":return bt(r,e,t);case"cim":return{type:"cim",rendererKey:e.vvFlags,data:r.data,maxVVSize:e.maxVVSize};case"CIMSymbolReference":return{type:"cim",rendererKey:e.vvFlags,data:r,maxVVSize:e.maxVVSize};case"web-style":return{...M(r),type:"web-style",hash:r.hash(),rendererKey:e.vvFlags,maxVVSize:e.maxVVSize};default:throw new Error(`symbol not supported ${r.type}`)}}function bt(r,e,t){const s=r.toJSON(),i=C(z.LABEL,{...e,placement:s.labelPlacement});return{materialKey:t?O(i):i,hash:r.hash(),...s,labelPlacement:s.labelPlacement}}function Et(r,e,t){const s=C(z.FILL,e),i=t?O(s):s,n=r.clone(),a=n.outline,o=Me(e.symbologyType);o||(n.outline=null);const l={materialKey:i,hash:n.hash(),...M(n)};if(o)return l;const u=[];if(u.push(l),a){const d=C(z.LINE,{...e,isOutline:!0}),c={materialKey:t?O(d):d,hash:a.hash(),...M(a)};u.push(c)}return{type:"composite-symbol",layers:u,hash:u.reduce(((d,c)=>c.hash+d),"")}}function Tt(r,e,t){const s=Me(e.symbologyType)?_.DEFAULT:e.symbologyType,i=C(z.LINE,{...e,symbologyType:s}),n=t?O(i):i,a=r.clone(),o=a.marker;a.marker=null;const l=[];if(l.push({materialKey:n,hash:a.hash(),...M(a)}),o){const u=C(z.MARKER,e),d=t?O(u):u;o.color=o.color??a.color,l.push({materialKey:d,hash:o.hash(),lineWidth:a.width,...M(o)})}return{type:"composite-symbol",layers:l,hash:l.reduce(((u,d)=>d.hash+u),"")}}function Rt(r,e,t){if(r.type==="simple-marker"&&(r.style==="path"||r.outline&&r.outline.style!=="solid"&&r.outline.style!=="none"))return g({type:"CIMSymbolReference",symbol:ht.fromSimpleMarker(r)},e,t);const s=C(z.MARKER,e),i=t?O(s):s,n=M(r);return{materialKey:i,hash:r.hash(),...n,angle:r.angle,maxVVSize:e.maxVVSize}}function vt(r,e,t){const s=C(z.TEXT,e),i=t?O(s):s,n=M(r);return{materialKey:i,hash:r.hash(),...n,angle:r.angle,maxVVSize:e.maxVVSize}}const _s=Object.freeze(Object.defineProperty({__proto__:null,createSymbolSchema:g},Symbol.toStringTag,{value:"Module"}));function St(r,e){if(!("visualVariables"in r)||!r.hasVisualVariables("size"))return 0;const t=r.getVisualVariablesForType("size");if(!t[0])return 0;const s=t[0];if(e&&s.field==="cluster_count"&&e.type==="cluster")return e.clusterMaxSize;if(s.target==="outline")return 0;if(s.transformationType==="stops")return s.stops.map((i=>i.size)).reduce(W,0);if(s.transformationType==="clamped-linear"){let i=-1/0,n=-1/0;return i=typeof s.maxSize=="number"?s.maxSize:s.maxSize.stops.map((a=>a.size)).reduce(W,0),n=typeof s.minSize=="number"?s.minSize:s.minSize.stops.map((a=>a.size)).reduce(W,0),Math.max(i,n)}return s.transformationType==="real-world-size"?30:void 0}function W(r,e){return Math.max(r,e)}const Y=8,Ae=Y-2,G=ne.getLogger("esri.views.2d.layers.features.support.rendererUtils"),bs=r=>{if(!("visualVariables"in r)||!r.visualVariables?.length)return r;const e=r.clone(),t=e.visualVariables.map((s=>Pe(s)?Ue(s):s));return e.visualVariables=t,e};function wt(r){return r.map((e=>Pe(e)?Ue(e.clone()):e))}function Pe(r){return(r.type==="size"||r.type==="color"||r.type==="opacity")&&r.stops!=null}function Ue(r){return r.stops=zt(r.type,r.stops??[]),r}function I(r,e,t){return(1-t)*r+t*e}function Ft(r,e){const[t,...s]=e,i=s.pop(),n=s[0].value,a=s[s.length-1].value,o=(a-n)/Ae,l=[];for(let u=n;u<a;u+=o){let d=0;for(;u>=s[d].value;)d++;const c=s[d],p=e[d-1],R=u-p.value,b=c.value===p.value?1:R/(c.value-p.value);if(r==="color"){const m=s[d],E=e[d-1],h=m.color.clone();h.r=I(E.color.r,h.r,b),h.g=I(E.color.g,h.g,b),h.b=I(E.color.b,h.b,b),h.a=I(E.color.a,h.a,b),l.push({value:u,color:h,label:m.label})}else if(r==="size"){const m=s[d],E=e[d-1],h=Ee(m.size),S=I(Ee(E.size),h,b);l.push({value:u,size:S,label:m.label})}else{const m=s[d],E=I(e[d-1].opacity,m.opacity,b);l.push({value:u,opacity:E,label:m.label})}}return[t,...l,i]}function kt(r){const[e,...t]=r,s=t.pop();for(;t.length>Ae;){let i=0,n=0;for(let a=1;a<t.length;a++){const o=t[a-1],l=t[a],u=Math.abs(l.value-o.value);u>n&&(n=u,i=a)}t.splice(i,1)}return[e,...t,s]}function zt(r,e){return e.length<=Y?e:(G.warn(`Found ${e.length} Visual Variable stops, but MapView only supports ${Y}. Displayed stops will be simplified.`),e.length>2*Y?Ft(r,e):kt(e))}function ae(){if(k("heatmap-force-raster"))return"raster";const{supportsTextureFloat:r,supportsTextureHalfFloat:e,supportsColorBufferFloat:t,supportsColorBufferFloatBlend:s,supportsColorBufferHalfFloat:i}=te("2d");return r&&t&&s||e&&i?"symbol":k("heatmap-allow-raster-fallback")?"raster":"none"}function Es(r){if(!r)return!0;switch(r.type){case"dot-density":if(!te("2d").supportsTextureFloat)return G.error(new y("webgl-missing-extension","Missing WebGL extension OES_Texture_Float which is required for DotDensity")),!1;break;case"heatmap":{const e=ae();if(e==="none"||e==="raster"&&!k("heatmap-force-raster")){const t=te("2d"),s=["supportsTextureFloat","supportsTextureHalfFloat","supportsColorBufferFloat","supportsColorBufferFloatBlend","supportsColorBufferHalfFloat"].filter((i=>!t[i])).join(", ");if(e==="none")return G.errorOnce(new y("webgl-missing-extension",`Missing WebGL${t.type} requirements for Heatmap: ${s}`)),!1;e==="raster"&&G.warnOnce(`Missing WebGL${t.type} requirements for accelerated Heatmap: ${s}. Feature support may be limited.`)}break}}return!0}const V=ne.getLogger("esri.views.2d.layers.features.schemaUtils"),x="ValidationError";function re(r,e){let t=0,s=0,i=_.DEFAULT;if(r!=null){if(s=St(r,e),"visualVariables"in r&&(t=$e(r.visualVariables||[]),r.type==="dot-density"&&(i=_.DOT_DENSITY)),r.type==="heatmap"&&(i=_.HEATMAP),r.type==="dictionary")return{maxVVSize:s,vvFlags:t,symbologyType:_.DEFAULT};if(r.type==="pie-chart")return{maxVVSize:s,vvFlags:t,symbologyType:_.PIE_CHART};if(i!==_.DOT_DENSITY&&i!==_.HEATMAP){const n=r.getSymbols();"backgroundFillSymbol"in r&&r.backgroundFillSymbol&&n.push(r.backgroundFillSymbol);let a=!0,o=!0;for(const l of n)if(l.type!=="cim"&&l.type!=="web-style"||(o=!1),l.type==="simple-fill"||l.type==="picture-fill"){const u=l.outline,d=u&&u.style!=="none"&&u.style!=="solid",c=l.type==="simple-fill"&&l.style!=="none"&&l.style!=="solid";d&&(a=!1),(l.type==="picture-fill"||c||d)&&(o=!1)}a?i=o?_.OUTLINE_FILL_SIMPLE:_.OUTLINE_FILL:o&&(i=_.SIMPLE)}}return{vvFlags:t,maxVVSize:s,symbologyType:i}}let ve=null;function Ts(r){if(k("esri-2d-update-debug")){const e=Se(r,!0);console.debug("Created new schema",e),console.debug("Schema diff",nt(ve,e)),ve=e}return Se(r)}function Se(r,e=!1){try{const t=Vt(r,e),s=Lt(r),i={};t.map((o=>Ct(i,r,o)));const n=r.subtypeCode!=null?`${r.subtypeField} = ${r.subtypeCode}`:null;return{source:{definitionExpression:st(r.definitionExpression,n),fields:r.fields.map((o=>o.toJSON())),gdbVersion:r.gdbVersion,historicMoment:r.historicMoment?.getTime(),outFields:r.availableFields,pixelBuffer:r.pixelBuffer,spatialReference:r.spatialReference.toJSON(),timeExtent:r.timeExtent?.toJSON(),customParameters:r.customParameters},attributes:{fields:{},indexCount:0},processors:t,tileRenderer:s,targets:i}}catch(t){if(t.fieldName===x)return V.error(t),null;throw t}}function Ct(r,e,t){switch(t.target){case"feature":return void X(r,Q(e),t);case"aggregate":{if(!("featureReduction"in e))return;const s=e.featureReduction;switch(s?.type){case"selection":throw new y(x,"Mapview does not support `selection` reduction type",s);case"binning":return X(r,Q(e),t),void Mt(r,s,e.fields.map((i=>i.toJSON())),t);case"cluster":return X(r,Q(e),t),void Ot(r,s,e.fields.map((i=>i.toJSON())),t)}}}}function oe(r,e){for(const t in e){const s=e[t];if(s.target!==r.name)continue;const i=r.attributes[t];if(i?.context){const n=i.context;n.mesh=n.mesh||s.context?.mesh,n.storage=n.storage||s.context?.storage}else r.attributes[t]=s}return r}function Q(r){return[r.filter?.toJSON()??null,r.featureEffect?.filter?.toJSON()??null]}function X(r,e,t){return r.feature||(r.feature={name:"feature",input:"source",filters:e,attributes:{}}),oe(r.feature,t.attributes.fields),r}function Ke(r,e){const{onStatisticExpression:t,onStatisticField:s,statisticType:i}=r;switch(i){case"min":case"max":case"avg":case"avg_angle":case"sum":case"count":return"esriFieldTypeDouble";case"mode":{if(t){const{returnType:a}=t;return a?a==="string"?"esriFieldTypeString":"esriFieldTypeDouble":(V.error(new y(x,"Unable to infer type of aggregateField with onStatisticExpression. ReturnType is not defined",r)),"esriFieldTypeString")}const n=e.find((a=>a.name===s));return n?n.type:(V.error(new y(x,"Unable to infer type of aggregateField with onStatisticExpression. ReturnType is not defined",r)),"esriFieldTypeString")}}}function Mt(r,e,t,s){return r.aggregate||(r.aggregate={name:"aggregate",type:"bin",filters:null,input:"feature",params:{fixedBinLevel:e.fixedBinLevel,fields:(e.fields??[]).map((i=>({...i.toJSON(),type:Ke(i,t)})))},attributes:{}}),oe(r.aggregate,s.attributes.fields),r}function Ot(r,e,t,s){const i=s.aggregateFields??[],n=new Set;for(const a of i)n.add(a.name);for(const a of e?.fields??[])n.has(a.name)||i.push(a);return r.aggregate||(r.aggregate={name:"aggregate",type:"cluster",input:"feature",filters:null,attributes:{},params:{clusterRadius:Te(e.clusterRadius/2),clusterPixelBuffer:64*Math.ceil(Te(e.clusterMaxSize)/64),fields:i.map((a=>({...a.toJSON(),type:Ke(a,t)})))}}),oe(r.aggregate,s.attributes.fields),r}function v(r,e){return e.field?F(r,{...e,type:"field",field:e.field}):e.valueExpression?F(r,{...e,type:"expression",valueExpression:e.valueExpression}):{field:void 0,fieldIndex:void 0}}function F(r,e){switch(e.type){case"expression":{const t=e.valueExpression;if(!r.fields[t]){const s=r.indexCount++;r.fields[t]={...e,name:t,fieldIndex:s}}return{fieldIndex:r.fields[t].fieldIndex}}case"label-expression":{const t=JSON.stringify(e.label);if(!r.fields[t]){const s=r.indexCount++;r.fields[t]={...e,name:t,fieldIndex:s}}return{fieldIndex:r.fields[t].fieldIndex}}case"field":{const t=e.field;return e.target==="aggregate"&&r.fields[t]||(r.fields[t]={...e,name:t}),{field:t}}case"statistic":return r.fields[e.name]={...e},{field:e.name}}}function Vt(r,e=!1){const t=new Array;let s=0;return t.push(It(r,s++,e)),t}function Z(r,e,t,s,i,n=!1){const a=F(r,{type:"label-expression",target:t,context:{mesh:!0},resultType:"string",label:{labelExpression:e.labelExpression,labelExpressionInfo:e.labelExpressionInfo?{expression:e.labelExpressionInfo.expression}:null,symbol:!!e.symbol,where:e.where}}),{fieldIndex:o}=a;return{...g(e,i,n),fieldIndex:o,target:t,index:s}}function Dt(r,e,t){const s="featureReduction"in e&&e.featureReduction;if(!s)return{fields:[],labels:[],matcher:void 0,rendererOverride:void 0};const i="aggregate",n=[];let a=null,o=Oe(e.geometryType),l=[],u=null;if(s)switch(s.type){case"selection":return V.error(new y(x,"Mapview does not support `selection` reduction type",s)),{fields:[],labels:[],matcher:void 0,rendererOverride:void 0};case"cluster":case"binning":if(n.push(...s.fields??[]),s.type==="cluster"?o="esriGeometryPoint":s.type==="binning"&&(o="esriGeometryPolygon"),s.renderer&&!s.renderer.authoringInfo?.isAutoGenerated){if(s.type==="cluster"){const{renderer:c}=pt(s.renderer,s,null);u=c}else u=s.renderer;const d=re(s.renderer,s);a=ie(r,i,s.renderer,d,t),l=s&&s.labelsVisible&&s.labelingInfo||[]}else if(s.type==="cluster"){if(u=yt(n,e.renderer,s,null,!0),s.symbol){const d=re(u,s);a={type:"simple",symbol:g(s.symbol,d,t),symbologyType:d.symbologyType}}l=s&&s.labelsVisible&&s.labelingInfo||[]}}return $t(r,n),{labels:Ce(l,s.type==="binning"?"esriGeometryPolygon":o),matcher:a,fields:n,rendererOverride:u}}function It(r,e,t=!1){const s={indexCount:0,fields:{}},i="featureReduction"in r?r.featureReduction??void 0:void 0,n=i?"aggregate":"feature";if("sublayers"in r){const h={type:"subtype",subtypeField:r.subtypeField,renderers:{},symbologyType:_.DEFAULT},S={type:"subtype",mapping:{},target:"feature",subtypeField:r.subtypeField},U={type:"subtype",classes:{}},Be={type:"symbol",target:"feature",aggregateFields:[],attributes:s,storage:S,mesh:{matcher:h,aggregateMatcher:null,labels:U,sortKey:null}},ue=new Set;let Je=0;for(const{renderer:D,subtypeCode:$,labelingInfo:He,labelsVisible:Ye}of r.sublayers){let de=0;"visualVariables"in D&&D.visualVariables&&(D.visualVariables.some((P=>P.type!=="rotation"))&&V.warnOnce("SubtypeGroupLayer currently only supports rotation visualVariables. All other visualVariable types will be ignored."),de=$e(D.visualVariables.filter((P=>P.type!=="size"))));const ce={symbologyType:_.DEFAULT,vvFlags:de,maxVVSize:0},A=ie(s,n,D,ce,t),K=we(s,n,D),he=Ye&&He;if(A.type==="dictionary")throw new y(x,"Dictionary renderer is not supported in subtype layers");if(A.type==="subtype")throw new y(x,"Nested subtype renderers is not supported");if(K!=null&&K.type==="subtype")throw new y(x,"Nested subtype storage is not supported");if(K?.attributeMapping!=null)throw new y(x,"Non-visual-variable attributes are not supported in subtype layers");if(A.type==="heatmap")throw new y(x,"Heatmaps are not supported in subtype layers");if(A.type==="pie-chart")throw new y(x,"Pie-charts are not supported in subtype layers");if(ue.has($))throw new y(x,"Subtype codes for sublayers must be unique");ue.add($),h.renderers[$]=A,S.mapping[$]=K,he&&(U.classes[$]=he.map((P=>Z(s,P,"feature",Je++,ce,t))))}return Be}if(r.renderer?.type==="heatmap"&&ae()==="raster"){const{radius:h,fieldOffset:S,field:U}=r.renderer;return{type:"heatmap",aggregateFields:[],attributes:s,target:n,storage:null,mesh:{radius:h,fieldOffset:S,field:v(s,{target:n,field:U,resultType:"numeric"}).field}}}const a=Dt(s,r,t),o=Oe(r.geometryType),l=a.rendererOverride??r.renderer,u=re(l,i),d=ie(s,n,l,u,t),c=we(s,n,l),p=Nt(s,r.orderBy,r.renderer,i),R=r.labelsVisible&&r.labelingInfo||[],b=Ce(R,o);let m=0;const E=[...b.map((h=>Z(s,h,"feature",m++,u,t))),...a.labels.map((h=>Z(s,h,"aggregate",m++,u,t)))];return{type:"symbol",target:n,attributes:s,aggregateFields:a.fields,storage:c,mesh:{matcher:d,labels:{type:"simple",classes:E},aggregateMatcher:a.matcher,sortKey:p}}}function Lt(r){return r.renderer?.type==="heatmap"&&ae()==="raster"?{type:"heatmap"}:{type:"symbol"}}function Nt(r,e,t,s){if(s!=null)return null;if(e!=null&&e.length){e.length>1&&V.warn(`Layer rendering currently only supports ordering by 1 orderByInfo, but found ${e.length}. All but the first will be discarded`);const i=e[0],n=i.order==="ascending"?"asc":"desc";return i.field?{field:i.field,order:n}:i.valueExpression?{fieldIndex:F(r,{type:"expression",target:"feature",valueExpression:i.valueExpression,resultType:"numeric"}).fieldIndex,order:n}:(V.error(new y(x,"Expected to find a field or valueExpression for OrderByInfo",i)),null)}return t!=null&&t.type==="unique-value"&&t.orderByClassesEnabled?{byRenderer:!0,order:"asc"}:null}function $t(r,e){const t={mesh:!0,storage:!0};for(const s of e){const{name:i,onStatisticField:n,onStatisticExpression:a,statisticType:o}=s;let l,u;const d="numeric",c="feature";a?u=F(r,{type:"expression",target:c,valueExpression:a.expression,resultType:d}).fieldIndex:l=F(r,{type:"field",target:c,field:n}).field,F(r,{type:"statistic",target:"aggregate",name:i,context:t,inField:l,inFieldIndex:u,statisticType:o})}}function we(r,e,t){let s;switch(t.type){case"simple":case"class-breaks":case"unique-value":case"dictionary":s={visualVariables:!0,attributes:null};break;default:s=lt(t).getStorageSpec(t)}return At(r,e,s,t)}function At(r,e,t,s){if(t==null)return null;const{visualVariables:i,attributes:n}=t;let a=null;i&&"visualVariables"in s&&(a=Pt(r,e,s.visualVariables));const o=a!=null?4:0;let l=null;return n!=null&&(l=n.map(((u,d)=>{const{field:c,fieldIndex:p}=v(r,{valueExpression:u.valueExpression,field:u.field,resultType:"numeric",target:e});return{binding:d+o,field:c,fieldIndex:p}}))),{type:"simple",target:e,attributeMapping:l,vvMapping:a}}function Pt(r,e,t){if(!t?.length)return[];const s={storage:!0},i="numeric";return wt(t).map((n=>{const a=at(n.type),{field:o,fieldIndex:l}=v(r,{target:e,valueExpression:n.valueExpression,field:n.field,context:s,resultType:i});switch(n.type){case"size":return n.valueExpression==="$view.scale"?null:{type:"size",binding:a,field:o,fieldIndex:l,normalizationField:v(r,{target:e,field:n.normalizationField,context:s,resultType:i}).field,valueRepresentation:n.valueRepresentation??null};case"color":return{type:"color",binding:a,field:o,fieldIndex:l,normalizationField:v(r,{target:e,field:n.normalizationField,context:s,resultType:i}).field};case"opacity":return{type:"opacity",binding:a,field:o,fieldIndex:l,normalizationField:v(r,{target:e,field:n.normalizationField,context:s,resultType:i}).field};case"rotation":return{type:"rotation",binding:a,field:o,fieldIndex:l}}})).filter(rt)}function ie(r,e,t,s,i=!1){const n=r??{indexCount:0,fields:{}};switch(t.type){case"simple":case"dot-density":return Ut(n,t,s,i);case"class-breaks":return Bt(n,e,t,s,i);case"unique-value":return Jt(n,e,t,s,i);case"dictionary":return Ht(n,t,s,i);case"heatmap":return Yt(n,t,s,i);case"pie-chart":return Kt(n,t,s,i)}}function Ut(r,e,t,s=!1){const i=e.getSymbols(),n=i.length?i[0]:null;return{type:"simple",symbol:g(n,t,s),symbologyType:t.symbologyType}}function Kt(r,e,t,s=!1){const i=e.getSymbols(),n=i[0],a=i.length>1?i[1]:null;return{type:"pie-chart",markerSymbol:g(n,t,s),fillSymbol:g(a,t,s),symbologyType:t.symbologyType}}function Bt(r,e,t,s,i=!1){const n={mesh:!0,use:"renderer.field"},a=t.backgroundFillSymbol,{field:o,fieldIndex:l}=v(r,{target:e,field:t.field,valueExpression:t.valueExpression,resultType:"numeric",context:n}),u=t.normalizationType,d=u==="log"?"esriNormalizeByLog":u==="percent-of-total"?"esriNormalizeByPercentOfTotal":u==="field"?"esriNormalizeByField":null,c=t.classBreakInfos.map((p=>({symbol:g(p.symbol,s,i),min:p.minValue,max:p.maxValue}))).sort(((p,R)=>p.min-R.min));return{type:"interval",attributes:r.fields,field:o,fieldIndex:l,backgroundFillSymbol:g(a,s,i),defaultSymbol:g(t.defaultSymbol,s,i),intervals:c,normalizationField:t.normalizationField,normalizationTotal:t.normalizationTotal,normalizationType:d,isMaxInclusive:t.isMaxInclusive,symbologyType:s.symbologyType}}function Jt(r,e,t,s,i=!1){const n=[],a=t.backgroundFillSymbol,o={target:e,context:{mesh:!0},resultType:"string"};if(t.field&&typeof t.field!="string")throw new y(x,"Expected renderer.field to be a string",t);const{field:l,fieldIndex:u}=v(r,{...o,field:t.field,valueExpression:t.valueExpression});for(const d of t.uniqueValueInfos??[])n.push({value:""+d.value,symbol:g(d.symbol,s,i)});return{type:"map",attributes:r.fields,field:l,fieldIndex:u,field2:v(r,{...o,field:t.field2}).field,field3:v(r,{...o,field:t.field3}).field,fieldDelimiter:t.fieldDelimiter??void 0,backgroundFillSymbol:g(a,s),defaultSymbol:g(t.defaultSymbol,s),map:n,symbologyType:s.symbologyType}}function Ht(r,e,t,s=!1){return{type:"dictionary",config:e.config,fieldMap:e.fieldMap,scaleExpression:e.scaleExpression,url:e.url,symbolOptions:t,symbologyType:t.symbologyType}}function Yt(r,e,t,s=!1){const i=e.getSymbols(),n=i.length?i[0]:null;return{type:"heatmap",symbol:g(n,t,s),symbologyType:t.symbologyType}}const le=ne.getLogger("esri.views.2d.engine.webgl.AttributeStoreView"),ee=dt(ct,le);class Fe{constructor(e,t,s){this._texture=null,this._lastTexture=null,this._fbos={},this.texelSize=4;const{buffer:i,pixelType:n,textureOnly:a}=e,o=J(n);this.shared=s,this.pixelType=n,this.size=t,this.textureOnly=a,a||(this.data=new o(i)),this._resetRange()}destroy(){this._texture?.dispose();for(const e in this._fbos){const t=this._fbos[e];t&&(e==="0"&&t.detachColorTexture(),t.dispose()),this._fbos[e]=null}this._texture=null}get _textureDesc(){const e=new Ie;return e.wrapMode=Ve.CLAMP_TO_EDGE,e.samplingMode=De.NEAREST,e.dataType=this.pixelType,e.width=this.size,e.height=this.size,e}setData(e,t,s){const i=Re(e),n=this.data,a=i*this.texelSize+t;!n||a>=n.length||(n[a]=s,this.dirtyStart=Math.min(this.dirtyStart,i),this.dirtyEnd=Math.max(this.dirtyEnd,i))}getData(e,t){if(this.data==null)return null;const s=Re(e)*this.texelSize+t;return!this.data||s>=this.data.length?null:this.data[s]}getTexture(e){return this._texture??this._initTexture(e)}getFBO(e,t=0){if(!this._fbos[t]){const s=t===0?this.getTexture(e):this._textureDesc;this._fbos[t]=new xt(e,s)}return this._fbos[t]}get locked(){return!(this.pixelType!==mt.UNSIGNED_BYTE||!this.shared||this.textureOnly||!k("esri-atomics")||!this.data)&&Atomics.load(this.data,0)===1}get hasDirty(){const e=this.dirtyStart;return this.dirtyEnd>=e}updateTexture(e,t){if(!this.locked){try{const s=this.dirtyStart,i=this.dirtyEnd;if(!this.hasDirty)return;this._resetRange();const n=this.data.buffer,a=this.getTexture(e),o=4,l=(s-s%this.size)/this.size,u=(i-i%this.size)/this.size,d=l,c=this.size,p=u,R=l*this.size*o,b=(c+p*this.size)*o-R,m=J(this.pixelType),E=new m(n,R*m.BYTES_PER_ELEMENT,b),h=this.size,S=p-d+1;if(S>this.size)return void le.error(new y("mapview-webgl","Out-of-bounds index when updating AttributeData"));a.updateData(0,0,d,h,S,E)}catch{}t()}}update(e){const{data:t,start:s,end:i}=e;if(t!=null&&this.data!=null){const n=this.data,a=s*this.texelSize;for(let o=0;o<t.length;o++){const l=1<<o%this.texelSize;e.layout&l&&(n[a+o]=t[o])}}this.dirtyStart=Math.min(this.dirtyStart,s),this.dirtyEnd=Math.max(this.dirtyEnd,i)}resize(e,t){const s=this.size;if(this.size=t,this.textureOnly)return void(s!==this.size&&(this._lastTexture=this._texture,this._texture=null));const i=J(this.pixelType);this.destroy(),this.data=new i(e.buffer)}_resetRange(){this.dirtyStart=2147483647,this.dirtyEnd=0}_initTexture(e){const t=new Le(e,this._textureDesc,this.data??void 0);if(this._lastTexture!=null&&this._fbos[0]){const s=this._lastTexture.descriptor.width,i=this._lastTexture.descriptor.height,n=this._lastTexture.descriptor.dataType,a=this._lastTexture.descriptor.pixelFormat,o=this.getFBO(e),l=ot(n),u=new(J(n))(new ArrayBuffer(s*i*l*this.texelSize)),d=e.getBoundFramebufferObject(),{x:c,y:p,width:R,height:b}=e.getViewport();e.bindFramebuffer(o),o.readPixels(0,0,s,i,a,n,u),t.updateData(0,0,0,2*s,i/2,u),e.setViewport(c,p,R,b),e.bindFramebuffer(d)}return this.destroy(),this._texture=t,this._texture}}class Rs{constructor(e){this._onUpdate=e,this._initialized=!1,this._forceNextUpload=!1,this._locked=!1}initialize(e){const{blocks:t,shared:s,size:i}=e;if(this.shared=s,this.size=i,ee("Initializing AttributeStoreView",e),this._data==null)this._data=t.map((n=>n!=null?new Fe(n,i,s):null));else for(let n=0;n<this._data.length;n++){const a=this._data[n],o=t[n];o!=null&&(a==null?this._data[n]=new Fe(o,i,s):a.resize(o,i))}this._initialized=!0}destroy(){for(const e of this._data??[])e?.destroy();this._defaultTexture?.dispose()}isEmpty(){return this._data==null}isUpdating(){const e=this._pendingAttributeUpdate!=null,t=e;return k("esri-2d-log-updating")&&console.log(`Updating AttributeStoreView ${t}
  -> hasPendingUpdate ${e}`),t}getBlock(e){return this._data==null?null:this._data[e]}setLabelMinZoom(e,t){this.setData(e,0,1,t)}getLabelMinZoom(e){return this.getData(e,0,1,255)}getFilterFlags(e){return this.getData(e,0,0,0)}getVVSize(e){return this.getData(e,ye,0,0)}getData(e,t,s,i){if(!this._data)return 0;const n=this._data[t];if(n==null)return 0;const a=n.getData(e,s);return a??i}setData(e,t,s,i){this._data[t].setData(e,s,i)}lockTextureUpload(){this._locked=!0}unlockTextureUpload(){this._locked=!1}forceTextureUpload(){this._forceNextUpload=!0}async requestUpdate(e){if(this._pendingAttributeUpdate)return void le.error(new y("mapview-webgl","Tried to update attribute data with a pending update"));const t=it();return ee("AttributeStoreView Update Requested",e),this._pendingAttributeUpdate={data:e,resolver:t},this._onUpdate(),t.promise}update(){if(this._initialized&&this._pendingAttributeUpdate!=null){k("esri-2d-update-debug")&&console.debug("AttributeStoreView::update");const{data:e,resolver:t}=this._pendingAttributeUpdate,s=this._data;for(let i=0;i<e.blocks.length;i++){const n=e.blocks[i],a=s[i];a!=null&&n!=null&&(ee(`Updating block ${i}`,n),a.update(n))}this._pendingAttributeUpdate=null,t(),this._onUpdate()}}bindTextures(e,t=!0){const s=this._getDefaultTexture(e);if(!this._initialized)return e.bindTexture(s,me),void(t&&(e.bindTexture(s,xe),e.bindTexture(s,ge),e.bindTexture(s,_e),e.bindTexture(s,q),e.bindTexture(s,j),e.bindTexture(s,be)));const i=this._data;if(!this._locked||this._forceNextUpload){for(const n of i)n?.updateTexture(e,(()=>this._onUpdate()));this._forceNextUpload=!1}e.bindTexture(i[Qe]?.getTexture(e)??s,me),t&&(e.bindTexture(i[Xe]?.getTexture(e)??s,be),e.bindTexture(i[Ze]?.getTexture(e)??s,xe),e.bindTexture(i[ye]?.getTexture(e)??s,ge),e.bindTexture(i[et]?.getTexture(e)??s,_e),e.bindTexture(i[q]?.getTexture(e)??s,q),e.bindTexture(i[j]?.getTexture(e)??s,j))}_getDefaultTexture(e){if(this._defaultTexture==null){const t=new Ie;t.wrapMode=Ve.CLAMP_TO_EDGE,t.samplingMode=De.NEAREST,t.width=1,t.height=1,this._defaultTexture=new Le(e,t,new Uint8Array(4))}return this._defaultTexture}}export{re as T,ie as _,ps as a,bs as b,_s as c,Es as h,g as i,Rs as j,_t as m,gs as n,N as r,Ts as w};

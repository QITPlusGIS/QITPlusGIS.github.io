import{cq as Y,h as _,o as u}from"./uuid-854440a9.js";import{i as P}from"./originUtils-cfe4feaf.js";import{Z as z}from"./FeatureLayer-96d0b946.js";import{I as B,y as $,w as E,b as G,u as j,v as k,l as N,d as q,m as I}from"./utils-9da11240.js";import{p as y}from"./arcgisLayerUrl-db50ff50.js";import{r as V}from"./fetchService-52ca97d5.js";import{h as Z}from"./layerUtils-53516847.js";import{o as x}from"./jsonContext-83068eb3.js";import{l as L,a as b,u as v,f as m,i as S}from"./portalItemUtils-1fa1f793.js";import"./index-2eca610e.js";import"./multiOriginJSONSupportUtils-c978f4c3.js";import"./UniqueValueRenderer-e361d3ea.js";import"./LegendOptions-82a1d9d3.js";import"./diffUtils-2fda0782.js";import"./SizeVariable-bf59d78c.js";import"./colorRamps-2b21b939.js";import"./compilerUtils-29e4db8f.js";import"./lengthUtils-b6ebb268.js";import"./ColorStop-1ffa7beb.js";import"./jsonUtils-1956249c.js";import"./styleUtils-327fee5c.js";import"./jsonUtils-6ee7893f.js";import"./DictionaryLoader-85e01f74.js";import"./LRUCache-f623b6a8.js";import"./FieldsIndex-babfd5a5.js";import"./heatmapUtils-2658140c.js";import"./vec4f64-3c9d0901.js";import"./MultiOriginJSONSupport-445fe484.js";import"./commonProperties-c4c17d77.js";import"./ElevationInfo-cefb6d5f.js";import"./FeatureLayerBase-f4864ff1.js";import"./Field-3600efd2.js";import"./fieldType-67bcc5fb.js";import"./featureLayerUtils-ac109221.js";import"./Query-84dc14af.js";import"./FullTextSearch-a21aa00d.js";import"./QuantizationParameters-0cb320a2.js";import"./AttachmentQuery-b68a2dcf.js";import"./RelationshipQuery-208eeb77.js";import"./LayerFloorInfo-a572a948.js";import"./serviceCapabilitiesUtils-15e9a7c8.js";import"./workers-bc069650.js";import"./queryZScale-fb4b06e9.js";import"./FeatureSet-5c3606d3.js";import"./APIKeyMixin-e23ff08a.js";import"./ArcGISService-f80e29bd.js";import"./BlendLayer-4792ed1b.js";import"./jsonUtils-d5cf6074.js";import"./parser-575e2c11.js";import"./mat4f32-60a2394b.js";import"./mat4-8067289c.js";import"./CustomParametersMixin-37d84f95.js";import"./EditBusLayer-b9fb1a02.js";import"./FeatureEffectLayer-7090e797.js";import"./FeatureEffect-32f3776e.js";import"./FeatureReductionLayer-4195f6bd.js";import"./clusterUtils-3da19a70.js";import"./MD5-715f37cd.js";import"./FeatureReductionSelection-b1bc3746.js";import"./LabelClass-360f8a0a.js";import"./labelUtils-38642a07.js";import"./defaultsJSON-b087dd4d.js";import"./OperationalLayer-be20f063.js";import"./OrderedLayer-a83a0e12.js";import"./PortalLayer-e811fd24.js";import"./PortalItem-eaf53090.js";import"./RefreshableLayer-74121b98.js";import"./ScaleRangeLayer-8c96f5fe.js";import"./TemporalLayer-0a93fd07.js";import"./FeatureTemplate-2ae2449f.js";import"./FeatureType-fbeaf9b0.js";import"./fieldProperties-2a1cbbd1.js";import"./labelingInfo-f046f80c.js";import"./versionUtils-feede695.js";import"./styleUtils-350617f8.js";import"./TopFeaturesQuery-8bb51543.js";import"./popupUtils-1833ba4a.js";import"./interfaces-f1f22245.js";import"./saveAPIKeyUtils-2f2d05fe.js";import"./requestPresets-baecfef2.js";const d="Feature Service",h="feature-layer-utils",C=`${h}-save`,H=`${h}-save-as`,c=`${h}-saveall`,f=`${h}-saveall-as`;function w(r){return{isValid:Z(r)&&(r.type!=="feature"||!r.dynamicDataSource),errorMessage:"Feature layer should be a layer or table in a map or feature service"}}function g(r){const t=[],a=[];for(const{layer:i,layerJSON:l}of r)i.isTable?a.push(l):t.push(l);return{layers:t,tables:a}}function O(r){return g([r])}async function J(r,t){return/\/\d+\/?$/.test(r.url)?O(t[0]):M(t,r)}async function M(r,t){if(!t)return r.reverse(),g(r);const{layer:{url:a,customParameters:i,apiKey:l}}=r[0];let e=await t.fetchData("json");(e==null?void 0:e.layers)!=null&&(e==null?void 0:e.tables)!=null||(e=await Q(e,{url:a??"",customParameters:i,apiKey:l},r.map(o=>o.layer.layerId)));for(const o of r)R(o.layer,o.layerJSON,e);return e}async function Q(r,t,a){r||(r={}),r.layers||(r.layers=[]),r.tables||(r.tables=[]);const{url:i,customParameters:l,apiKey:e}=t,{serviceJSON:o,layersJSON:s}=await V(i,{customParameters:l,apiKey:e}),n=T(r.layers,o.layers,a),p=T(r.tables,o.tables,a);r.layers=n.itemResources,r.tables=p.itemResources;const F=[...n.added,...p.added],K=s?[...s.layers,...s.tables]:[];return await W(r,F,i,K),r}function T(r,t,a){const i=Y(r,t,(e,o)=>e.id===o.id);r=r.filter(e=>!i.removed.some(o=>o.id===e.id));const l=i.added.map(({id:e})=>({id:e}));return l.forEach(({id:e})=>{r.push({id:e})}),{itemResources:r,added:l.filter(({id:e})=>!a.includes(e))}}async function W(r,t,a,i){const l=t.map(({id:e})=>new z({url:a,layerId:e,sourceJSON:i.find(({id:o})=>o===e)}));await Promise.allSettled(l.map(e=>e.load())),l.forEach(e=>{const{layerId:o,loaded:s,defaultPopupTemplate:n}=e;!s||n==null||R(e,{id:o,popupInfo:n.toJSON()},r)})}function R(r,t,a){r.isTable?A(a.tables,t):A(a.layers,t)}function A(r,t){const a=r.findIndex(({id:i})=>i===t.id);a===-1?r.push(t):r[a]=t}function D(r,t){if(!r.length)throw new u(`${t}:missing-parameters`,"'layers' array should contain at least one feature layer")}function X(r,t){const a=r.map(i=>i.portalItem.id);if(new Set(a).size>1)throw new u(`${t}:invalid-parameters`,"All layers in the 'layers' array should be loaded from the same portal item")}function U(r,t){const a=r.map(i=>i.layerId);if(new Set(a).size!==a.length)throw new u(`${t}:invalid-parameters`,"'layers' array should contain only one instance each of layer or table in a feature service")}async function rr(r){D(r,c),await Promise.all(r.map(t=>t.load()));for(const t of r)N(t,c,w),q({layer:t,itemType:d,errorNamePrefix:c});X(r,c),U(r,c)}async function tr(r,t){const{url:a,layerId:i,title:l,fullExtent:e,isTable:o}=r,s=y(a);t.url=(s==null?void 0:s.serverType)==="FeatureServer"?a:`${a}/${i}`,t.title||(t.title=l),t.extent=null,o||e==null||(t.extent=await L(e)),b(t,m.METADATA),b(t,m.MULTI_LAYER),S(t,m.SINGLE_LAYER),o&&S(t,m.TABLE)}function er(r,t){for(const e of r){const o=e.parsedUrl.path,s=y(o);if(!(s==null?void 0:s.url.path))throw new u(`${t}:invalid-parameters`,I(e,`has unsupported url pattern: ${o}`),{layer:e});const p=s==null?void 0:s.serverType;if(p!=="FeatureServer"&&p!=="MapServer")throw new u(`${t}:invalid-parameters`,I(e,`has unsupported server type: ${p}`),{layer:e});if(p==="MapServer"&&r.length>1)throw new u(`${t}:invalid-parameters`,"Only one layer or table in a map service can be saved")}const a=y(r[0].parsedUrl.path),i=a==null?void 0:a.url.path;if(!r.every(e=>{const o=y(e.parsedUrl.path);return(o==null?void 0:o.url.path)===i}))throw new u(`${t}:invalid-parameters`,"'layers' array should only contain layers or tables that belong to the same feature service")}async function ar(r){D(r,f),await Promise.all(r.map(t=>t.load()));for(const t of r)N(t,f,w);er(r,f),U(r,f)}async function or(r,t){let a=0,i=0;for(const{isTable:o}of t)o?i++:a++;const l=t[0].parsedUrl.path,e=y(l);if(r.url=(e==null?void 0:e.serverType)==="FeatureServer"?e.url.path:l,r.title||(r.title=e.title),r.extent=null,a>0){const o=t.map(s=>s.fullExtent).filter(_).reduce((s,n)=>s.clone().union(n));o&&(r.extent=await L(o))}b(r,m.METADATA),v(r,m.MULTI_LAYER,t.length>1),v(r,m.SINGLE_LAYER,t.length===1),v(r,m.TABLE,i>0&&a===0),E(r)}async function Ot(r,t){return B({layer:r,itemType:d,validateLayer:w,createItemData:(a,i)=>J(i,[a]),errorNamePrefix:C},t)}async function Jt(r,t){await rr(r);const a=r[0].portalItem,i=x(a),l=await Promise.all(r.map(o=>$(o,i,t))),e=await J(a,r.map((o,s)=>({layer:o,layerJSON:l[s]})));return E(a),await a.update({data:e}),await Promise.all(r.slice(1).map(o=>o.portalItem.reload())),P(i),a.clone()}async function Mt(r,t,a){return G({layer:r,itemType:d,validateLayer:w,createItemData:(i,l)=>Promise.resolve(O(i)),errorNamePrefix:H,newItem:t,setItemProperties:tr},a)}async function Rt(r,t,a){await ar(r);const i=j({itemType:d,errorNamePrefix:f,newItem:t}),l=x(i),e=await Promise.all(r.map(s=>$(s,l,a))),o=await M(r.map((s,n)=>({layer:s,layerJSON:e[n]})));await or(i,r),await k(i,o,a);for(const s of r)s.portalItem=i.clone();return P(l),i}export{Ot as save,Jt as saveAll,Rt as saveAllAs,Mt as saveAs};

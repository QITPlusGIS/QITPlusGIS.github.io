import{cq as Y,h as _,o as u}from"./uuid-11f8a774.js";import{i as P}from"./originUtils-cfe4feaf.js";import{Z as z}from"./FeatureLayer-c0885f3b.js";import{I as B,y as $,w as E,b as G,u as j,v as k,l as N,d as q,m as I}from"./utils-f3d2201f.js";import{p as y}from"./arcgisLayerUrl-f89b3daf.js";import{r as V}from"./fetchService-fab6d0ba.js";import{h as Z}from"./layerUtils-c5e7bd79.js";import{o as x}from"./jsonContext-f5673966.js";import{l as L,a as b,u as v,f as m,i as S}from"./portalItemUtils-0033aed5.js";import"./index-9591f551.js";import"./multiOriginJSONSupportUtils-c978f4c3.js";import"./UniqueValueRenderer-0326331a.js";import"./LegendOptions-204a2dae.js";import"./diffUtils-0fe85298.js";import"./SizeVariable-45541787.js";import"./colorRamps-1b6e24dc.js";import"./compilerUtils-4589e991.js";import"./lengthUtils-782f0f7c.js";import"./ColorStop-213c8cb4.js";import"./jsonUtils-e8038208.js";import"./styleUtils-3725741d.js";import"./jsonUtils-9eefcfc7.js";import"./DictionaryLoader-5dbec708.js";import"./LRUCache-7a50638a.js";import"./FieldsIndex-c32201a6.js";import"./heatmapUtils-f451477b.js";import"./vec4f64-3c9d0901.js";import"./MultiOriginJSONSupport-f9b5e427.js";import"./commonProperties-f89d14c0.js";import"./ElevationInfo-799a9463.js";import"./FeatureLayerBase-3df249b7.js";import"./Field-1a3f84f2.js";import"./fieldType-322546e5.js";import"./featureLayerUtils-6bc58f22.js";import"./Query-76befbe7.js";import"./FullTextSearch-9c3b6738.js";import"./QuantizationParameters-047a8fb0.js";import"./AttachmentQuery-f66519fc.js";import"./RelationshipQuery-86d00593.js";import"./LayerFloorInfo-c5010652.js";import"./serviceCapabilitiesUtils-d97f21eb.js";import"./workers-194c6572.js";import"./queryZScale-a1939753.js";import"./FeatureSet-59d81965.js";import"./APIKeyMixin-a201f929.js";import"./ArcGISService-7f066aea.js";import"./BlendLayer-8947abd2.js";import"./jsonUtils-c816488a.js";import"./parser-e8657b5e.js";import"./mat4f32-60a2394b.js";import"./mat4-a716043f.js";import"./CustomParametersMixin-4a5d03f4.js";import"./EditBusLayer-fe8c4a23.js";import"./FeatureEffectLayer-4b19d3ac.js";import"./FeatureEffect-ab0d1707.js";import"./FeatureReductionLayer-2b1f24c2.js";import"./clusterUtils-34ff746f.js";import"./MD5-715f37cd.js";import"./FeatureReductionSelection-0d9c5570.js";import"./LabelClass-e2fd4294.js";import"./labelUtils-64d01ef0.js";import"./defaultsJSON-b087dd4d.js";import"./OperationalLayer-61f7229f.js";import"./OrderedLayer-609b38d1.js";import"./PortalLayer-d38eb28e.js";import"./PortalItem-6e04dd29.js";import"./RefreshableLayer-4bf55224.js";import"./ScaleRangeLayer-66b933a4.js";import"./TemporalLayer-c4d663bb.js";import"./FeatureTemplate-f7d78c16.js";import"./FeatureType-5838f4bd.js";import"./fieldProperties-e6427986.js";import"./labelingInfo-efefa770.js";import"./versionUtils-40da0aad.js";import"./styleUtils-5d13f252.js";import"./TopFeaturesQuery-f3898e23.js";import"./popupUtils-d11912bd.js";import"./interfaces-f1f22245.js";import"./saveAPIKeyUtils-a02241fd.js";import"./requestPresets-68f0e98f.js";const d="Feature Service",h="feature-layer-utils",C=`${h}-save`,H=`${h}-save-as`,c=`${h}-saveall`,f=`${h}-saveall-as`;function w(r){return{isValid:Z(r)&&(r.type!=="feature"||!r.dynamicDataSource),errorMessage:"Feature layer should be a layer or table in a map or feature service"}}function g(r){const t=[],a=[];for(const{layer:i,layerJSON:l}of r)i.isTable?a.push(l):t.push(l);return{layers:t,tables:a}}function O(r){return g([r])}async function J(r,t){return/\/\d+\/?$/.test(r.url)?O(t[0]):M(t,r)}async function M(r,t){if(!t)return r.reverse(),g(r);const{layer:{url:a,customParameters:i,apiKey:l}}=r[0];let e=await t.fetchData("json");(e==null?void 0:e.layers)!=null&&(e==null?void 0:e.tables)!=null||(e=await Q(e,{url:a??"",customParameters:i,apiKey:l},r.map(o=>o.layer.layerId)));for(const o of r)R(o.layer,o.layerJSON,e);return e}async function Q(r,t,a){r||(r={}),r.layers||(r.layers=[]),r.tables||(r.tables=[]);const{url:i,customParameters:l,apiKey:e}=t,{serviceJSON:o,layersJSON:s}=await V(i,{customParameters:l,apiKey:e}),n=T(r.layers,o.layers,a),p=T(r.tables,o.tables,a);r.layers=n.itemResources,r.tables=p.itemResources;const F=[...n.added,...p.added],K=s?[...s.layers,...s.tables]:[];return await W(r,F,i,K),r}function T(r,t,a){const i=Y(r,t,(e,o)=>e.id===o.id);r=r.filter(e=>!i.removed.some(o=>o.id===e.id));const l=i.added.map(({id:e})=>({id:e}));return l.forEach(({id:e})=>{r.push({id:e})}),{itemResources:r,added:l.filter(({id:e})=>!a.includes(e))}}async function W(r,t,a,i){const l=t.map(({id:e})=>new z({url:a,layerId:e,sourceJSON:i.find(({id:o})=>o===e)}));await Promise.allSettled(l.map(e=>e.load())),l.forEach(e=>{const{layerId:o,loaded:s,defaultPopupTemplate:n}=e;!s||n==null||R(e,{id:o,popupInfo:n.toJSON()},r)})}function R(r,t,a){r.isTable?A(a.tables,t):A(a.layers,t)}function A(r,t){const a=r.findIndex(({id:i})=>i===t.id);a===-1?r.push(t):r[a]=t}function D(r,t){if(!r.length)throw new u(`${t}:missing-parameters`,"'layers' array should contain at least one feature layer")}function X(r,t){const a=r.map(i=>i.portalItem.id);if(new Set(a).size>1)throw new u(`${t}:invalid-parameters`,"All layers in the 'layers' array should be loaded from the same portal item")}function U(r,t){const a=r.map(i=>i.layerId);if(new Set(a).size!==a.length)throw new u(`${t}:invalid-parameters`,"'layers' array should contain only one instance each of layer or table in a feature service")}async function rr(r){D(r,c),await Promise.all(r.map(t=>t.load()));for(const t of r)N(t,c,w),q({layer:t,itemType:d,errorNamePrefix:c});X(r,c),U(r,c)}async function tr(r,t){const{url:a,layerId:i,title:l,fullExtent:e,isTable:o}=r,s=y(a);t.url=(s==null?void 0:s.serverType)==="FeatureServer"?a:`${a}/${i}`,t.title||(t.title=l),t.extent=null,o||e==null||(t.extent=await L(e)),b(t,m.METADATA),b(t,m.MULTI_LAYER),S(t,m.SINGLE_LAYER),o&&S(t,m.TABLE)}function er(r,t){for(const e of r){const o=e.parsedUrl.path,s=y(o);if(!(s==null?void 0:s.url.path))throw new u(`${t}:invalid-parameters`,I(e,`has unsupported url pattern: ${o}`),{layer:e});const p=s==null?void 0:s.serverType;if(p!=="FeatureServer"&&p!=="MapServer")throw new u(`${t}:invalid-parameters`,I(e,`has unsupported server type: ${p}`),{layer:e});if(p==="MapServer"&&r.length>1)throw new u(`${t}:invalid-parameters`,"Only one layer or table in a map service can be saved")}const a=y(r[0].parsedUrl.path),i=a==null?void 0:a.url.path;if(!r.every(e=>{const o=y(e.parsedUrl.path);return(o==null?void 0:o.url.path)===i}))throw new u(`${t}:invalid-parameters`,"'layers' array should only contain layers or tables that belong to the same feature service")}async function ar(r){D(r,f),await Promise.all(r.map(t=>t.load()));for(const t of r)N(t,f,w);er(r,f),U(r,f)}async function or(r,t){let a=0,i=0;for(const{isTable:o}of t)o?i++:a++;const l=t[0].parsedUrl.path,e=y(l);if(r.url=(e==null?void 0:e.serverType)==="FeatureServer"?e.url.path:l,r.title||(r.title=e.title),r.extent=null,a>0){const o=t.map(s=>s.fullExtent).filter(_).reduce((s,n)=>s.clone().union(n));o&&(r.extent=await L(o))}b(r,m.METADATA),v(r,m.MULTI_LAYER,t.length>1),v(r,m.SINGLE_LAYER,t.length===1),v(r,m.TABLE,i>0&&a===0),E(r)}async function Ot(r,t){return B({layer:r,itemType:d,validateLayer:w,createItemData:(a,i)=>J(i,[a]),errorNamePrefix:C},t)}async function Jt(r,t){await rr(r);const a=r[0].portalItem,i=x(a),l=await Promise.all(r.map(o=>$(o,i,t))),e=await J(a,r.map((o,s)=>({layer:o,layerJSON:l[s]})));return E(a),await a.update({data:e}),await Promise.all(r.slice(1).map(o=>o.portalItem.reload())),P(i),a.clone()}async function Mt(r,t,a){return G({layer:r,itemType:d,validateLayer:w,createItemData:(i,l)=>Promise.resolve(O(i)),errorNamePrefix:H,newItem:t,setItemProperties:tr},a)}async function Rt(r,t,a){await ar(r);const i=j({itemType:d,errorNamePrefix:f,newItem:t}),l=x(i),e=await Promise.all(r.map(s=>$(s,l,a))),o=await M(r.map((s,n)=>({layer:s,layerJSON:e[n]})));await or(i,r),await k(i,o,a);for(const s of r)s.portalItem=i.clone();return P(l),i}export{Ot as save,Jt as saveAll,Rt as saveAllAs,Mt as saveAs};

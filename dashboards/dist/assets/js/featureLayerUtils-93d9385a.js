import{o as P,g as Y,Z as _,p as f,k,l as $,a as b,u as v,f as u,h as z,s as p,i as I}from"./index-7a11ac30.js";import{i as E}from"./originUtils-cfe4feaf.js";import{I as B,y as N,w as x,b as G,u as j,v as V,l as L,d as Z,m as S}from"./utils-080ceae4.js";import{r as q}from"./fetchService-b7df8b56.js";import"./multiOriginJSONSupportUtils-c978f4c3.js";import"./saveAPIKeyUtils-12fb5bc7.js";import"./requestPresets-e712967c.js";const d="Feature Service",h="feature-layer-utils",C=`${h}-save`,H=`${h}-save-as`,m=`${h}-saveall`,y=`${h}-saveall-as`;function w(e){return{isValid:z(e)&&(e.type!=="feature"||!e.dynamicDataSource),errorMessage:"Feature layer should be a layer or table in a map or feature service"}}function g(e){const a=[],r=[];for(const{layer:l,layerJSON:o}of e)l.isTable?r.push(o):a.push(o);return{layers:a,tables:r}}function O(e){return g([e])}async function J(e,a){return/\/\d+\/?$/.test(e.url)?O(a[0]):M(a,e)}async function M(e,a){if(!a)return e.reverse(),g(e);const{layer:{url:r,customParameters:l,apiKey:o}}=e[0];let t=await a.fetchData("json");(t==null?void 0:t.layers)!=null&&(t==null?void 0:t.tables)!=null||(t=await Q(t,{url:r??"",customParameters:l,apiKey:o},e.map(s=>s.layer.layerId)));for(const s of e)R(s.layer,s.layerJSON,t);return t}async function Q(e,a,r){e||(e={}),e.layers||(e.layers=[]),e.tables||(e.tables=[]);const{url:l,customParameters:o,apiKey:t}=a,{serviceJSON:s,layersJSON:n}=await q(l,{customParameters:o,apiKey:t}),i=T(e.layers,s.layers,r),c=T(e.tables,s.tables,r);e.layers=i.itemResources,e.tables=c.itemResources;const F=[...i.added,...c.added],K=n?[...n.layers,...n.tables]:[];return await W(e,F,l,K),e}function T(e,a,r){const l=Y(e,a,(t,s)=>t.id===s.id);e=e.filter(t=>!l.removed.some(s=>s.id===t.id));const o=l.added.map(({id:t})=>({id:t}));return o.forEach(({id:t})=>{e.push({id:t})}),{itemResources:e,added:o.filter(({id:t})=>!r.includes(t))}}async function W(e,a,r,l){const o=a.map(({id:t})=>new _({url:r,layerId:t,sourceJSON:l.find(({id:s})=>s===t)}));await Promise.allSettled(o.map(t=>t.load())),o.forEach(t=>{const{layerId:s,loaded:n,defaultPopupTemplate:i}=t;!n||i==null||R(t,{id:s,popupInfo:i.toJSON()},e)})}function R(e,a,r){e.isTable?A(r.tables,a):A(r.layers,a)}function A(e,a){const r=e.findIndex(({id:l})=>l===a.id);r===-1?e.push(a):e[r]=a}function D(e,a){if(!e.length)throw new p(`${a}:missing-parameters`,"'layers' array should contain at least one feature layer")}function X(e,a){const r=e.map(l=>l.portalItem.id);if(new Set(r).size>1)throw new p(`${a}:invalid-parameters`,"All layers in the 'layers' array should be loaded from the same portal item")}function U(e,a){const r=e.map(l=>l.layerId);if(new Set(r).size!==r.length)throw new p(`${a}:invalid-parameters`,"'layers' array should contain only one instance each of layer or table in a feature service")}async function ee(e){D(e,m),await Promise.all(e.map(a=>a.load()));for(const a of e)L(a,m,w),Z({layer:a,itemType:d,errorNamePrefix:m});X(e,m),U(e,m)}async function ae(e,a){const{url:r,layerId:l,title:o,fullExtent:t,isTable:s}=e,n=f(r);a.url=(n==null?void 0:n.serverType)==="FeatureServer"?r:`${r}/${l}`,a.title||(a.title=o),a.extent=null,s||t==null||(a.extent=await $(t)),b(a,u.METADATA),b(a,u.MULTI_LAYER),I(a,u.SINGLE_LAYER),s&&I(a,u.TABLE)}function te(e,a){for(const t of e){const s=t.parsedUrl.path,n=f(s);if(!(n==null?void 0:n.url.path))throw new p(`${a}:invalid-parameters`,S(t,`has unsupported url pattern: ${s}`),{layer:t});const c=n==null?void 0:n.serverType;if(c!=="FeatureServer"&&c!=="MapServer")throw new p(`${a}:invalid-parameters`,S(t,`has unsupported server type: ${c}`),{layer:t});if(c==="MapServer"&&e.length>1)throw new p(`${a}:invalid-parameters`,"Only one layer or table in a map service can be saved")}const r=f(e[0].parsedUrl.path),l=r==null?void 0:r.url.path;if(!e.every(t=>{const s=f(t.parsedUrl.path);return(s==null?void 0:s.url.path)===l}))throw new p(`${a}:invalid-parameters`,"'layers' array should only contain layers or tables that belong to the same feature service")}async function re(e){D(e,y),await Promise.all(e.map(a=>a.load()));for(const a of e)L(a,y,w);te(e,y),U(e,y)}async function se(e,a){let r=0,l=0;for(const{isTable:s}of a)s?l++:r++;const o=a[0].parsedUrl.path,t=f(o);if(e.url=(t==null?void 0:t.serverType)==="FeatureServer"?t.url.path:o,e.title||(e.title=t.title),e.extent=null,r>0){const s=a.map(n=>n.fullExtent).filter(k).reduce((n,i)=>n.clone().union(i));s&&(e.extent=await $(s))}b(e,u.METADATA),v(e,u.MULTI_LAYER,a.length>1),v(e,u.SINGLE_LAYER,a.length===1),v(e,u.TABLE,l>0&&r===0),x(e)}async function me(e,a){return B({layer:e,itemType:d,validateLayer:w,createItemData:(r,l)=>J(l,[r]),errorNamePrefix:C},a)}async function ye(e,a){await ee(e);const r=e[0].portalItem,l=P(r),o=await Promise.all(e.map(s=>N(s,l,a))),t=await J(r,e.map((s,n)=>({layer:s,layerJSON:o[n]})));return x(r),await r.update({data:t}),await Promise.all(e.slice(1).map(s=>s.portalItem.reload())),E(l),r.clone()}async function fe(e,a,r){return G({layer:e,itemType:d,validateLayer:w,createItemData:(l,o)=>Promise.resolve(O(l)),errorNamePrefix:H,newItem:a,setItemProperties:ae},r)}async function de(e,a,r){await re(e);const l=j({itemType:d,errorNamePrefix:y,newItem:a}),o=P(l),t=await Promise.all(e.map(n=>N(n,o,r))),s=await M(e.map((n,i)=>({layer:n,layerJSON:t[i]})));await se(l,e),await V(l,s,r);for(const n of e)n.portalItem=l.clone();return E(o),l}export{me as save,ye as saveAll,de as saveAllAs,fe as saveAs};

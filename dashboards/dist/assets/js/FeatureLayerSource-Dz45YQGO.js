const __vite__mapDeps=(i,m=__vite__mapDeps,d=(m.f||(m.f=["./uploadAssets-ChfjPi8S.js","./uuid-De2V3pkO.js","./index-OAJD89tD.js","./External-CSsgmrs6.js","./infoFor3D-CKoUGm1M.js","./arcgisLayerUrl-DMpJLG2u.js"])))=>i.map(i=>d[i]);
import{_ as P}from"./index-OAJD89tD.js";import{o as A,eM as T,s as _,eN as j,g as L,a7 as Q,m as D,dm as V,a5 as N,z as y,h as v,R as C,A as G,S as z,bt as M,eO as H,ai as W,X,ct as Y,N as Z,a as I,y as $,c as B}from"./uuid-De2V3pkO.js";import{F as K,b as tt,c as et,w as at}from"./arcgisLayerUrl-DMpJLG2u.js";import{q as rt}from"./mat4-DR7ljCfE.js";import{e as st}from"./mat4f64-D0ba0WBC.js";import{m as it}from"./MeshGeoreferencedRelativeVertexSpace-BdbsO6h6.js";import{r as ot}from"./vec32-RqERiiwD.js";import{v as nt}from"./External-CSsgmrs6.js";import{isFeatureIdentifierArrayWithGlobalId as ut,isFeatureIdentifierArrayWithObjectId as lt}from"./editingSupport-D5I07PLd.js";import{o as ct}from"./clientSideDefaults-Y_HJrJZ_.js";import{x as dt}from"./QueryTask-Gy5mxTux.js";import{Q as O}from"./featureLayerUtils-JQb3hLRE.js";import{F as pt}from"./infoFor3D-CKoUGm1M.js";import{s as mt}from"./executeQueryJSON-BPmRxjW1.js";import{i as ht}from"./FeatureLayer-XPLTGHtu.js";import{b as yt}from"./Query-CEg5oX17.js";import{s as ft,a as gt,r as bt}from"./EditBusLayer-Z-bxRsy2.js";import"./normalizeUtils-CHaYFzrc.js";import"./normalizeUtilsCommon-vfKhPTnw.js";import"./layerUtils-D8dZn4eh.js";import"./QueryEngineCapabilities-CTDe3LlQ.js";import"./defaultsJSON-CHAaurhX.js";import"./executeForIds-DVUzyPe5.js";import"./query-Dc0QFYci.js";import"./pbfQueryUtils-CF_kx7yC.js";import"./pbf-Jel0b315.js";import"./OptimizedFeature-CuDeWVOV.js";import"./OptimizedFeatureSet-Blu9Ckm7.js";import"./queryZScale-BHsgP0Ac.js";import"./executeQueryPBF-cAc13GFo.js";import"./featureConversionUtils-BBvLZPS5.js";import"./FeatureSet-B32diVNL.js";import"./Field-CpwGNSHU.js";import"./fieldType-CQ9t6Wui.js";import"./jsonUtils-CshCi2EU.js";import"./UniqueValueRenderer-DdZymv08.js";import"./LegendOptions-FRTnoArL.js";import"./diffUtils-B9GaWVUW.js";import"./SizeVariable-CEwBbtT1.js";import"./colorRamps-BC6MwlXc.js";import"./compilerUtils-BndV9QTL.js";import"./lengthUtils-C4EPlNSZ.js";import"./ColorStop-B_V1vtMl.js";import"./jsonUtils-CqYY9-3B.js";import"./styleUtils-IlLdeGfy.js";import"./DictionaryLoader-Bl9OQ4Ss.js";import"./LRUCache-DMLtX-OB.js";import"./FieldsIndex-dTLkFgHd.js";import"./heatmapUtils-DncJMPvQ.js";import"./vec4f64-Jk3PXxMO.js";import"./AttachmentQuery-BX_2HFsg.js";import"./RelationshipQuery-CSVnFDD7.js";import"./FullTextSearch-C1te3nF2.js";import"./QuantizationParameters-DrrRb5JH.js";import"./MultiOriginJSONSupport-Df7Mn0iX.js";import"./commonProperties-7y88ic0r.js";import"./ElevationInfo-C7w4yfnq.js";import"./FeatureLayerBase-Vxy7-5Ka.js";import"./LayerFloorInfo-DRZBdyCP.js";import"./serviceCapabilitiesUtils-BVYFxrwG.js";import"./workers-Dp_XhR59.js";import"./APIKeyMixin-CcEMCMh8.js";import"./ArcGISService-B9AkhE_C.js";import"./BlendLayer-4Nq3kFEk.js";import"./jsonUtils-Ds9cu0Qh.js";import"./parser-CQvYRaWk.js";import"./mat4f32-BYh1DbDV.js";import"./CustomParametersMixin-B-WvQlLz.js";import"./FeatureEffectLayer-C-VkqhLI.js";import"./FeatureEffect-D6mxFSco.js";import"./FeatureReductionLayer-CMPQavUU.js";import"./clusterUtils-CBl3uOAm.js";import"./MD5-MtSiOt06.js";import"./FeatureReductionSelection-BdTwQHJB.js";import"./LabelClass-5BgkMgGD.js";import"./labelUtils-Dph0uXsk.js";import"./OperationalLayer-Bx6pTHh7.js";import"./OrderedLayer-CDjvvtKC.js";import"./PortalLayer-DU1TFOEn.js";import"./PortalItem-C8IOgJp9.js";import"./portalItemUtils-2ng-Kvae.js";import"./RefreshableLayer-BEFOmf5k.js";import"./ScaleRangeLayer-cDV6S-UX.js";import"./TemporalLayer-B6MVRSR-.js";import"./FeatureTemplate-CuIcCtQS.js";import"./FeatureType-okWbna3M.js";import"./fieldProperties-BBmuKf7F.js";import"./labelingInfo-C5rI8Tdf.js";import"./versionUtils-go49xXEj.js";import"./styleUtils-CfnOzvk7.js";import"./TopFeaturesQuery-BR6kql40.js";import"./popupUtils-tKvJKde2.js";import"./interfaces-CL2NbQte.js";function wt(t){const{vertexSpace:e}=t;if(e.isRelative)return t.clone();const{anchor:a}=t,r=a.clone(),s=rt(Rt,[-r.x,-r.y,-r.z]),i=new it({origin:[r.x,r.y,r.z]}),o=t.cloneWithVertexSpace(i),{position:n}=o.vertexAttributes;return o.vertexAttributes.position=ot(new Float64Array(n.length),n,s),o.vertexAttributesChanged(),o}const Rt=st();async function J(t,e,a){const{geometry:r}=e,s={...e.attributes};if(a!=null&&r?.type==="mesh"){const{transformFieldRoles:i}=a,{origin:o,spatialReference:n,transform:u}=r,l=t.spatialReference;await K(n,l);const d=tt(o,l);if(s[i.originX]=d.x,s[i.originY]=d.y,s[i.originZ]=d.z??0,u!=null){const{translation:h,scale:p,rotation:f}=u,{vertexSpace:w}=r,c=w.isGeoreferenced?1:T(n)/T(l);s[i.translationX]=h[0]*c,s[i.translationY]=h[2]*c,s[i.translationZ]=-h[1]*c,s[i.scaleX]=p[0],s[i.scaleY]=p[2],s[i.scaleZ]=p[1],s[i.rotationX]=f[0],s[i.rotationY]=f[2],s[i.rotationZ]=-f[1],s[i.rotationDeg]=f[3]}return{attributes:s}}return r==null?{attributes:s}:r.type==="mesh"||r.type==="extent"?null:{geometry:r.toJSON(),attributes:s}}async function St(t,e){const a=await Promise.all((e.addAttachments??[]).map((i=>k(t,i)))),r=await Promise.all((e.updateAttachments??[]).map((i=>k(t,i)))),s=e.deleteAttachments??[];return a.length||r.length||s.length?{adds:a,updates:r,deletes:[...s]}:null}async function k(t,e){const{feature:a,attachment:r}=e,{globalId:s,name:i,contentType:o,data:n,uploadId:u}=r,l={globalId:s};if(a&&("attributes"in a?l.parentGlobalId=a.attributes?.[t.globalIdField]:a.globalId&&(l.parentGlobalId=a.globalId)),u)l.uploadId=u;else if(n){const d=await j(n);d&&(l.contentType=d.mediaType,l.data=d.data),n instanceof File&&(l.name=n.name)}return i&&(l.name=i),o&&(l.contentType=o),l}function qt(t,e,a){if(!e||e.length===0)return[];if(a&&ut(e))return e.map((s=>s.globalId));if(lt(e))return e.map((s=>s.objectId));const r=a?t.globalIdField:t.objectIdField;return r?e.map((s=>s.getAttribute(r))):[]}function At(t){const e=t?.assetMaps;if(e){for(const s of e.addResults)s.success||_.getLogger("esri.layers.graphics.sources.support.sourceUtils").error(`Failed to map asset to feature with globalId ${s.globalId}.`);for(const s of e.updateResults)s.success||_.getLogger("esri.layers.graphics.sources.support.sourceUtils").error(`Failed to map asset to feature with globalId ${s.globalId}.`)}const a=t?.attachments,r={addFeatureResults:t?.addResults?.map(b)??[],updateFeatureResults:t?.updateResults?.map(b)??[],deleteFeatureResults:t?.deleteResults?.map(b)??[],addAttachmentResults:a?.addResults?a.addResults.map(b):[],updateAttachmentResults:a?.updateResults?a.updateResults.map(b):[],deleteAttachmentResults:a?.deleteResults?a.deleteResults.map(b):[]};return t?.editMoment&&(r.editMoment=t.editMoment),r}function b(t){const e=t.success===!0?null:t.error||{code:void 0,description:void 0};return{objectId:t.objectId,globalId:t.globalId,error:e?new A("feature-layer-source:edit-failure",e.description,{code:e.code}):null}}function E(t,e){return new L({attributes:t.attributes,geometry:Q({...t.geometry,spatialReference:e})})}function Ft(t,e){return{adds:t?.adds?.map((a=>E(a,e)))||[],updates:t?.updates?.map((a=>({original:E(a[0],e),current:E(a[1],e)})))||[],deletes:t?.deletes?.map((a=>E(a,e)))||[],spatialReference:e}}function It(t){const e=t.details.raw,a=+e.code,r=+e.extendedCode;return a===500&&(r===-2147217144||r===-2147467261)}const Ot=new C({originalAndCurrentFeatures:"original-and-current-features",none:"none"}),Et=new Set(["Feature Layer","Oriented Imagery Layer","Table"]),_t=new C({Started:"published",Publishing:"publishing",Stopped:"unavailable"});let S=class extends D{constructor(){super(...arguments),this.type="feature-layer",this.refresh=V((async()=>{await this.load();const t=this.sourceJSON.editingInfo?.lastEditDate;if(t==null)return{dataChanged:!0,updates:{}};try{await this._fetchService(null)}catch{return{dataChanged:!0,updates:{}}}const e=t!==this.sourceJSON.editingInfo?.lastEditDate;return{dataChanged:e,updates:e?{editingInfo:this.sourceJSON.editingInfo,extent:this.sourceJSON.extent}:null}})),this._ongoingAssetUploads=new Map}load(t){const e=this.layer.sourceJSON,a=this._fetchService(e,{...t}).then((()=>this.layer.setUserPrivileges(this.sourceJSON.serviceItemId,t))).then((()=>this._ensureLatestMetadata(t)));return this.addResolvingPromise(a),Promise.resolve(this)}get queryTask(){const{capabilities:t,parsedUrl:e,dynamicDataSource:a,infoFor3D:r,gdbVersion:s,spatialReference:i,fieldsIndex:o}=this.layer,n=N("featurelayer-pbf")&&t?.query.supportsFormatPBF&&r==null,u=t?.operations?.supportsQueryAttachments??!1;return new dt({url:e.path,pbfSupported:n,fieldsIndex:o,infoFor3D:r,dynamicDataSource:a,gdbVersion:s,sourceSpatialReference:i,queryAttachmentsSupported:u})}async addAttachment(t,e){await this.load();const{layer:a}=this;await O(a,"editing");const r=t.attributes[a.objectIdField],s=a.parsedUrl.path+"/"+r+"/addAttachment",i=this._getLayerRequestOptions(),o=this._getFormDataForAttachment(e,i.query);try{const n=await y(s,{body:o});return b(n.data.addAttachmentResult)}catch(n){throw this._createAttachmentErrorResult(r,n)}}async updateAttachment(t,e,a){await this.load();const{layer:r}=this;await O(r,"editing");const s=t.attributes[r.objectIdField],i=r.parsedUrl.path+"/"+s+"/updateAttachment",o=this._getLayerRequestOptions({query:{attachmentId:e}}),n=this._getFormDataForAttachment(a,o.query);try{const u=await y(i,{body:n});return b(u.data.updateAttachmentResult)}catch(u){throw this._createAttachmentErrorResult(s,u)}}async applyEdits(t,e){await this.load();const{layer:a}=this;await O(a,"editing");const r=a.infoFor3D,s=r!=null,i=s||(e?.globalIdUsed??!1),o=s?await this._uploadMeshesAndGetAssetMapEditsJSON(t):null,n=t.addFeatures?.map((m=>J(this.layer,m,r)))??[],u=(await Promise.all(n)).filter(v),l=t.updateFeatures?.map((m=>J(this.layer,m,r)))??[],d=(await Promise.all(l)).filter(v),h=qt(this.layer,t.deleteFeatures,i);ht(u,d,a.spatialReference);const p=await St(this.layer,t),f=a.capabilities.editing.supportsAsyncApplyEdits&&s,w=e?.gdbVersion||a.gdbVersion,c={gdbVersion:w,rollbackOnFailure:e?.rollbackOnFailureEnabled,useGlobalIds:i,returnEditMoment:e?.returnEditMoment,usePreviousEditMoment:e?.usePreviousEditMoment,async:f};await ft(this.layer.url,w,!0);const F=gt(this.layer.url,w||null);e?.returnServiceEditsOption?(c.edits=JSON.stringify([{id:a.layerId,adds:u,updates:d,deletes:h,attachments:p,assetMaps:o}]),c.returnServiceEditsOption=Ot.toJSON(e?.returnServiceEditsOption),c.returnServiceEditsInSourceSR=e?.returnServiceEditsInSourceSR):(c.adds=u.length?JSON.stringify(u):null,c.updates=d.length?JSON.stringify(d):null,c.deletes=h.length?i?JSON.stringify(h):h.join(","):null,c.attachments=p&&JSON.stringify(p),c.assetMaps=o!=null?JSON.stringify(o):void 0);const g=this._getLayerRequestOptions({method:"post",query:c});F&&(g.authMode="immediate",g.query.returnEditMoment=!0,g.query.sessionId=bt);const R=e?.returnServiceEditsOption?a.url:a.parsedUrl.path;let q;try{q=f?await this._asyncApplyEdits(R+"/applyEdits",g):await y(R+"/applyEdits",g)}catch(m){if(!It(m))throw m;g.authMode="immediate",q=f?await this._asyncApplyEdits(R+"/applyEdits",g):await y(R+"/applyEdits",g)}return!a.capabilities.operations?.supportsEditing&&a.effectiveCapabilities?.operations?.supportsEditing&&await G?.findCredential(a.url)?.refreshToken(),this._createEditsResult(q)}async deleteAttachments(t,e){await this.load();const{layer:a}=this;await O(a,"editing");const r=t.attributes[a.objectIdField],s=a.parsedUrl.path+"/"+r+"/deleteAttachments";try{return(await y(s,this._getLayerRequestOptions({query:{attachmentIds:e.join(",")},method:"post"}))).data.deleteAttachmentResults.map(b)}catch(i){throw this._createAttachmentErrorResult(r,i)}}fetchRecomputedExtents(t={}){const e=t.signal;return this.load({signal:e}).then((async()=>{const a=this._getLayerRequestOptions({...t,query:{returnUpdates:!0}}),{layerId:r,url:s}=this.layer,{data:i}=await y(`${s}/${r}`,a),{id:o,extent:n,fullExtent:u,timeExtent:l}=i,d=n||u;return{id:o,fullExtent:d&&z.fromJSON(d),timeExtent:l&&et.fromJSON({start:l[0],end:l[1]})}}))}async queryAttachments(t,e={}){await this.load();const a=this._getLayerRequestOptions(e);return this.queryTask.executeAttachmentQuery(t,a)}async queryFeatures(t,e){await this.load();const a=await this.queryTask.execute(t,{...e,query:this._createRequestQueryOptions(e)});return t.outStatistics?.length&&a.features.length&&a.features.forEach((r=>{const s=r.attributes;t.outStatistics?.forEach((({outStatisticFieldName:i})=>{if(i){const o=i.toLowerCase();o&&o in s&&i!==o&&(s[i]=s[o],delete s[o])}}))})),a}async queryFeaturesJSON(t,e){return await this.load(),this.queryTask.executeJSON(t,{...e,query:this._createRequestQueryOptions(e)})}async queryObjectIds(t,e){return await this.load(),this.queryTask.executeForIds(t,{...e,query:this._createRequestQueryOptions(e)})}async queryFeatureCount(t,e){return await this.load(),this.queryTask.executeForCount(t,{...e,query:this._createRequestQueryOptions(e)})}async queryExtent(t,e){return await this.load(),this.queryTask.executeForExtent(t,{...e,query:this._createRequestQueryOptions(e)})}async queryRelatedFeatures(t,e){return await this.load(),this.queryTask.executeRelationshipQuery(t,{...e,query:this._createRequestQueryOptions(e)})}async queryRelatedFeaturesCount(t,e){return await this.load(),this.queryTask.executeRelationshipQueryForCount(t,{...e,query:this._createRequestQueryOptions(e)})}async queryTopFeatures(t,e){return await this.load(),this.queryTask.executeTopFeaturesQuery(t,{...e,query:this._createRequestQueryOptions(e)})}async queryTopObjectIds(t,e){return await this.load(),this.queryTask.executeForTopIds(t,{...e,query:this._createRequestQueryOptions(e)})}async queryTopExtents(t,e){return await this.load(),this.queryTask.executeForTopExtents(t,{...e,query:this._createRequestQueryOptions(e)})}async queryTopCount(t,e){return await this.load(),this.queryTask.executeForTopCount(t,{...e,query:this._createRequestQueryOptions(e)})}async fetchPublishingStatus(){if(!at(this.layer.url))return"unavailable";const t=M(this.layer.url,"status"),e=await y(t,{query:{f:"json"}});return _t.fromJSON(e.data.status)}async uploadAssets(t,e){const{uploadAssets:a}=await P(()=>import("./uploadAssets-ChfjPi8S.js"),__vite__mapDeps([0,1,2,3,4,5]),import.meta.url);return a(t,{layer:this.layer,ongoingUploads:this._ongoingAssetUploads},e)}async _asyncApplyEdits(t,e){const a=(await y(t,e)).data.statusUrl;for(;;){const r=(await y(a,{query:{f:"json"},responseType:"json"})).data;switch(r.status){case"Completed":return y(r.resultUrl,{query:{f:"json"},responseType:"json"});case"CompletedWithErrors":throw new A("async-applyEdits-failed","asynchronous applyEdits call failed.");case"Failed ImportChanges":case"InProgress":case"Pending":case"ExportAttachments":case"ExportChanges":case"ExportingData":case"ExportingSnapshot":case"ImportAttachments":case"ProvisioningReplica":case"UnRegisteringReplica":break;default:throw new A("async-applyEdits-failed","asynchronous applyEdits call failed (undefined response status)")}await H(xt)}}_createRequestQueryOptions(t){const e={...this.layer.customParameters,token:this.layer.apiKey,...t?.query};return this.layer.datesInUnknownTimezone&&(e.timeReferenceUnknownClient=!0),e}async _fetchService(t,e){if(!t){const r={};N("featurelayer-advanced-symbols")&&(r.returnAdvancedSymbols=!0),e?.cacheBust&&(r._ts=Date.now());const{data:s}=await y(this.layer.parsedUrl.path,this._getLayerRequestOptions({query:r,signal:e?.signal}));t=s}this.sourceJSON=await this._patchServiceJSON(t,e?.signal);const a=t.type;if(!Et.has(a))throw new A("feature-layer-source:unsupported-type",`Source type "${a}" is not supported`)}async _patchServiceJSON(t,e){if(t.type!=="Table"&&t.geometryType&&!t?.drawingInfo?.renderer&&!t.defaultSymbol){const a=ct(t.geometryType).renderer;W("drawingInfo.renderer",a,t)}if(t.geometryType==="esriGeometryMultiPatch"&&t.infoFor3D&&(t.geometryType="mesh"),t.extent==null)try{const{data:a}=await y(this.layer.url,this._getLayerRequestOptions({signal:e}));a.spatialReference&&(t.extent={xmin:0,ymin:0,xmax:0,ymax:0,spatialReference:a.spatialReference})}catch(a){X(a)}return t}async _ensureLatestMetadata(t){if(this.layer.userHasUpdateItemPrivileges&&this.sourceJSON.cacheMaxAge>0)return this._fetchService(null,{...t,cacheBust:!0})}async _uploadMeshesAndGetAssetMapEditsJSON(t){const{addAssetFeatures:e}=t;if(!e?.length)return null;const a=await this._filterRedundantAssetMaps(e);if(!e?.length)return null;const r=new Array,s=new Map;for(const i of a){const{geometry:o}=i,{vertexSpace:n}=o;if(n.isRelative)r.push(o);else{const u=wt(o);s.set(u,o),i.geometry=u,r.push(u)}}await this.uploadAssets(r);for(const[i,o]of s)o.addExternalSources(i.metadata.externalSources.items);return{adds:this._getAssetMapEditsJSON(a),updates:[],deletes:[]}}_getAssetMapEditsJSON(t){const e=new Array,a=this.layer.globalIdField,r=this.layer.parsedUrl;for(const s of t){const i=s.geometry,{metadata:o}=i,n=o.getExternalSourcesOnService(r),u=s.getAttribute(a);if(n.length===0){_.getLogger(this).error(`Skipping feature ${u}. The mesh it is associated with has not been uploaded to the service and cannot be mapped to it.`);continue}const{source:l}=n.find(nt)??n[0],{vertexSpace:d}=i,h=d.isGeoreferenced?["PROJECT_VERTICES"]:[];for(const p of l)p.parts.length===1?e.push({globalId:Y(),parentGlobalId:u,assetName:p.assetName,assetHash:p.parts[0].partHash,flags:h}):_.getLogger(this).error(`Skipping asset ${p.assetName}. It does not have exactly one part, so we cannot map it to a feature.`)}return e}_createEditsResult(t){const e=t.data,{layerId:a}=this.layer,r=[];let s=null;if(Array.isArray(e))for(const o of e)r.push({id:o.id,editedFeatures:o.editedFeatures}),o.id===a&&(s={addResults:o.addResults??[],updateResults:o.updateResults??[],deleteResults:o.deleteResults??[],attachments:o.attachments,editMoment:o.editMoment});else s=e;const i=At(s);if(r.length>0){i.editedFeatureResults=[];for(const o of r){const{editedFeatures:n}=o,u=n?.spatialReference?new Z(n.spatialReference):null;i.editedFeatureResults.push({layerId:o.id,editedFeatures:Ft(n,u)})}}return i}_createAttachmentErrorResult(t,e){const a=e.details.messages?.[0]||e.message,r=e.details.httpStatus||e.details.messageCode;return{objectId:t,globalId:null,error:new A("feature-layer-source:attachment-failure",a,{code:r})}}_getFormDataForAttachment(t,e){const a=t instanceof FormData?t:t&&t.elements?new FormData(t):null;if(a)for(const r in e){const s=e[r];s!=null&&(a.set?a.set(r,s):a.append(r,s))}return a}_getLayerRequestOptions(t={}){const{parsedUrl:e,gdbVersion:a,dynamicDataSource:r}=this.layer;return{...t,query:{gdbVersion:a,layer:r?JSON.stringify({source:r}):void 0,...e.query,f:"json",...this._createRequestQueryOptions(t)},responseType:"json"}}async _filterRedundantAssetMaps(t){const{layer:e}=this,{globalIdField:a,infoFor3D:r,parsedUrl:s}=e;if(r==null||a==null)return t;const i=pt(r);if(i==null)return t;const o=M(s.path,`../${i.id}`),n=new Array,u=new Array;for(const c of t)c.geometry.metadata.getExternalSourcesOnService(s).length>0?u.push(c):n.push(c);const l=u.map((c=>c.getAttribute(a))).filter(v);if(l.length===0)return t;const{assetMapFieldRoles:{parentGlobalId:d,assetHash:h}}=r,p=new yt;p.where=`${d} IN (${l.map((c=>`'${c}'`))})`,p.outFields=[h,d],p.returnGeometry=!1;const f=await mt(o,p),{features:w}=f;return w.length===0?t:[...n,...u.filter((c=>{const F=c.getAttribute(a);if(!F)return!0;const{metadata:g}=c.geometry,R=w.filter((m=>m.getAttribute(d)===F));if(R.length===0)return!0;const q=R.map((m=>m.getAttribute(h)));return g.getExternalSourcesOnService(s).flatMap((({source:m})=>m.flatMap((x=>x.parts.map((U=>U.partHash)))))).some((m=>q.every((x=>m!==x))))}))]}};I([$()],S.prototype,"type",void 0),I([$({constructOnly:!0})],S.prototype,"layer",void 0),I([$({readOnly:!0})],S.prototype,"queryTask",null),S=I([B("esri.layers.graphics.sources.FeatureLayerSource")],S);const xt=1e3,ya=S;export{ya as default};

import{cq as Y,h as _,o as u}from"./uuid-fb53ae2e.js";import{i as P}from"./originUtils-cfe4feaf.js";import{Z as z}from"./FeatureLayer-82c27456.js";import{I as B,y as $,w as E,b as G,u as j,v as k,l as N,d as q,m as I}from"./utils-aed3ba0b.js";import{p as y}from"./arcgisLayerUrl-fc2d909c.js";import{r as V}from"./fetchService-7c55146c.js";import{h as Z}from"./layerUtils-a8920453.js";import{o as x}from"./jsonContext-1d02b744.js";import{l as L,a as b,u as v,f as m,i as S}from"./portalItemUtils-064daa72.js";import"./index-e42a63f9.js";import"./multiOriginJSONSupportUtils-c978f4c3.js";import"./UniqueValueRenderer-eeb3ca28.js";import"./LegendOptions-21ba0c6d.js";import"./diffUtils-7a67a389.js";import"./SizeVariable-d8011d21.js";import"./colorRamps-18dfa72a.js";import"./compilerUtils-811a6f43.js";import"./lengthUtils-5d9bdf3f.js";import"./ColorStop-4bfca0a7.js";import"./jsonUtils-6741d81c.js";import"./styleUtils-957365ee.js";import"./jsonUtils-ca31df3a.js";import"./DictionaryLoader-153eea1f.js";import"./LRUCache-9b8f5520.js";import"./FieldsIndex-406a2400.js";import"./heatmapUtils-c2569515.js";import"./vec4f64-3c9d0901.js";import"./MultiOriginJSONSupport-0ac2102c.js";import"./commonProperties-dc1396d3.js";import"./ElevationInfo-c9711b5d.js";import"./FeatureLayerBase-031726c8.js";import"./Field-2e745f35.js";import"./fieldType-5ce7d1ed.js";import"./featureLayerUtils-e818abf0.js";import"./Query-56eb5454.js";import"./FullTextSearch-92b839ce.js";import"./QuantizationParameters-a323cbe3.js";import"./AttachmentQuery-293581a3.js";import"./RelationshipQuery-c73acba6.js";import"./LayerFloorInfo-5a946a6e.js";import"./serviceCapabilitiesUtils-4afaedbc.js";import"./workers-3c8ba252.js";import"./queryZScale-45e23751.js";import"./FeatureSet-46acd907.js";import"./APIKeyMixin-e0a32935.js";import"./ArcGISService-73c5a696.js";import"./BlendLayer-840b2c27.js";import"./jsonUtils-2946bd15.js";import"./parser-450a99c3.js";import"./mat4f32-60a2394b.js";import"./mat4-f091cc2b.js";import"./CustomParametersMixin-b959de81.js";import"./EditBusLayer-bfd28f9d.js";import"./FeatureEffectLayer-3b8f0448.js";import"./FeatureEffect-3edf5c32.js";import"./FeatureReductionLayer-d08e423b.js";import"./clusterUtils-80867c68.js";import"./MD5-715f37cd.js";import"./FeatureReductionSelection-29ad62c4.js";import"./LabelClass-03af2031.js";import"./labelUtils-f4e57b25.js";import"./defaultsJSON-b087dd4d.js";import"./OperationalLayer-37855d78.js";import"./OrderedLayer-4f625116.js";import"./PortalLayer-5667eeff.js";import"./PortalItem-01395053.js";import"./RefreshableLayer-a50327d1.js";import"./ScaleRangeLayer-f6774238.js";import"./TemporalLayer-938bf204.js";import"./FeatureTemplate-a4a4ff4d.js";import"./FeatureType-233007f9.js";import"./fieldProperties-a1eafbe1.js";import"./labelingInfo-144cafce.js";import"./versionUtils-3d1d9820.js";import"./styleUtils-acaf630f.js";import"./TopFeaturesQuery-2a03aa6d.js";import"./popupUtils-7cecbe49.js";import"./interfaces-f1f22245.js";import"./saveAPIKeyUtils-4a19a7b5.js";import"./requestPresets-25d3d846.js";const d="Feature Service",h="feature-layer-utils",C=`${h}-save`,H=`${h}-save-as`,c=`${h}-saveall`,f=`${h}-saveall-as`;function w(r){return{isValid:Z(r)&&(r.type!=="feature"||!r.dynamicDataSource),errorMessage:"Feature layer should be a layer or table in a map or feature service"}}function g(r){const t=[],a=[];for(const{layer:i,layerJSON:l}of r)i.isTable?a.push(l):t.push(l);return{layers:t,tables:a}}function O(r){return g([r])}async function J(r,t){return/\/\d+\/?$/.test(r.url)?O(t[0]):M(t,r)}async function M(r,t){if(!t)return r.reverse(),g(r);const{layer:{url:a,customParameters:i,apiKey:l}}=r[0];let e=await t.fetchData("json");(e==null?void 0:e.layers)!=null&&(e==null?void 0:e.tables)!=null||(e=await Q(e,{url:a??"",customParameters:i,apiKey:l},r.map(o=>o.layer.layerId)));for(const o of r)R(o.layer,o.layerJSON,e);return e}async function Q(r,t,a){r||(r={}),r.layers||(r.layers=[]),r.tables||(r.tables=[]);const{url:i,customParameters:l,apiKey:e}=t,{serviceJSON:o,layersJSON:s}=await V(i,{customParameters:l,apiKey:e}),n=T(r.layers,o.layers,a),p=T(r.tables,o.tables,a);r.layers=n.itemResources,r.tables=p.itemResources;const F=[...n.added,...p.added],K=s?[...s.layers,...s.tables]:[];return await W(r,F,i,K),r}function T(r,t,a){const i=Y(r,t,(e,o)=>e.id===o.id);r=r.filter(e=>!i.removed.some(o=>o.id===e.id));const l=i.added.map(({id:e})=>({id:e}));return l.forEach(({id:e})=>{r.push({id:e})}),{itemResources:r,added:l.filter(({id:e})=>!a.includes(e))}}async function W(r,t,a,i){const l=t.map(({id:e})=>new z({url:a,layerId:e,sourceJSON:i.find(({id:o})=>o===e)}));await Promise.allSettled(l.map(e=>e.load())),l.forEach(e=>{const{layerId:o,loaded:s,defaultPopupTemplate:n}=e;!s||n==null||R(e,{id:o,popupInfo:n.toJSON()},r)})}function R(r,t,a){r.isTable?A(a.tables,t):A(a.layers,t)}function A(r,t){const a=r.findIndex(({id:i})=>i===t.id);a===-1?r.push(t):r[a]=t}function D(r,t){if(!r.length)throw new u(`${t}:missing-parameters`,"'layers' array should contain at least one feature layer")}function X(r,t){const a=r.map(i=>i.portalItem.id);if(new Set(a).size>1)throw new u(`${t}:invalid-parameters`,"All layers in the 'layers' array should be loaded from the same portal item")}function U(r,t){const a=r.map(i=>i.layerId);if(new Set(a).size!==a.length)throw new u(`${t}:invalid-parameters`,"'layers' array should contain only one instance each of layer or table in a feature service")}async function rr(r){D(r,c),await Promise.all(r.map(t=>t.load()));for(const t of r)N(t,c,w),q({layer:t,itemType:d,errorNamePrefix:c});X(r,c),U(r,c)}async function tr(r,t){const{url:a,layerId:i,title:l,fullExtent:e,isTable:o}=r,s=y(a);t.url=(s==null?void 0:s.serverType)==="FeatureServer"?a:`${a}/${i}`,t.title||(t.title=l),t.extent=null,o||e==null||(t.extent=await L(e)),b(t,m.METADATA),b(t,m.MULTI_LAYER),S(t,m.SINGLE_LAYER),o&&S(t,m.TABLE)}function er(r,t){for(const e of r){const o=e.parsedUrl.path,s=y(o);if(!(s==null?void 0:s.url.path))throw new u(`${t}:invalid-parameters`,I(e,`has unsupported url pattern: ${o}`),{layer:e});const p=s==null?void 0:s.serverType;if(p!=="FeatureServer"&&p!=="MapServer")throw new u(`${t}:invalid-parameters`,I(e,`has unsupported server type: ${p}`),{layer:e});if(p==="MapServer"&&r.length>1)throw new u(`${t}:invalid-parameters`,"Only one layer or table in a map service can be saved")}const a=y(r[0].parsedUrl.path),i=a==null?void 0:a.url.path;if(!r.every(e=>{const o=y(e.parsedUrl.path);return(o==null?void 0:o.url.path)===i}))throw new u(`${t}:invalid-parameters`,"'layers' array should only contain layers or tables that belong to the same feature service")}async function ar(r){D(r,f),await Promise.all(r.map(t=>t.load()));for(const t of r)N(t,f,w);er(r,f),U(r,f)}async function or(r,t){let a=0,i=0;for(const{isTable:o}of t)o?i++:a++;const l=t[0].parsedUrl.path,e=y(l);if(r.url=(e==null?void 0:e.serverType)==="FeatureServer"?e.url.path:l,r.title||(r.title=e.title),r.extent=null,a>0){const o=t.map(s=>s.fullExtent).filter(_).reduce((s,n)=>s.clone().union(n));o&&(r.extent=await L(o))}b(r,m.METADATA),v(r,m.MULTI_LAYER,t.length>1),v(r,m.SINGLE_LAYER,t.length===1),v(r,m.TABLE,i>0&&a===0),E(r)}async function Ot(r,t){return B({layer:r,itemType:d,validateLayer:w,createItemData:(a,i)=>J(i,[a]),errorNamePrefix:C},t)}async function Jt(r,t){await rr(r);const a=r[0].portalItem,i=x(a),l=await Promise.all(r.map(o=>$(o,i,t))),e=await J(a,r.map((o,s)=>({layer:o,layerJSON:l[s]})));return E(a),await a.update({data:e}),await Promise.all(r.slice(1).map(o=>o.portalItem.reload())),P(i),a.clone()}async function Mt(r,t,a){return G({layer:r,itemType:d,validateLayer:w,createItemData:(i,l)=>Promise.resolve(O(i)),errorNamePrefix:H,newItem:t,setItemProperties:tr},a)}async function Rt(r,t,a){await ar(r);const i=j({itemType:d,errorNamePrefix:f,newItem:t}),l=x(i),e=await Promise.all(r.map(s=>$(s,l,a))),o=await M(r.map((s,n)=>({layer:s,layerJSON:e[n]})));await or(i,r),await k(i,o,a);for(const s of r)s.portalItem=i.clone();return P(l),i}export{Ot as save,Jt as saveAll,Rt as saveAllAs,Mt as saveAs};

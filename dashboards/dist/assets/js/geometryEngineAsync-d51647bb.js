import{b3 as l,a6 as f}from"./uuid-8543c34e.js";import{p as m}from"./workers-d869425a.js";function i(t){var r;return Array.isArray(t)?(r=t[0])==null?void 0:r.spatialReference:t==null?void 0:t.spatialReference}function p(t){return t&&(Array.isArray(t)?t.map(p):t.toJSON?t.toJSON():t)}function c(t){return Array.isArray(t)?t.map(r=>f(r)):f(t)}function d(t,r){let n;return Array.isArray(t)?n=t:(n=[],n.push(t),r!=null&&n.push(r)),n}let s;async function g(){return s||(s=m("geometryEngineWorker",{strategy:"distributed"})),s}async function e(t,r){return(await g()).invoke("executeGEOperation",{operation:t,parameters:p(r)})}async function O(t,r){return c(await e("clip",[i(t),t,r]))}async function S(t,r){return c(await e("cut",[i(t),t,r]))}function J(t,r){return e("contains",[i(t),t,r])}function N(t,r){return e("crosses",[i(t),t,r])}function E(t,r,n){return e("distance",[i(t),t,r,n])}function R(t,r){return e("equals",[i(t),t,r])}function b(t,r){return e("intersects",[i(t),t,r])}function v(t,r){return e("touches",[i(t),t,r])}function k(t,r){return e("within",[i(t),t,r])}function D(t,r){return e("disjoint",[i(t),t,r])}function L(t,r){return e("overlaps",[i(t),t,r])}function $(t,r,n){return e("relate",[i(t),t,r,n])}function j(t){return e("isSimple",[i(t),t])}async function B(t){return c(await e("simplify",[i(t),t]))}async function C(t,r=!1){return c(await e("convexHull",[i(t),t,r]))}async function G(t,r){return c(await e("difference",[i(t),t,r]))}async function H(t,r){return c(await e("symmetricDifference",[i(t),t,r]))}async function V(t,r){return c(await e("intersect",[i(t),t,r]))}async function W(t,r=null){const n=d(t,r);return c(await e("union",[i(n),n]))}async function q(t,r,n,a,u,o){return c(await e("offset",[i(t),t,r,n,a,u,o]))}async function z(t,r,n,a=!1){const u=[i(t),t,r,n,a];return c(await e("buffer",u))}async function F(t,r,n,a,u,o){const w=[i(t),t,r,n,a,u,o];return c(await e("geodesicBuffer",w))}async function I(t,r,n=!0){const a=await e("nearestCoordinate",[i(t),t,r,n]);return{...a,coordinate:l.fromJSON(a.coordinate)}}async function K(t,r){const n=await e("nearestVertex",[i(t),t,r]);return{...n,coordinate:l.fromJSON(n.coordinate)}}function A(t){var r;return"xmin"in t?t.center:"x"in t?t:(r=t.extent)==null?void 0:r.center}async function M(t,r,n){if(t==null)throw new y;const a=t.spatialReference;if((n=n??A(t))==null)throw new y;const u=t.constructor.fromJSON(await e("rotate",[a,t,r,n]));return u.spatialReference=a,u}async function P(t,r,n,a){return c(await e("generalize",[i(t),t,r,n,a]))}async function T(t,r,n){return c(await e("densify",[i(t),t,r,n]))}async function U(t,r,n,a=0){return c(await e("geodesicDensify",[i(t),t,r,n,a]))}function Z(t,r){return e("planarArea",[i(t),t,r])}function Q(t,r){return e("planarLength",[i(t),t,r])}function X(t,r,n){return e("geodesicArea",[i(t),t,r,n])}function Y(t,r,n){return e("geodesicLength",[i(t),t,r,n])}class y extends Error{constructor(){super("Illegal Argument Exception")}}export{D as A,P as B,T as C,V as D,G as E,Q as F,M as H,j as J,X as K,z as L,Y as M,B as N,L as O,F as P,$ as R,v as S,I as T,U,K as V,Z as W,W as b,E as d,R as g,b as h,C as j,H as k,N as m,J as p,q as v,S as w,k as x,O as y};

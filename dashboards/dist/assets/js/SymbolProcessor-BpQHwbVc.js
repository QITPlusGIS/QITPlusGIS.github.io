import{b as T,W as _,N as D,aB as C,a as F,c as R}from"./uuid-De2V3pkO.js";import{i as K}from"./ExpandedCIM-Dnfk4gBv.js";import{a as E,s as v}from"./diffUtils-B9GaWVUW.js";import{p as P}from"./visualVariablesUtils-CsTrhTSw.js";import{S as $}from"./color-cT1-Ge3_.js";import{x as L,a as A,o as w,E as O,n as U}from"./Matcher-CavG8wnV.js";import{p as B}from"./BaseProcessor-3S-Rpssj.js";import"./index-OAJD89tD.js";import"./BidiEngine-VcLDr8lR.js";import"./GeometryUtils-D08nBgDv.js";import"./enums-lYQiQBYo.js";import"./utils-pl3RUk3K.js";import"./GeometryUtils-CzofDDjY.js";import"./definitions-DYuD04dF.js";import"./mat2df32-Y88URbH1.js";import"./vec2-C6Y96AwR.js";import"./TileStore-DTOce_SM.js";import"./workers-Dp_XhR59.js";import"./signal-C4o35hpO.js";import"./quickselect-Dsa-MazW.js";import"./commonjsHelpers-DCkdB7M8.js";import"./QuantizationParameters-DrrRb5JH.js";import"./TileInfoView-CccucBWX.js";import"./vec2f32-DJy8k_UQ.js";import"./Rect-CUzevAry.js";import"./quantizationUtils-D3whBd2n.js";import"./floatRGBA-BJa16tCb.js";import"./OptimizedFeature-CuDeWVOV.js";import"./enums-BFYfP9qy.js";import"./VertexElementDescriptor-BLyltQyJ.js";import"./tileUtils-B7X19rIS.js";import"./TurboLine-ADRWAXBV.js";import"./defaultsJSON-CHAaurhX.js";import"./earcut-BVL67bTw.js";import"./LRUCache-DMLtX-OB.js";class z{constructor(e){this._remoteClient=e,this._resourceMap=new Map,this._inFlightResourceMap=new Map,this.geometryEngine=null,this.geometryEnginePromise=null}destroy(){}async fetchResource(e,s){const r=this._resourceMap,a=r.get(e);if(a)return a;let i=this._inFlightResourceMap.get(e);if(i)return i;try{i=this._remoteClient.invoke("tileRenderer.fetchResource",{url:e},{...s}),this._inFlightResourceMap.set(e,i),i.then((o=>(this._inFlightResourceMap.delete(e),r.set(e,o),o)))}catch(o){return T(o)?null:{width:0,height:0}}return i}getResource(e){return this._resourceMap.get(e)??null}loadFont(e){return Promise.resolve(null)}}function I(t,e){const s=e-e/2,r=e+e/4;return(!t.minScale||t.minScale>=s)&&(!t.maxScale||t.maxScale<=r)}function x(t){const e=t.message,s={message:{data:{},tileKey:e.tileKey,tileKeyOrigin:e.tileKeyOrigin,version:e.version},transferList:new Array};for(const r in e.data){const a=r,i=e.data[a];if(s.message.data[a]=null,i!=null){const o=i.stride,n=i.indices.slice(0),l=i.vertices.slice(0),d=i.records.slice(0),c=i.metrics?.slice(0),h={stride:o,indices:n,vertices:l,records:d,metrics:c};s.transferList.push(n,l,d),s.message.data[a]=h}}return s}let M=class extends B{constructor(){super(...arguments),this.type="symbol",this._matchers={feature:null,aggregate:null},this._bufferData=new Map,this._bufferIds=new Map}initialize(){this.addHandles([this.tileStore.on("update",this.onTileUpdate.bind(this))]),this._resourceManagerProxy=new z(this.remoteClient)}destroy(){this._resourceManagerProxy.destroy()}get supportsTileUpdates(){return!0}forEachBufferId(t){this._bufferIds.forEach((e=>{e.forEach(t)}))}async update(t,e){const s=e.schema.processors[0];if(s.type!=="symbol")return;const r=E(this._schema,s);(v(r,"mesh")||v(r,"target"))&&(t.mesh=!0,t.why?.mesh.push("Symbology changed"),this._schema=s,this._factory=this._createFactory(s),this._factory.update(s,this.tileStore.tileScheme.tileInfo))}onTileMessage(t,e,s,r){return _(r),this._onTileData(t,e,s,r)}onTileClear(t,e){const s={clear:!0,end:e};return this._bufferData.delete(t.key.id),this._bufferIds.delete(t.key.id),this.remoteClient.invoke("tileRenderer.onTileData",{tileKey:t.id,data:s})}onTileError(t,e,s){const r=s.signal,a={tileKey:t.id,error:e};return this.remoteClient.invoke("tileRenderer.onTileError",a,{signal:r})}onTileUpdate(t){for(const e of t.removed)this._bufferData.has(e.key.id)&&this._bufferData.delete(e.key.id),this._bufferIds.has(e.key.id)&&this._bufferIds.delete(e.key.id);for(const e of t.added)this._bufferData.forEach((s=>{for(const r of s)r.message.tileKey===e.id&&this._updateTileMesh("append",e,x(r),[],!1,!1,null)}))}_addBufferData(t,e){this._bufferData.has(t)||this._bufferData.set(t,[]),this._bufferData.get(t)?.push(x(e))}_createFactory(t){const{geometryType:e,objectIdField:s,fields:r}=this.service,a=(d,c)=>this.remoteClient.invoke("tileRenderer.getMaterialItems",d,c),i={geometryType:e,fields:r,spatialReference:D.fromJSON(this.spatialReference)},o=new L(a,this.tileStore.tileScheme.tileInfo),{matcher:n,aggregateMatcher:l}=t.mesh;return this._store=o,this._matchers.feature=w(n,o,i,this._resourceManagerProxy),this._matchers.aggregate=l?w(l,o,i,this._resourceManagerProxy):null,new A(e,s,o)}async _onTileData(t,e,s,r){_(r);const{type:a,addOrUpdate:i,remove:o,clear:n,end:l}=e,d=!!this._schema.mesh.sortKey;if(!i){const h={type:a,addOrUpdate:null,remove:o,clear:n,end:l,sort:d};return this.remoteClient.invoke("tileRenderer.onTileData",{tileKey:t.id,data:h},r)}const c=this._processFeatures(t,i,s,r,e.status?.version);try{const h=await c;if(h==null){const u={type:a,addOrUpdate:null,remove:o,clear:n,end:l,sort:d};return this.remoteClient.invoke("tileRenderer.onTileData",{tileKey:t.id,data:u},r)}const f=[];for(const u of h){let m=!1;const g=u.message.bufferIds,p=t.key.id,b=u.message.tileKey;if(p!==b&&g!=null){if(!this.tileStore.get(b)){this._addBufferData(p,u),f.push(u);continue}let y=this._bufferIds.get(b);y||(y=new Set,this._bufferIds.set(b,y));const k=Array.from(g);for(const S of k){if(y.has(S)){m=!0;break}y.add(S)}}m||(this._addBufferData(p,u),f.push(u))}await Promise.all(f.map((u=>{const m=t.key.id===u.message.tileKey,g=m?e.remove:[],p=m&&e.end;return this._updateTileMesh(a,t,u,g,p,!!e.clear,r.signal)})))}catch(h){this._handleError(t,h,r)}}async _updateTileMesh(t,e,s,r,a,i,o){const n=t,l=s.message.tileKey,d=!!this._schema.mesh.sortKey;l!==e.key.id&&(a=!1);const c=s?.message,h={type:n,addOrUpdate:c,remove:r,clear:i,end:a,sort:d},f={transferList:s?.transferList??[],signal:o};return _(f),this.remoteClient.invoke("tileRenderer.onTileData",{tileKey:l,data:h},f)}async _processFeatures(t,e,s,r,a){if(e==null||!e.hasFeatures)return null;const i={transform:t.transform,hasZ:!1,hasM:!1},o=this._factory,n={viewingMode:"",scale:t.scale},l=await this._matchers.feature,d=await this._matchers.aggregate;_(r);const c=this._getLabelInfos(t,e);return await o.analyze(e.getCursor(),this._resourceManagerProxy,l,d,i,n),_(r),this._writeFeatureSet(t,e,i,c,o,s,a)}_writeFeatureSet(t,e,s,r,a,i,o){const n=e.getSize(),l=this._schema.mesh.matcher.symbologyType,d=new O(t.key.id,{features:n,records:n,metrics:0},l,i,l!==$.HEATMAP,o),c={viewingMode:"",scale:t.scale},h=e.getCursor();for(;h.next();)try{const u=h.getDisplayId(),m=r!=null?r.get(u):null;a.writeCursor(d,h,s,c,t.level,m,this._resourceManagerProxy)}catch{}const f=t.tileInfoView.tileInfo.isWrappable;return d.serialize(f)}_handleError(t,e,s){if(!T(e)){const r={tileKey:t.id,error:e.message};return this.remoteClient.invoke("tileRenderer.onTileError",r,{signal:s.signal})}return Promise.resolve()}_getLabelingSchemaForScale(t){const e=this._schema.mesh.labels;if(e==null)return null;if(e.type==="subtype"){const r={type:"subtype",classes:{}};let a=!1;for(const i in e.classes){const o=e.classes[i].filter((n=>I(n,t.scale)));a=a||!!o.length,r.classes[i]=o}return a?r:null}const s=e.classes.filter((r=>I(r,t.scale)));return s.length?{type:"simple",classes:s}:null}_getLabels(t,e){if(e.type==="subtype"){const s=this.service.subtypeField;C(s,"Expected to find subtype Field");const r=t.readAttribute(s);return r==null?[]:e.classes[r]??[]}return e.classes}_getLabelInfos(t,e){const s=this._getLabelingSchemaForScale(t);if(s==null)return null;const r=new Map,a=e.getCursor();for(;a.next();){const i=a.getDisplayId(),o=[],n=P(i),l=n&&a.readAttribute("cluster_count")!==1?"aggregate":"feature",d=this._getLabels(a,s);for(const c of d){if(c.target!==l)continue;const h=a.getStorage(),f=n&&l==="feature"?h.getComputedStringAtIndex(a.readAttribute("referenceId"),c.fieldIndex):h.getComputedStringAtIndex(i,c.fieldIndex);if(!f)continue;const u=K(f.toString()),m=u[0],g=u[1];this._store.getMosaicItem(c.symbol,U(m)).then((p=>{o[c.index]={glyphs:p.glyphMosaicItems??[],rtl:g,index:c.index}}))}r.set(i,o)}return r}};M=F([R("esri.views.2d.layers.features.processors.SymbolProcessor")],M);const we=M;export{we as default};

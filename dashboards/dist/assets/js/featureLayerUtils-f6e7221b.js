import{cp as Y,h as _,o as u}from"./uuid-896b9aab.js";import{i as P}from"./originUtils-cfe4feaf.js";import{Z as z}from"./FeatureLayer-7e634011.js";import{I as B,y as $,w as E,b as G,u as j,v as k,l as N,d as V,m as I}from"./utils-2a92a81d.js";import{p as y}from"./arcgisLayerUrl-babbe1bf.js";import{r as Z}from"./fetchService-32179de4.js";import{h as q}from"./layerUtils-71133796.js";import{o as x}from"./jsonContext-e6effc50.js";import{l as L,a as b,u as v,f as m,i as S}from"./portalItemUtils-50147700.js";import"./index-36e9aec6.js";import"./multiOriginJSONSupportUtils-c978f4c3.js";import"./UniqueValueRenderer-5d584a21.js";import"./LegendOptions-cec1028c.js";import"./diffUtils-a3a9db51.js";import"./SizeVariable-b5ce232d.js";import"./colorRamps-25747e5c.js";import"./compilerUtils-b3a0c560.js";import"./lengthUtils-4ab57232.js";import"./ColorStop-3d508119.js";import"./jsonUtils-3767cca3.js";import"./styleUtils-885e3cac.js";import"./jsonUtils-ac311f38.js";import"./DictionaryLoader-3b50e321.js";import"./LRUCache-6cfe7ff6.js";import"./FieldsIndex-b9e92cab.js";import"./heatmapUtils-27bad519.js";import"./vec4f64-3c9d0901.js";import"./MultiOriginJSONSupport-3a78e066.js";import"./commonProperties-6f21cf48.js";import"./ElevationInfo-8d60fc5a.js";import"./FeatureLayerBase-a76fe8f1.js";import"./Field-44a4dae2.js";import"./fieldType-39083810.js";import"./featureLayerUtils-b6f26a17.js";import"./Query-2995d860.js";import"./FullTextSearch-bf557d06.js";import"./QuantizationParameters-8e0f5300.js";import"./AttachmentQuery-98e24455.js";import"./RelationshipQuery-b003b1c1.js";import"./LayerFloorInfo-fc9dcbd1.js";import"./serviceCapabilitiesUtils-40e4709f.js";import"./workers-d41a4c7e.js";import"./queryZScale-00692237.js";import"./FeatureSet-536478a2.js";import"./APIKeyMixin-60d9f7d0.js";import"./ArcGISService-ca2440e3.js";import"./BlendLayer-d89d05a2.js";import"./jsonUtils-84d8e543.js";import"./parser-14d23883.js";import"./mat4f32-60a2394b.js";import"./mat4-318655b6.js";import"./CustomParametersMixin-4711adcc.js";import"./EditBusLayer-e27f20bb.js";import"./FeatureEffectLayer-c77101f3.js";import"./FeatureEffect-c92b9a39.js";import"./FeatureReductionLayer-4c8784ac.js";import"./clusterUtils-d4a9bc58.js";import"./MD5-715f37cd.js";import"./FeatureReductionSelection-3f8562f5.js";import"./LabelClass-961ff56d.js";import"./labelUtils-21b484ec.js";import"./defaultsJSON-b087dd4d.js";import"./OperationalLayer-db945a99.js";import"./OrderedLayer-0783efcd.js";import"./PortalLayer-d46cf7fb.js";import"./PortalItem-6f01e175.js";import"./RefreshableLayer-216f1bc8.js";import"./ScaleRangeLayer-c70a8fe7.js";import"./TemporalLayer-1b7f1cb8.js";import"./FeatureTemplate-5d7372f9.js";import"./FeatureType-a5e62fd2.js";import"./fieldProperties-7813280d.js";import"./labelingInfo-926370a5.js";import"./versionUtils-5fe55710.js";import"./styleUtils-56d63244.js";import"./TopFeaturesQuery-68defe80.js";import"./popupUtils-ca8ca81d.js";import"./interfaces-f1f22245.js";import"./saveAPIKeyUtils-30be8fd8.js";import"./requestPresets-cb9586bc.js";const d="Feature Service",h="feature-layer-utils",C=`${h}-save`,H=`${h}-save-as`,c=`${h}-saveall`,f=`${h}-saveall-as`;function w(r){return{isValid:q(r)&&(r.type!=="feature"||!r.dynamicDataSource),errorMessage:"Feature layer should be a layer or table in a map or feature service"}}function g(r){const t=[],a=[];for(const{layer:i,layerJSON:l}of r)i.isTable?a.push(l):t.push(l);return{layers:t,tables:a}}function O(r){return g([r])}async function J(r,t){return/\/\d+\/?$/.test(r.url)?O(t[0]):M(t,r)}async function M(r,t){if(!t)return r.reverse(),g(r);const{layer:{url:a,customParameters:i,apiKey:l}}=r[0];let e=await t.fetchData("json");(e==null?void 0:e.layers)!=null&&(e==null?void 0:e.tables)!=null||(e=await Q(e,{url:a??"",customParameters:i,apiKey:l},r.map(o=>o.layer.layerId)));for(const o of r)R(o.layer,o.layerJSON,e);return e}async function Q(r,t,a){r||(r={}),r.layers||(r.layers=[]),r.tables||(r.tables=[]);const{url:i,customParameters:l,apiKey:e}=t,{serviceJSON:o,layersJSON:s}=await Z(i,{customParameters:l,apiKey:e}),n=T(r.layers,o.layers,a),p=T(r.tables,o.tables,a);r.layers=n.itemResources,r.tables=p.itemResources;const F=[...n.added,...p.added],K=s?[...s.layers,...s.tables]:[];return await W(r,F,i,K),r}function T(r,t,a){const i=Y(r,t,(e,o)=>e.id===o.id);r=r.filter(e=>!i.removed.some(o=>o.id===e.id));const l=i.added.map(({id:e})=>({id:e}));return l.forEach(({id:e})=>{r.push({id:e})}),{itemResources:r,added:l.filter(({id:e})=>!a.includes(e))}}async function W(r,t,a,i){const l=t.map(({id:e})=>new z({url:a,layerId:e,sourceJSON:i.find(({id:o})=>o===e)}));await Promise.allSettled(l.map(e=>e.load())),l.forEach(e=>{const{layerId:o,loaded:s,defaultPopupTemplate:n}=e;!s||n==null||R(e,{id:o,popupInfo:n.toJSON()},r)})}function R(r,t,a){r.isTable?A(a.tables,t):A(a.layers,t)}function A(r,t){const a=r.findIndex(({id:i})=>i===t.id);a===-1?r.push(t):r[a]=t}function D(r,t){if(!r.length)throw new u(`${t}:missing-parameters`,"'layers' array should contain at least one feature layer")}function X(r,t){const a=r.map(i=>i.portalItem.id);if(new Set(a).size>1)throw new u(`${t}:invalid-parameters`,"All layers in the 'layers' array should be loaded from the same portal item")}function U(r,t){const a=r.map(i=>i.layerId);if(new Set(a).size!==a.length)throw new u(`${t}:invalid-parameters`,"'layers' array should contain only one instance each of layer or table in a feature service")}async function rr(r){D(r,c),await Promise.all(r.map(t=>t.load()));for(const t of r)N(t,c,w),V({layer:t,itemType:d,errorNamePrefix:c});X(r,c),U(r,c)}async function tr(r,t){const{url:a,layerId:i,title:l,fullExtent:e,isTable:o}=r,s=y(a);t.url=(s==null?void 0:s.serverType)==="FeatureServer"?a:`${a}/${i}`,t.title||(t.title=l),t.extent=null,o||e==null||(t.extent=await L(e)),b(t,m.METADATA),b(t,m.MULTI_LAYER),S(t,m.SINGLE_LAYER),o&&S(t,m.TABLE)}function er(r,t){for(const e of r){const o=e.parsedUrl.path,s=y(o);if(!(s==null?void 0:s.url.path))throw new u(`${t}:invalid-parameters`,I(e,`has unsupported url pattern: ${o}`),{layer:e});const p=s==null?void 0:s.serverType;if(p!=="FeatureServer"&&p!=="MapServer")throw new u(`${t}:invalid-parameters`,I(e,`has unsupported server type: ${p}`),{layer:e});if(p==="MapServer"&&r.length>1)throw new u(`${t}:invalid-parameters`,"Only one layer or table in a map service can be saved")}const a=y(r[0].parsedUrl.path),i=a==null?void 0:a.url.path;if(!r.every(e=>{const o=y(e.parsedUrl.path);return(o==null?void 0:o.url.path)===i}))throw new u(`${t}:invalid-parameters`,"'layers' array should only contain layers or tables that belong to the same feature service")}async function ar(r){D(r,f),await Promise.all(r.map(t=>t.load()));for(const t of r)N(t,f,w);er(r,f),U(r,f)}async function or(r,t){let a=0,i=0;for(const{isTable:o}of t)o?i++:a++;const l=t[0].parsedUrl.path,e=y(l);if(r.url=(e==null?void 0:e.serverType)==="FeatureServer"?e.url.path:l,r.title||(r.title=e.title),r.extent=null,a>0){const o=t.map(s=>s.fullExtent).filter(_).reduce((s,n)=>s.clone().union(n));o&&(r.extent=await L(o))}b(r,m.METADATA),v(r,m.MULTI_LAYER,t.length>1),v(r,m.SINGLE_LAYER,t.length===1),v(r,m.TABLE,i>0&&a===0),E(r)}async function Ot(r,t){return B({layer:r,itemType:d,validateLayer:w,createItemData:(a,i)=>J(i,[a]),errorNamePrefix:C},t)}async function Jt(r,t){await rr(r);const a=r[0].portalItem,i=x(a),l=await Promise.all(r.map(o=>$(o,i,t))),e=await J(a,r.map((o,s)=>({layer:o,layerJSON:l[s]})));return E(a),await a.update({data:e}),await Promise.all(r.slice(1).map(o=>o.portalItem.reload())),P(i),a.clone()}async function Mt(r,t,a){return G({layer:r,itemType:d,validateLayer:w,createItemData:(i,l)=>Promise.resolve(O(i)),errorNamePrefix:H,newItem:t,setItemProperties:tr},a)}async function Rt(r,t,a){await ar(r);const i=j({itemType:d,errorNamePrefix:f,newItem:t}),l=x(i),e=await Promise.all(r.map(s=>$(s,l,a))),o=await M(r.map((s,n)=>({layer:s,layerJSON:e[n]})));await or(i,r),await k(i,o,a);for(const s of r)s.portalItem=i.clone();return P(l),i}export{Ot as save,Jt as saveAll,Rt as saveAllAs,Mt as saveAs};

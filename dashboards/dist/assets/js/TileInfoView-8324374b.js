import{aH as I,aT as R}from"./uuid-8543c34e.js";let x=class B{static getId(t,o,l,e){return typeof t=="object"?`${t.level}/${t.row}/${t.col}/${t.world}`:`${t}/${o}/${l}/${e}`}constructor(t,o,l,e){this.set(t,o,l,e)}get key(){return this}get id(){return this.toString()}set id(t){this.set(t)}get hash(){const t=4095&this.row,o=4095&this.col,l=63&this.level;return(3&this.world)<<30|o<<22|t<<8|l}acquire(t,o,l,e){this.set(t,o,l,e)}contains(t){const o=t.level-this.level;return o>=0&&this.row===t.row>>o&&this.col===t.col>>o&&this.world===t.world}equals(t){return this.level===t.level&&this.row===t.row&&this.col===t.col&&this.world===t.world}clone(){return new B(this)}release(){this.level=0,this.row=0,this.col=0,this.world=0}set(t,o,l,e){if(t==null)this.level=0,this.row=0,this.col=0,this.world=0;else if(typeof t=="object")this.level=t.level||0,this.row=t.row||0,this.col=t.col||0,this.world=t.world||0;else if(typeof t=="string"){const[s,n,i,r]=t.split("/");this.level=parseFloat(s),this.row=parseFloat(n),this.col=parseFloat(i),this.world=parseFloat(r)}else this.level=+t,this.row=+o,this.col=+l,this.world=+e||0;return this}toString(){return`${this.level}/${this.row}/${this.col}/${this.world}`}getParentKey(){return this.level<=0?null:new B(this.level-1,this.row>>1,this.col>>1,this.world)}getChildKeys(){const t=this.level+1,o=this.row<<1,l=this.col<<1,e=this.world;return[new B(t,o,l,e),new B(t,o,l+1,e),new B(t,o+1,l,e),new B(t,o+1,l+1,e)]}compareRowMajor(t){return this.row<t.row?-1:this.row>t.row?1:this.col<t.col?-1:this.col>t.col?1:0}};x.pool=new I(x,null,null,25,50);function S(g,t){return[g,t]}function C(g,t,o){return g[0]=t,g[1]=o,g}function $(g,t,o,l,e){return g[0]=t,g[1]=o,g[2]=l,g[3]=e,g}const F=new x("0/0/0/0");let X=class L{static create(t,o,l=null){const e=R(t.spatialReference),s=o.origin||S(t.origin.x,t.origin.y),n=S(t.size[0]*o.resolution,t.size[1]*o.resolution),i=S(-1/0,-1/0),r=S(1/0,1/0),h=S(1/0,1/0);l!=null&&(C(i,Math.max(0,Math.floor((l.xmin-s[0])/n[0])),Math.max(0,Math.floor((s[1]-l.ymax)/n[1]))),C(r,Math.max(0,Math.floor((l.xmax-s[0])/n[0])),Math.max(0,Math.floor((s[1]-l.ymin)/n[1]))),C(h,r[0]-i[0]+1,r[1]-i[1]+1));const{cols:a,rows:f}=o;let m,M,p,w;return!l&&a&&f&&(C(i,a[0],f[0]),C(r,a[1],f[1]),C(h,a[1]-a[0]+1,f[1]-f[0]+1)),t.isWrappable?(m=S(Math.ceil(Math.round((e.valid[1]-e.valid[0])/o.resolution)/t.size[0]),h[1]),M=S(Math.floor((e.origin[0]-s[0])/n[0]),i[1]),p=S(m[0]+M[0]-1,r[1]),w=!0):(M=i,p=r,m=h,w=!1),new L(o.level,o.resolution,o.scale,s,i,r,h,n,M,p,m,w)}constructor(t,o,l,e,s,n,i,r,h,a,f,m){this.level=t,this.resolution=o,this.scale=l,this.origin=e,this.first=s,this.last=n,this.size=i,this.norm=r,this.worldStart=h,this.worldEnd=a,this.worldSize=f,this.wrap=m}normalizeCol(t){if(!this.wrap)return t;const o=this.worldSize[0];return t<0?o-1-Math.abs((t+1)%o):t%o}denormalizeCol(t,o){return this.wrap?this.worldSize[0]*o+t:t}getWorldForColumn(t){return this.wrap?Math.floor(t/this.worldSize[0]):0}getFirstColumnForWorld(t){return t*this.worldSize[0]+this.first[0]}getLastColumnForWorld(t){return t*this.worldSize[0]+this.first[0]+this.size[0]-1}getColumnForX(t){return(t-this.origin[0])/this.norm[0]}getXForColumn(t){return this.origin[0]+t*this.norm[0]}getRowForY(t){return(this.origin[1]-t)/this.norm[1]}getYForRow(t){return this.origin[1]-t*this.norm[1]}getTileBounds(t,o,l=!1){F.set(o);const e=l?F.col:this.denormalizeCol(F.col,F.world),s=F.row;return $(t,this.getXForColumn(e),this.getYForRow(s+1),this.getXForColumn(e+1),this.getYForRow(s)),t}getTileCoords(t,o,l=!1){F.set(o);const e=l?F.col:this.denormalizeCol(F.col,F.world);return Array.isArray(t)?C(t,this.getXForColumn(e),this.getYForRow(F.row)):(t.x=this.getXForColumn(e),t.y=this.getYForRow(F.row)),t}},_=class{constructor(){this.spans=[]}acquire(t){this.lodInfo=t}release(){this.lodInfo=null,this.spans.length=0}forEach(t,o){const{spans:l,lodInfo:e}=this,{level:s}=e;if(l.length!==0)for(const{row:n,colFrom:i,colTo:r}of l)for(let h=i;h<=r;h++)t.call(o,s,n,e.normalizeCol(h),e.getWorldForColumn(h))}};_.pool=new I(_);class z{constructor(t,o,l){this.row=t,this.colFrom=o,this.colTo=l}}const c=new x("0/0/0/0");class T{static create(t,o){t[1]>o[1]&&([t,o]=[o,t]);const[l,e]=t,[s,n]=o,i=s-l,r=n-e,h=r!==0?i/r:0,a=(Math.ceil(e)-e)*h,f=(Math.floor(e)-e)*h;return new T(l,Math.floor(e),Math.ceil(n),h,i<0?a:f,i<0?f:a,i<0?s:l,i<0?l:s)}constructor(t,o,l,e,s,n,i,r){this.x=t,this.ymin=o,this.ymax=l,this.invM=e,this.leftAdjust=s,this.rightAdjust=n,this.leftBound=i,this.rightBound=r}incrRow(){this.x+=this.invM}getLeftCol(){return Math.max(this.x+this.leftAdjust,this.leftBound)}getRightCol(){return Math.min(this.x+this.rightAdjust,this.rightBound)}}const v=[[0,0],[0,0],[0,0],[0,0]],Y=1e-6;class j{constructor(t,o=null,l=t.lods[0].level,e=t.lods[t.lods.length-1].level){this.tileInfo=t,this.fullExtent=o,this.scales=[],this._infoByScale={},this._infoByLevel={};const s=t.lods.filter(i=>i.level>=l&&i.level<=e);this.minScale=s[0].scale,this.maxScale=s[s.length-1].scale;const n=this._lodInfos=s.map(i=>X.create(t,i,o));s.forEach((i,r)=>{this._infoByLevel[i.level]=n[r],this._infoByScale[i.scale]=n[r],this.scales[r]=i.scale},this),this._wrap=t.isWrappable}get spatialReference(){return this.tileInfo.spatialReference}getLODInfoAt(t){return this._infoByLevel[typeof t=="number"?t:t.level]}getTileBounds(t,o,l=!1){c.set(o);const e=this._infoByLevel[c.level];return e?e.getTileBounds(t,c,l):t}getTileCoords(t,o,l=!1){c.set(o);const e=this._infoByLevel[c.level];return e?e.getTileCoords(t,c,l):t}getTileCoverage(t,o=192,l=!0,e="closest"){if(!l&&(t.scale>this.minScale||t.scale<this.maxScale))return null;const s=e==="closest"?this.getClosestInfoForScale(t.scale):this.getSmallestInfoForScale(t.scale),n=_.pool.acquire(s),i=this._wrap;let r,h,a,f=1/0,m=-1/0;const M=n.spans;v[0][0]=v[0][1]=v[1][1]=v[3][0]=-o,v[1][0]=v[2][0]=t.size[0]+o,v[2][1]=v[3][1]=t.size[1]+o;for(const u of v)t.toMap(u,u),u[0]=s.getColumnForX(u[0]),u[1]=s.getRowForY(u[1]);const p=[];let w=3;for(let u=0;u<4;u++){if(v[u][1]===v[w][1]){w=u;continue}const d=T.create(v[u],v[w]);f=Math.min(d.ymin,f),m=Math.max(d.ymax,m),p[d.ymin]===void 0&&(p[d.ymin]=[]),p[d.ymin].push(d),w=u}if(f==null||m==null||m-f>100)return null;let y=[];for(r=f;r<m;){p[r]!=null&&(y=y.concat(p[r])),h=1/0,a=-1/0;for(let u=y.length-1;u>=0;u--){const d=y[u];h=Math.min(h,d.getLeftCol()),a=Math.max(a,d.getRightCol())}if(h=Math.floor(h),a=Math.floor(a),r>=s.first[1]&&r<=s.last[1])if(i)if(s.size[0]<s.worldSize[0]){const u=Math.floor(a/s.worldSize[0]);for(let d=Math.floor(h/s.worldSize[0]);d<=u;d++)M.push(new z(r,Math.max(s.getFirstColumnForWorld(d),h),Math.min(s.getLastColumnForWorld(d),a)))}else M.push(new z(r,h,a));else h>s.last[0]||a<s.first[0]||(h=Math.max(h,s.first[0]),a=Math.min(a,s.last[0]),M.push(new z(r,h,a)));r+=1;for(let u=y.length-1;u>=0;u--){const d=y[u];d.ymax>=r?d.incrRow():y.splice(u,1)}}return n}getTileParentId(t){c.set(t);const o=this._infoByLevel[c.level],l=this._lodInfos.indexOf(o)-1;return l<0?null:(this._getTileIdAtLOD(c,this._lodInfos[l],c),c.id)}getTileResolution(t){const o=this._infoByLevel[typeof t=="object"?t.level:t];return o?o.resolution:-1}getTileScale(t){const o=this._infoByLevel[t.level];return o?o.scale:-1}intersects(t,o){c.set(o);const l=this._infoByLevel[c.level],e=t.lodInfo;if(e.resolution>l.resolution){this._getTileIdAtLOD(c,e,c);const n=e.denormalizeCol(c.col,c.world);for(const i of t.spans)if(i.row===c.row&&i.colFrom<=n&&i.colTo>=n)return!0}if(e.resolution<l.resolution){const[n,i,r,h]=t.spans.reduce((w,y)=>(w[0]=Math.min(w[0],y.row),w[1]=Math.max(w[1],y.row),w[2]=Math.min(w[2],y.colFrom),w[3]=Math.max(w[3],y.colTo),w),[1/0,-1/0,1/0,-1/0]),a=l.denormalizeCol(c.col,c.world),f=e.getColumnForX(l.getXForColumn(a)),m=e.getRowForY(l.getYForRow(c.row)),M=e.getColumnForX(l.getXForColumn(a+1))-1,p=e.getRowForY(l.getYForRow(c.row+1))-1;return!(f>h||M<r||m>i||p<n)}const s=e.denormalizeCol(c.col,c.world);return t.spans.some(n=>n.row===c.row&&n.colFrom<=s&&n.colTo>=s)}normalizeBounds(t,o,l){if(t[0]=o[0],t[1]=o[1],t[2]=o[2],t[3]=o[3],this._wrap){const e=R(this.tileInfo.spatialReference),s=-l*(e.valid[1]-e.valid[0]);t[0]+=s,t[2]+=s}return t}getSmallestInfoForScale(t){const o=this.scales;if(this._infoByScale[t])return this._infoByScale[t];if(t>o[0])return this._infoByScale[o[0]];for(let l=1;l<o.length-1;l++)if(t>o[l]+Y)return this._infoByScale[o[l-1]];return this._infoByScale[o[o.length-1]]}getClosestInfoForScale(t){const o=this.scales;return this._infoByScale[t]||(t=o.reduce((l,e)=>Math.abs(e-t)<Math.abs(l-t)?e:l,o[0])),this._infoByScale[t]}scaleToLevel(t){const o=this.scales;if(this._infoByScale[t])return this._infoByScale[t].level;for(let l=o.length-1;l>=0;l--)if(t<o[l])return l===o.length-1?this._infoByScale[o[o.length-1]].level:this._infoByScale[o[l]].level+(o[l]-t)/(o[l]-o[l+1]);return this._infoByScale[o[0]].level}scaleToZoom(t){return this.tileInfo.scaleToZoom(t)}_getTileIdAtLOD(t,o,l){const e=this._infoByLevel[l.level];return t.set(l),o.resolution<e.resolution?null:(o.resolution===e.resolution||(t.level=o.level,t.col=Math.floor(l.col*e.resolution/o.resolution+.01),t.row=Math.floor(l.row*e.resolution/o.resolution+.01)),t)}}export{x as e,j as h,_ as l};

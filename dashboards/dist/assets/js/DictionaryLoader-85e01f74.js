import{o as v,b as j,ds as I,aJ as x,s as S,A as M,dt as L,du as $,dv as R}from"./uuid-854440a9.js";import{e as T}from"./LRUCache-f623b6a8.js";import{c as N}from"./FieldsIndex-babfd5a5.js";let w=class{constructor(r,t,e=""){this.major=r,this.minor=t,this._context=e}lessThan(r,t){return this.major<r||r===this.major&&this.minor<t}since(r,t){return!this.lessThan(r,t)}validate(r){if(this.major!==r.major){const t=this._context&&this._context+":",e=this._context&&this._context+" ";throw new v(t+"unsupported-version",`Required major ${e}version is '${this.major}', but got '\${version.major}.\${version.minor}'`,{version:r})}}clone(){return new w(this.major,this.minor,this._context)}static parse(r,t=""){const[e,i]=r.split("."),s=/^\s*\d+\s*$/;if(!(e!=null&&e.match)||!s.test(e))throw new v((t&&t+":")+"invalid-version","Expected major version to be a number, but got '${version}'",{version:r});if(!(i!=null&&i.match)||!s.test(i))throw new v((t&&t+":")+"invalid-version","Expected minor version to be a number, but got '${version}'",{version:r});const l=parseInt(e,10),c=parseInt(i,10);return new w(l,c,t)}};const P="esri.renderers.support.DictionaryLoader",F={type:"CIMSimpleLineCallout",lineSymbol:{type:"CIMLineSymbol",symbolLayers:[{type:"CIMSolidStroke",width:.5,color:[0,0,0,255]}]}};class q{constructor(t,e,i){this.config=null,this.fieldMap=null,this.url=null,this._ongoingRequests=new Map,this._symbolCache=new T(100),this._dictionaryVersion=null,this._fieldIndex=null,this._dictionaryPromise=null,this.url=t,this.config=e,this.fieldMap=i}getSymbolFields(){return this._symbolFields}async getSymbolAsync(t,e){let i;this._dictionaryPromise||(this._dictionaryPromise=this.fetchResources(e));try{i=await this._dictionaryPromise}catch(o){if(j(o))return this._dictionaryPromise=null,null}const s=this._dictionaryVersion&&this._dictionaryVersion.since(4,0),l={};if(this.fieldMap)for(const o of this._symbolFields){const a=this._getFieldName(this.fieldMap[o]);if(a){const u=t.attributes[a];l[o]=s?u:u!=null?""+t.attributes[a]:""}else l[o]=""}let c=null;try{c=i==null?void 0:i(l,e)}catch{return null}if(!c||typeof c!="string")return null;const m=I(c).toString(),h=this._symbolCache.get(m);if(h)return h.catch(()=>{this._symbolCache.pop(m)}),h;const b=c.split(";"),f=[],y=[];for(const o of b)if(o)if(o.includes("po:")){const a=o.substr(3).split("|");if(a.length===3){const u=a[0],g=a[1];let d=a[2];if(g==="DashTemplate")d=d.split(" ").map(p=>Number(p));else if(g==="Color"){const p=new x(d).toRgba();d=[p[0],p[1],p[2],255*p[3]]}else d=Number(d);y.push({primitiveName:u,propertyName:g,value:d})}}else if(o.includes("|")){for(const a of o.split("|"))if(this._itemNames.has(a)){f.push(a);break}}else this._itemNames.has(o)&&f.push(o);const _=t.geometry==null||!t.geometry.hasZ&&t.geometry.type==="point",n=this._cimPartsToCIMSymbol(f,y,_,e);return this._symbolCache.put(m,n,1),n}async fetchResources(t){if(this._dictionaryPromise)return this._dictionaryPromise;if(!this.url)return void S.getLogger(P).error("no valid URL!");const e=M(this.url+"/resources/styles/dictionary-info.json",{responseType:"json",query:{f:"json"},signal:t!=null?t.signal:null}),[{data:i}]=await Promise.all([e,L()]);if(!i)throw this._dictionaryPromise=null,new v("esri.renderers.DictionaryRenderer","Bad dictionary data!");const{authoringInfo:s,dictionary_version:l,expression:c,itemsNames:m}=i,h=c;let b=!1;l&&(this._dictionaryVersion=w.parse(l),b=this._dictionaryVersion.since(4,0)),this._refSymbolUrlTemplate=this.url+"/"+i.cimRefTemplateUrl,this._itemNames=new Set(m),this._symbolFields=s.symbol;const f={};if(this.config){const n=this.config;for(const o in n)f[o]=n[o]}if(s.configuration)for(const n of s.configuration)f.hasOwnProperty(n.name)||(f[n.name]=n.value);const y=[];if(t!=null&&t.fields&&this.fieldMap)for(const n of this._symbolFields){const o=this.fieldMap[n],a=t.fields.filter(u=>u.name.toLowerCase()===(o==null?void 0:o.toLowerCase()));a.length>0&&y.push({...a[0],type:b?a[0].type:"esriFieldTypeString"})}y.length>0&&(this._fieldIndex=new N(y));const _=$(h,t!=null?t.spatialReference:null,y,f).then(n=>{const o={scale:0};return(a,u)=>{if(n==null)return null;const g=n.repurposeFeature({geometry:null,attributes:a});return o.scale=u!=null?u.scale??void 0:void 0,n.evaluate({$feature:g,$view:o},n.services)}}).catch(n=>(S.getLogger(P).error("Creating dictinoary expression failed:",n),null));return this._dictionaryPromise=_,_}async _cimPartsToCIMSymbol(t,e,i,s){const l=new Array(t.length);for(let h=0;h<t.length;h++)l[h]=this._getSymbolPart(t[h],s);const c=await Promise.all(l),m=this.fieldMap;if(m)for(const h of c)C(h,m);return new R({data:this._combineSymbolParts(c,e,i)})}async _getSymbolPart(t,e){if(this._ongoingRequests.has(t))return this._ongoingRequests.get(t).then(l=>l.data);const i=this._refSymbolUrlTemplate.replaceAll(/\{itemName\}/gi,t),s=M(i,{responseType:"json",query:{f:"json"},...e});this._ongoingRequests.set(t,s);try{return(await s).data}catch(l){throw this._ongoingRequests.delete(t),l}}_combineSymbolParts(t,e,i){if(!t||t.length===0)return null;const s={...t[0]};if(t.length>1){s.symbolLayers=[];for(const l of t){const c=l;s.symbolLayers.unshift(...c.symbolLayers)}}return i&&(s.callout=F),{type:"CIMSymbolReference",symbol:s,primitiveOverrides:e}}_getFieldName(t){if(this._fieldIndex!==null){const e=this._fieldIndex.get(t);return e?e.name:t}return t}}function C(r,t){if(!r)return;const e=r.symbolLayers;if(!e)return;let i=e.length;for(;i--;){const s=e[i];s&&s.enable!==!1&&s.type==="CIMVectorMarker"&&D(s,t)}}function D(r,t){const e=r.markerGraphics;if(e)for(const i of e){if(!i)continue;const s=i.symbol;if(s)switch(s.type){case"CIMPointSymbol":case"CIMLineSymbol":case"CIMPolygonSymbol":C(s,t);break;case"CIMTextSymbol":s.fieldMap=t}}}const O=Object.freeze(Object.defineProperty({__proto__:null,DictionaryLoader:q},Symbol.toStringTag,{value:"Module"}));export{O as D,w as r,q as y};

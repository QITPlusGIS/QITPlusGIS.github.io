import{cp as Y,h as _,o as u}from"./uuid-8543c34e.js";import{i as P}from"./originUtils-cfe4feaf.js";import{Z as z}from"./FeatureLayer-45a1e5d9.js";import{I as B,y as $,w as E,b as G,u as j,v as k,l as N,d as V,m as I}from"./utils-854d7d06.js";import{p as y}from"./arcgisLayerUrl-ec2f2135.js";import{r as Z}from"./fetchService-feb4ca6b.js";import{h as q}from"./layerUtils-60bab848.js";import{o as x}from"./jsonContext-49166ace.js";import{l as L,a as b,u as v,f as m,i as S}from"./portalItemUtils-cfa001ef.js";import"./index-71f6c0ac.js";import"./multiOriginJSONSupportUtils-c978f4c3.js";import"./UniqueValueRenderer-5377a072.js";import"./LegendOptions-5787bf37.js";import"./diffUtils-2f40bb41.js";import"./SizeVariable-569fefc3.js";import"./colorRamps-6df6d6f7.js";import"./compilerUtils-b6fccf25.js";import"./lengthUtils-7e41a327.js";import"./ColorStop-d7d9c239.js";import"./jsonUtils-f5725ae9.js";import"./styleUtils-94d35cb4.js";import"./jsonUtils-cd25f8ce.js";import"./DictionaryLoader-77016f21.js";import"./LRUCache-20778572.js";import"./FieldsIndex-8f568a88.js";import"./heatmapUtils-7f7225e7.js";import"./vec4f64-3c9d0901.js";import"./MultiOriginJSONSupport-0b650e25.js";import"./commonProperties-33a2de5d.js";import"./ElevationInfo-4de725df.js";import"./FeatureLayerBase-cb3d46a4.js";import"./Field-d39fc769.js";import"./fieldType-2c1216fb.js";import"./featureLayerUtils-2be9b25e.js";import"./Query-6436d464.js";import"./FullTextSearch-aa688208.js";import"./QuantizationParameters-5bcf1f9a.js";import"./AttachmentQuery-89503620.js";import"./RelationshipQuery-0ef80766.js";import"./LayerFloorInfo-9ed56392.js";import"./serviceCapabilitiesUtils-2125f780.js";import"./workers-d869425a.js";import"./queryZScale-f627fdd4.js";import"./FeatureSet-5aedb17a.js";import"./APIKeyMixin-96e5d80c.js";import"./ArcGISService-5ec94bea.js";import"./BlendLayer-69a06cfc.js";import"./jsonUtils-7a48f99d.js";import"./parser-01d0d370.js";import"./mat4f32-60a2394b.js";import"./mat4-f427906c.js";import"./CustomParametersMixin-81ca532a.js";import"./EditBusLayer-3dfa86b4.js";import"./FeatureEffectLayer-3d594b7a.js";import"./FeatureEffect-8c4188ef.js";import"./FeatureReductionLayer-1cdc1e17.js";import"./clusterUtils-51d649eb.js";import"./MD5-715f37cd.js";import"./FeatureReductionSelection-6f98c66b.js";import"./LabelClass-766d0bd7.js";import"./labelUtils-308d1e86.js";import"./defaultsJSON-b087dd4d.js";import"./OperationalLayer-16bd961b.js";import"./OrderedLayer-018bff96.js";import"./PortalLayer-1236c832.js";import"./PortalItem-40a43a90.js";import"./RefreshableLayer-3d275e6c.js";import"./ScaleRangeLayer-8e351e9d.js";import"./TemporalLayer-d7a5502b.js";import"./FeatureTemplate-6db887d6.js";import"./FeatureType-dede8b35.js";import"./fieldProperties-3c3ce4a7.js";import"./labelingInfo-cc2f73a7.js";import"./versionUtils-a63f1dc6.js";import"./styleUtils-a62a4cab.js";import"./TopFeaturesQuery-5f508c79.js";import"./popupUtils-49cf1e32.js";import"./interfaces-f1f22245.js";import"./saveAPIKeyUtils-501da03f.js";import"./requestPresets-4624c7ea.js";const d="Feature Service",h="feature-layer-utils",C=`${h}-save`,H=`${h}-save-as`,c=`${h}-saveall`,f=`${h}-saveall-as`;function w(r){return{isValid:q(r)&&(r.type!=="feature"||!r.dynamicDataSource),errorMessage:"Feature layer should be a layer or table in a map or feature service"}}function g(r){const t=[],a=[];for(const{layer:i,layerJSON:l}of r)i.isTable?a.push(l):t.push(l);return{layers:t,tables:a}}function O(r){return g([r])}async function J(r,t){return/\/\d+\/?$/.test(r.url)?O(t[0]):M(t,r)}async function M(r,t){if(!t)return r.reverse(),g(r);const{layer:{url:a,customParameters:i,apiKey:l}}=r[0];let e=await t.fetchData("json");(e==null?void 0:e.layers)!=null&&(e==null?void 0:e.tables)!=null||(e=await Q(e,{url:a??"",customParameters:i,apiKey:l},r.map(o=>o.layer.layerId)));for(const o of r)R(o.layer,o.layerJSON,e);return e}async function Q(r,t,a){r||(r={}),r.layers||(r.layers=[]),r.tables||(r.tables=[]);const{url:i,customParameters:l,apiKey:e}=t,{serviceJSON:o,layersJSON:s}=await Z(i,{customParameters:l,apiKey:e}),n=T(r.layers,o.layers,a),p=T(r.tables,o.tables,a);r.layers=n.itemResources,r.tables=p.itemResources;const F=[...n.added,...p.added],K=s?[...s.layers,...s.tables]:[];return await W(r,F,i,K),r}function T(r,t,a){const i=Y(r,t,(e,o)=>e.id===o.id);r=r.filter(e=>!i.removed.some(o=>o.id===e.id));const l=i.added.map(({id:e})=>({id:e}));return l.forEach(({id:e})=>{r.push({id:e})}),{itemResources:r,added:l.filter(({id:e})=>!a.includes(e))}}async function W(r,t,a,i){const l=t.map(({id:e})=>new z({url:a,layerId:e,sourceJSON:i.find(({id:o})=>o===e)}));await Promise.allSettled(l.map(e=>e.load())),l.forEach(e=>{const{layerId:o,loaded:s,defaultPopupTemplate:n}=e;!s||n==null||R(e,{id:o,popupInfo:n.toJSON()},r)})}function R(r,t,a){r.isTable?A(a.tables,t):A(a.layers,t)}function A(r,t){const a=r.findIndex(({id:i})=>i===t.id);a===-1?r.push(t):r[a]=t}function D(r,t){if(!r.length)throw new u(`${t}:missing-parameters`,"'layers' array should contain at least one feature layer")}function X(r,t){const a=r.map(i=>i.portalItem.id);if(new Set(a).size>1)throw new u(`${t}:invalid-parameters`,"All layers in the 'layers' array should be loaded from the same portal item")}function U(r,t){const a=r.map(i=>i.layerId);if(new Set(a).size!==a.length)throw new u(`${t}:invalid-parameters`,"'layers' array should contain only one instance each of layer or table in a feature service")}async function rr(r){D(r,c),await Promise.all(r.map(t=>t.load()));for(const t of r)N(t,c,w),V({layer:t,itemType:d,errorNamePrefix:c});X(r,c),U(r,c)}async function tr(r,t){const{url:a,layerId:i,title:l,fullExtent:e,isTable:o}=r,s=y(a);t.url=(s==null?void 0:s.serverType)==="FeatureServer"?a:`${a}/${i}`,t.title||(t.title=l),t.extent=null,o||e==null||(t.extent=await L(e)),b(t,m.METADATA),b(t,m.MULTI_LAYER),S(t,m.SINGLE_LAYER),o&&S(t,m.TABLE)}function er(r,t){for(const e of r){const o=e.parsedUrl.path,s=y(o);if(!(s==null?void 0:s.url.path))throw new u(`${t}:invalid-parameters`,I(e,`has unsupported url pattern: ${o}`),{layer:e});const p=s==null?void 0:s.serverType;if(p!=="FeatureServer"&&p!=="MapServer")throw new u(`${t}:invalid-parameters`,I(e,`has unsupported server type: ${p}`),{layer:e});if(p==="MapServer"&&r.length>1)throw new u(`${t}:invalid-parameters`,"Only one layer or table in a map service can be saved")}const a=y(r[0].parsedUrl.path),i=a==null?void 0:a.url.path;if(!r.every(e=>{const o=y(e.parsedUrl.path);return(o==null?void 0:o.url.path)===i}))throw new u(`${t}:invalid-parameters`,"'layers' array should only contain layers or tables that belong to the same feature service")}async function ar(r){D(r,f),await Promise.all(r.map(t=>t.load()));for(const t of r)N(t,f,w);er(r,f),U(r,f)}async function or(r,t){let a=0,i=0;for(const{isTable:o}of t)o?i++:a++;const l=t[0].parsedUrl.path,e=y(l);if(r.url=(e==null?void 0:e.serverType)==="FeatureServer"?e.url.path:l,r.title||(r.title=e.title),r.extent=null,a>0){const o=t.map(s=>s.fullExtent).filter(_).reduce((s,n)=>s.clone().union(n));o&&(r.extent=await L(o))}b(r,m.METADATA),v(r,m.MULTI_LAYER,t.length>1),v(r,m.SINGLE_LAYER,t.length===1),v(r,m.TABLE,i>0&&a===0),E(r)}async function Ot(r,t){return B({layer:r,itemType:d,validateLayer:w,createItemData:(a,i)=>J(i,[a]),errorNamePrefix:C},t)}async function Jt(r,t){await rr(r);const a=r[0].portalItem,i=x(a),l=await Promise.all(r.map(o=>$(o,i,t))),e=await J(a,r.map((o,s)=>({layer:o,layerJSON:l[s]})));return E(a),await a.update({data:e}),await Promise.all(r.slice(1).map(o=>o.portalItem.reload())),P(i),a.clone()}async function Mt(r,t,a){return G({layer:r,itemType:d,validateLayer:w,createItemData:(i,l)=>Promise.resolve(O(i)),errorNamePrefix:H,newItem:t,setItemProperties:tr},a)}async function Rt(r,t,a){await ar(r);const i=j({itemType:d,errorNamePrefix:f,newItem:t}),l=x(i),e=await Promise.all(r.map(s=>$(s,l,a))),o=await M(r.map((s,n)=>({layer:s,layerJSON:e[n]})));await or(i,r),await k(i,o,a);for(const s of r)s.portalItem=i.clone();return P(l),i}export{Ot as save,Jt as saveAll,Rt as saveAllAs,Mt as saveAs};

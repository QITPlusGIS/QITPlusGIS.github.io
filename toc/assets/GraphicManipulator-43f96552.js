import{dr as I,D as L,gd as T,fG as J,cu as P,a as v,aS as Z,hy as A,gN as B,aj as F,l as K,eV as U,hz as Q,hA as j,hB as q,dJ as W,dK as $,hC as tt,f_ as et,b as _,c as nt,bj as it,hD as st}from"./index-797c09f0.js";import{i as lt}from"./drapedUtils-c3232933.js";function w(t,i,n,e){if(e==null||t.hasZ||(e=void 0),t.type==="point")return t.x+=i,t.y+=n,t.hasZ&&e!=null&&(t.z+=e),t;if(t.type==="multipoint"){const y=t.points;for(let a=0;a<y.length;a++)y[a]=N(y[a],i,n,e);return t}if(t.type==="extent")return t.xmin+=i,t.xmax+=i,t.ymin+=n,t.ymax+=n,e!=null&&(t.zmin??(t.zmin=0),t.zmin+=e,t.zmax??(t.zmax=0),t.zmax+=e),t;const o=I(t),s=t.type==="polyline"?t.paths:t.rings;for(let y=0;y<o.length;y++){const a=o[y];for(let l=0;l<a.length;l++)a[l]=N(a[l],i,n,e)}return"paths"in t?t.paths=s:t.rings=s,t}function ht(t,i,n,e,o){const s=t.clone(),y=e.resolution;if(s.type==="point"){if(o)w(s,i*y,-n*y);else{const a=e.state.transform,l=e.state.inverseTransform,r=a[0]*s.x+a[2]*s.y+a[4],h=a[1]*s.x+a[3]*s.y+a[5];s.x=l[0]*(r+i)+l[2]*(h+n)+l[4],s.y=l[1]*(r+i)+l[3]*(h+n)+l[5]}return s}if(s.type==="multipoint"){if(o)w(s,i*y,-n*y);else{const a=s.points,l=e.state.transform,r=e.state.inverseTransform;for(let h=0;h<a.length;h++){const p=a[h],m=l[0]*p[0]+l[2]*p[1]+l[4],d=l[1]*p[0]+l[3]*p[1]+l[5],u=r[0]*(m+i)+r[2]*(d+n)+r[4],f=r[1]*(m+i)+r[3]*(d+n)+r[5];a[h]=D(p,u,f,void 0)}}return s}if(s.type==="extent"){if(o)w(s,i*y,-n*y);else{const a=e.state.transform,l=e.state.inverseTransform,r=a[0]*s.xmin+a[2]*s.ymin+a[4],h=a[1]*s.xmin+a[3]*s.ymin+a[5],p=a[0]*s.xmax+a[2]*s.ymax+a[4],m=a[1]*s.xmax+a[3]*s.ymax+a[5];s.xmin=l[0]*(r+i)+l[2]*(h+n)+l[4],s.ymin=l[1]*(r+i)+l[3]*(h+n)+l[5],s.xmax=l[0]*(p+i)+l[2]*(m+n)+l[4],s.ymax=l[1]*(p+i)+l[3]*(m+n)+l[5]}return s}if(o)w(s,i*y,-n*y);else{const a=I(s),l=s.type==="polyline"?s.paths:s.rings,r=e.state.transform,h=e.state.inverseTransform;for(let p=0;p<a.length;p++){const m=a[p];for(let d=0;d<m.length;d++){const u=m[d],f=r[0]*u[0]+r[2]*u[1]+r[4],g=r[1]*u[0]+r[3]*u[1]+r[5],S=h[0]*(f+i)+h[2]*(g+n)+h[4],x=h[1]*(f+i)+h[3]*(g+n)+h[5];m[d]=D(u,S,x,void 0)}}"paths"in s?s.paths=l:s.rings=l}return s}function ct(t,i,n,e){if(t.type==="point"){const{x:u,y:f}=t,g=e?e[0]:u,S=e?e[1]:f,x=t.clone(),C=(u-g)*i+g,c=(f-S)*n+S;return x.x=C,x.y=c,x}if(t.type==="multipoint"){const u=I(t),f=L(),[g,S,x,C]=T(f,[u]),c=e?e[0]:(g+x)/2,M=e?e[1]:(C+S)/2,z=t.clone(),H=z.points;for(let G=0;G<H.length;G++){const E=H[G],[V,X]=E,Y=(V-c)*i+c,k=(X-M)*n+M;H[G]=D(E,Y,k,void 0)}return z}if(t.type==="extent"){const{xmin:u,xmax:f,ymin:g,ymax:S}=t,x=e?e[0]:(u+f)/2,C=e?e[1]:(S+g)/2,c=t.clone();if(c.xmin=(u-x)*i+x,c.ymax=(S-C)*n+C,c.xmax=(f-x)*i+x,c.ymin=(g-C)*n+C,c.xmin>c.xmax){const M=c.xmin,z=c.xmax;c.xmin=z,c.xmax=M}if(c.ymin>c.ymax){const M=c.ymin,z=c.ymax;c.ymin=z,c.ymax=M}return c}const o=I(t),s=L(),[y,a,l,r]=T(s,o),h=e?e[0]:(y+l)/2,p=e?e[1]:(r+a)/2,m=t.clone(),d=m.type==="polyline"?m.paths:m.rings;for(let u=0;u<o.length;u++){const f=o[u];for(let g=0;g<f.length;g++){const S=f[g],[x,C]=S,c=(x-h)*i+h,M=(C-p)*n+p;d[u][g]=D(S,c,M,void 0)}}return"paths"in m?m.paths=d:m.rings=d,m}function yt(t,i,n,e,o,s){const y=Math.sqrt((n-t)*(n-t)+(e-i)*(e-i));return Math.sqrt((o-t)*(o-t)+(s-i)*(s-i))/y}function mt(t,i,n,e=!1){const o=Math.atan2(i.y-n.y,i.x-n.x)-Math.atan2(t.y-n.y,t.x-n.x),s=Math.atan2(Math.sin(o),Math.cos(o));return e?s:J(s)}function N(t,i,n,e){return D(t,t[0]+i,t[1]+n,t[2]!=null&&e!=null?t[2]+e:void 0)}function D(t,i,n,e){const o=[i,n];return t.length>2&&o.push(e??t[2]),t.length>3&&o.push(t[3]),o}function at(t){let i=0,n=0,e=0;return t?(t.type==="cim"&&t.data.symbol&&"symbolLayers"in t.data.symbol&&t.data.symbol.symbolLayers&&t.data.symbol.symbolLayers.map(o=>{o.type==="CIMVectorMarker"&&o.anchorPoint&&(Math.abs(o.anchorPoint.x)>i&&(i=o.anchorPoint.x),Math.abs(o.anchorPoint.y)>n&&(n=o.anchorPoint.y),o.size!=null&&o.size>e&&(e=o.size))}),i=P(i),n=P(n),e=P(e),{offsetX:i,offsetY:n,size:e}):{offsetX:i,offsetY:n,size:e}}let b=class extends Z{set graphic(t){this._circleCollisionCache=null,this._originalSymbol=t.symbol,this._set("graphic",t),this.attachSymbolChanged()}get elevationInfo(){const{layer:t}=this.graphic,i=t&&"elevationInfo"in t?t.elevationInfo:null,n=A(this.graphic),e=i?i.offset:0;return new B({mode:n,offset:e})}set focusedSymbol(t){t!==this._get("focusedSymbol")&&(this._set("focusedSymbol",t),this._updateGraphicSymbol(),this._circleCollisionCache=null)}grabbableForEvent(){return!0}set grabbing(t){t!==this._get("grabbing")&&(this._set("grabbing",t),this._updateGraphicSymbol())}set hovering(t){t!==this._get("hovering")&&(this._set("hovering",t),this._updateGraphicSymbol())}set selected(t){t!==this._get("selected")&&(this._set("selected",t),this._updateGraphicSymbol(),this.events.emit("select-changed",{action:t?"select":"deselect"}))}get _focused(){return this._get("hovering")||this._get("grabbing")}constructor(t){super(t),this.layer=null,this.interactive=!0,this.selectable=!1,this.grabbable=!0,this.dragging=!1,this.cursor=null,this.events=new F.EventEmitter,this._circleCollisionCache=null,this._graphicSymbolChangedHandle=null,this._originalSymbol=null}destroy(){this.detachSymbolChanged(),this._resetGraphicSymbol(),this._set("view",null)}intersectionDistance(t){const i=this.graphic;if(i.visible===!1)return null;const n=i.geometry;if(n==null)return null;const e=this._get("focusedSymbol"),o=e??i.symbol;return this.view.type==="2d"?this._intersectDistance2D(this.view,t,n,o):this._intersectDistance3D(this.view,t,i)}attach(){this.attachSymbolChanged(),this.layer!=null&&this.layer.add(this.graphic)}detach(){this.detachSymbolChanged(),this._resetGraphicSymbol(),this.layer!=null&&this.layer.remove(this.graphic)}attachSymbolChanged(){this.detachSymbolChanged(),this._graphicSymbolChangedHandle=K(()=>{var t;return(t=this.graphic)==null?void 0:t.symbol},t=>{t!=null&&t!==this.focusedSymbol&&t!==this._originalSymbol&&(this._originalSymbol=t,this._focused&&this.focusedSymbol!=null&&(this.graphic.symbol=this.focusedSymbol))},U)}detachSymbolChanged(){this._graphicSymbolChangedHandle!=null&&(this._graphicSymbolChangedHandle.remove(),this._graphicSymbolChangedHandle=null)}onElevationChange(){}onViewChange(){}_updateGraphicSymbol(){this.graphic.symbol=this._focused&&this.focusedSymbol!=null?this.focusedSymbol:this._originalSymbol}_resetGraphicSymbol(){this.graphic.symbol=this._originalSymbol}_intersectDistance2D(t,i,n,e){var y,a;if((e=e||Q(n))==null)return null;const o=1;let s=this._circleCollisionCache;if(n.type==="point"&&e.type==="cim"&&((y=e.data.symbol)==null?void 0:y.type)==="CIMPointSymbol"&&e.data.symbol.symbolLayers){const{offsetX:l,offsetY:r,size:h}=at(e),p=j(i,R),m=h/2,d=t.toScreen(n),u=d.x+l,f=d.y+r;return q(p,[u,f])<m*m?o:null}if(n.type!=="point"||e.type!=="simple-marker")return lt(i,n,t)?o:null;if(s==null||!s.originalPoint.equals(n)){const l=n,r=t.spatialReference;if(W(l.spatialReference,r)){const h=$(l,r);s={originalPoint:l.clone(),mapPoint:h,radiusPx:P(e.size)},this._circleCollisionCache=s}}if(s!=null){const l=j(i,R),r=(a=t.toScreen)==null?void 0:a.call(t,s.mapPoint);if(!r)return null;const h=s.radiusPx,p=r.x+P(e.xoffset),m=r.y-P(e.yoffset);return q(l,[p,m])<h*h?o:null}return null}_intersectDistance3D(t,i,n){const e=t.toMap(i,{include:[n]});return e&&tt(e,O,t.renderSpatialReference)?et(O,t.state.camera.eye):null}};v([_({constructOnly:!0,nonNullable:!0})],b.prototype,"graphic",null),v([_()],b.prototype,"elevationInfo",null),v([_({constructOnly:!0,nonNullable:!0})],b.prototype,"view",void 0),v([_({value:null})],b.prototype,"focusedSymbol",null),v([_({constructOnly:!0})],b.prototype,"layer",void 0),v([_()],b.prototype,"interactive",void 0),v([_()],b.prototype,"selectable",void 0),v([_()],b.prototype,"grabbable",void 0),v([_({value:!1})],b.prototype,"grabbing",null),v([_()],b.prototype,"dragging",void 0),v([_()],b.prototype,"hovering",null),v([_({value:!1})],b.prototype,"selected",null),v([_()],b.prototype,"cursor",void 0),b=v([nt("esri.views.interactive.GraphicManipulator")],b);const O=it(),R=st();export{b as S,yt as a,at as b,ht as i,mt as m,w as r,ct as s};

import{h3 as Bt,q$ as Ls,fw as Na,qh as rt,bQ as W,lE as Mt,bu as pe,fy as ot,ht as za,r0 as Fs,fP as ye,f_ as Fr,bG as li,g0 as Ns,r1 as ja,fo as k,f$ as oe,d7 as Rt,fD as K,bj as N,aj as zs,bp as Me,aH as js,j as Us,e_ as je,z as it,iD as Ua,hm as kt,iE as m,a as v,b as $,aS as gi,hc as Va,kk as Vs,iG as Ve,cY as le,r2 as Ei,mT as Ii,lN as Ur,lO as Kt,r3 as Ha,fx as Wa,fz as Vt,r4 as Hs,mb as vi,r5 as Ga,r6 as Pi,r7 as $i,jk as Pt,r8 as Mi,r9 as Ba,mX as ka,hD as qa,hi as jt,he as ce,kc as Qe,dn as Xt,cZ as ci,c_ as Le,bO as ne,jm as Za,s as Nr,ra as Ws,c as zr,mo as et,hb as p,ma as Ja,iF as qt,ar as _i,cW as Gs,hf as Qt,mc as Bs,hv as st,aa as Ht,mh as Ya,hk as er,mi as Ee,mj as Li,mk as Xa,g2 as Vr,ml as Qa,mn as yi,fU as ks,bI as xr,d5 as q,l4 as Fi,lP as Ka,rb as eo,jl as to,fp as Rr,lA as qe,lB as Tt,kj as Ft,hB as Ni,d3 as St,lx as ae,rc as ro,kC as zi,rd as ut,re as tr,bR as io,na as so,mr as ao,lH as qs,rf as oo,mm as no,rg as lo,rh as co,dM as ji,ri as Ue,rj as ho,rk as uo,rl as po,rm as Ui,rn as fo,ro as mo,l as Hr,cP as Vi,w as go,lq as vo,h7 as _o,rp as yo,rq as Wr,jc as wo,rr as To,gR as So,f4 as Q,fY as B,iM as Hi,lG as xo,qt as Ro,ho as Co,rs as bo,rt as Oo,ru as Do,cU as wi,rv as Ao,qw as Eo,D as Io,rw as Po,fN as $o,kO as Mo,q_ as Lo,qL as Fo,rx as No,eH as zo,ry as jo,rz as Uo,rA as Vo,bJ as Ho,fs as Wo,aw as Go,h9 as Bo,rB as ko,qA as qo,rC as Zo,rD as Jo}from"./index-4457faad.js";import{t as Ti,a as Wi}from"./DoubleArray-28266794.js";import{ay as Gi,az as Bi,aA as ki,G as E,aB as ze,i as Si,u as Yo,s as nt,e as at,q as Zs,p as O,K as xi,o as Y,b as Ct,aC as qi,D as Xo,B as Qo,f as Js,A as Ri,ak as Ko,U as en,F as Ys,y as Xs,h as $t,g as jr,W as tn,aD as rn,X as Qs,P as xt,C as Ks,H as Be,j as Ci,k as bi,Y as Zi,Z as Ji,_ as sn,E as J,l as Oi,aE as Yi,aF as an,aG as on,aH as nn,a1 as ln,t as ea,a0 as cn,aI as Xi,aw as we,av as L,a as ta,aJ as Gr,aK as dn,at as hn,aL as un,ad as pn,x as Br,al as ra,am as ia,aM as fn,T as mn,ap as gn,J as vn,an as _n,aj as yn,ah as sa,ar as wn,$ as Tn,r as Sn,aN as xn,aO as Rn,aP as Cn,aQ as rr,aR as Qi,L as Ki,aS as bn,v as On,ax as Ce,aT as es}from"./FloatArray-73ba570e.js";import{l as aa,y as Dn}from"./Indices-836a5a9a.js";import{o as An,x as En,u as In}from"./hydratedFeatures-1f5e8f4b.js";import{a as Cr,f as oa}from"./triangulationUtils-2852bf6d.js";import{D as di,L as br,E as hi,M as Pn,_ as Or,B as $n,F as Mn,R as ir}from"./enums-b14466b3.js";import{x as na,i as Ln,c as Fn}from"./VertexArrayObject-79e51137.js";import{e as Dr,T as gr,n as Nn}from"./Texture-53149a07.js";import{t as Di}from"./NestedMap-1b5db22e.js";import{W as zn,I as jn,L as Un,s as Vn,l as sr}from"./Octree-30686065.js";import{t as ts,N as Hn}from"./basicInterfaces-bb952591.js";import{H as dt}from"./InterleavedLayout-2de7b1c4.js";import{o as ge,W as tt,c as vr,A as la,l as ca,b as da,E as ha,_ as Ot,f as Wn,d as Gn,S as Bn,e as kn}from"./OrderIndependentTransparency-2a607a9a.js";import"./floatRGBA-45eb4edf.js";import{r as qn}from"./glUtil-0b7ee6ea.js";let Zn=class{constructor(){this.enabled=!0,this._time=Bt(0)}get time(){return this._time}advance({deltaTime:e,fixedTime:r}){return r!=null?this._time!==r&&(this._time=r,!0):(this._time=Bt(this._time+e),e!==0)}};var Wt,Ar,ui;(function(t){t[t.RasterImage=0]="RasterImage",t[t.Features=1]="Features"})(Wt||(Wt={})),function(t){t[t.MapLayer=0]="MapLayer",t[t.ViewLayer=1]="ViewLayer",t[t.Outline=2]="Outline",t[t.SnappingHint=3]="SnappingHint"}(Ar||(Ar={})),function(t){t[t.WithRasterImage=0]="WithRasterImage",t[t.WithoutRasterImage=1]="WithoutRasterImage"}(ui||(ui={}));var Er,$e;(function(t){t[t.ADD=0]="ADD",t[t.UPDATE=1]="UPDATE",t[t.REMOVE=2]="REMOVE"})(Er||(Er={})),function(t){t[t.NONE=0]="NONE",t[t.VISIBILITY=1]="VISIBILITY",t[t.GEOMETRY=2]="GEOMETRY",t[t.TRANSFORMATION=4]="TRANSFORMATION",t[t.HIGHLIGHT=8]="HIGHLIGHT",t[t.OCCLUDEE=16]="OCCLUDEE"}($e||($e={}));var Zt;(function(t){t[t.ASYNC=0]="ASYNC",t[t.SYNC=1]="SYNC"})(Zt||(Zt={}));let Jn=class extends Ls{get geometries(){return this._geometries}get transformation(){return this._transformation??Na}set transformation(e){this._transformation=rt(this._transformation??W(),e),this._invalidateBoundingVolume(),this._emit("objectTransformation",this)}get shaderTransformation(){return this._shaderTransformation??this.transformation}set shaderTransformation(e){this._shaderTransformation=rt(this._shaderTransformation??W(),e),this._invalidateBoundingVolume(),this._emit("objectShaderTransformation",this)}clearShaderTransformation(){this._shaderTransformation=void 0,this._invalidateBoundingVolume(),this._emit("objectShaderTransformation",this)}constructor(e={}){super(),this.type=Mt.Object,this._hasVolatileTransformation=!1,this._parentLayer=null,this._visible=!0,this.castShadow=e.castShadow??!0,this.usesVerticalDistanceToGround=e.usesVerticalDistanceToGround??!1,this.graphicUid=e.graphicUid,this.layerUid=e.layerUid,e.isElevationSource&&(this.lastValidElevationBB=new ua),this._geometries=e.geometries?Array.from(e.geometries):new Array}dispose(){this._geometries.length=0}get parentLayer(){return this._parentLayer}set parentLayer(e){pe(this._parentLayer==null||e==null,"Object3D can only be added to a single Layer"),this._parentLayer=e}addGeometry(e){e.visible=this._visible,this._geometries.push(e),this._hasVolatileTransformation=this._hasVolatileTransformation||e.hasVolatileTransformation,this._emit("objectGeometryAdded",{object:this,geometry:e}),this._invalidateBoundingVolume()}removeGeometry(e){const r=this._geometries.splice(e,1)[0];r&&(this._emit("objectGeometryRemoved",{object:this,geometry:r}),this._invalidateBoundingVolume())}removeAllGeometries(){for(;this._geometries.length>0;)this.removeGeometry(0)}geometryVertexAttrsUpdated(e){this._emit("objectGeometryUpdated",{object:this,geometry:e}),this._invalidateBoundingVolume()}get visible(){return this._visible}set visible(e){if(this._visible!==e){this._visible=e;for(const r of this._geometries)r.visible=this._visible;this._emit("visibilityChanged",this)}}maskOccludee(){const e=new Gi(ts.MaskOccludee);for(const r of this._geometries)r.occludees=Bi(r.occludees,e);return this._emit("occlusionChanged",this),e}removeOcclude(e){for(const r of this._geometries)r.occludees=ki(r.occludees,e);this._emit("occlusionChanged",this)}highlight(){const e=new Gi(ts.Highlight);for(const r of this._geometries)r.highlights=Bi(r.highlights,e);return this._emit("highlightChanged",this),e}removeHighlight(e){for(const r of this._geometries)r.highlights=ki(r.highlights,e);this._emit("highlightChanged",this)}getCombinedStaticTransformation(e,r){return ot(r,this.transformation,e.transformation)}getCombinedShaderTransformation(e,r=W()){return ot(r,this.shaderTransformation,e.shaderTransformation)}hasVolativeTransformation(){return this._hasVolatileTransformation}get boundingVolumeWorldSpace(){return this._bvWorldSpace&&!this._hasVolatileTransformation||(this._bvWorldSpace=this._bvWorldSpace||new rs,this._validateBoundingVolume(this._bvWorldSpace,Gt.WorldSpace)),this._bvWorldSpace}get boundingVolumeObjectSpace(){return this._bvObjectSpace&&!this._hasVolatileTransformation||(this._bvObjectSpace=this._bvObjectSpace||new rs,this._validateBoundingVolume(this._bvObjectSpace,Gt.ObjectSpace)),this._bvObjectSpace}_validateBoundingVolume(e,r){const i=r===Gt.ObjectSpace;for(const s of this._geometries){const a=s.boundingInfo;a&&Yn(a,e,i?s.shaderTransformation:this.getCombinedShaderTransformation(s))}za(e.bounds,e.min,e.max,.5);for(const s of this._geometries){const a=s.boundingInfo;if(a==null)continue;const o=i?s.shaderTransformation:this.getCombinedShaderTransformation(s),n=Fs(o);ye(is,a.center,o);const l=Fr(is,e.bounds),c=a.radius*n;e.bounds[3]=Math.max(e.bounds[3],l+c)}}_invalidateBoundingVolume(){var r;const e=(r=this._bvWorldSpace)==null?void 0:r.bounds;this._bvObjectSpace=this._bvWorldSpace=void 0,this._parentLayer&&e&&this._parentLayer.notifyObjectBBChanged(this,e)}_emit(e,r){this._parentLayer&&this._parentLayer.events.emit(e,r)}get test(){const e=this;return{hasGeometry:r=>e._geometries.includes(r),getGeometryIndex:r=>e._geometries.indexOf(r)}}},ua=class{constructor(){this.min=li(Number.MAX_VALUE,Number.MAX_VALUE,Number.MAX_VALUE),this.max=li(-Number.MAX_VALUE,-Number.MAX_VALUE,-Number.MAX_VALUE)}isEmpty(){return this.max[0]<this.min[0]&&this.max[1]<this.min[1]&&this.max[2]<this.min[2]}},rs=class extends ua{constructor(){super(...arguments),this.bounds=Ns()}};function Yn(t,e,r){const i=t.bbMin,s=t.bbMax;if(ja(r)){const a=k(Xn,r[12],r[13],r[14]);oe(ve,i,a),oe(Oe,s,a);for(let o=0;o<3;++o)e.min[o]=Math.min(e.min[o],ve[o]),e.max[o]=Math.max(e.max[o],Oe[o])}else if(ye(ve,i,r),Rt(i,s))for(let a=0;a<3;++a)e.min[a]=Math.min(e.min[a],ve[a]),e.max[a]=Math.max(e.max[a],ve[a]);else{ye(Oe,s,r);for(let a=0;a<3;++a)e.min[a]=Math.min(e.min[a],ve[a],Oe[a]),e.max[a]=Math.max(e.max[a],ve[a],Oe[a]);for(let a=0;a<3;++a){K(ve,i),K(Oe,s),ve[a]=s[a],Oe[a]=i[a],ye(ve,ve,r),ye(Oe,Oe,r);for(let o=0;o<3;++o)e.min[o]=Math.min(e.min[o],ve[o],Oe[o]),e.max[o]=Math.max(e.max[o],ve[o],Oe[o])}}}const Xn=N(),ve=N(),Oe=N(),is=N();var Gt;(function(t){t[t.WorldSpace=0]="WorldSpace",t[t.ObjectSpace=1]="ObjectSpace"})(Gt||(Gt={}));const Qn=["layerObjectAdded","layerObjectRemoved","layerObjectsAdded","layerObjectsRemoved","shaderTransformationChanged","objectTransformation","visibilityChanged","occlusionChanged","highlightChanged","objectGeometryAdded","objectGeometryRemoved","objectGeometryUpdated"];let Kn=class extends Ls{get objects(){return this._objects}constructor(e,r,i=""){super(),this.stage=e,this.apiLayerUid=i,this.type=Mt.Layer,this.events=new zs,this.sliceable=!1,this._objects=new Me,this._objectsAdded=new Me,this._handles=new js,this.apiLayerUid=i,this.visible=(r==null?void 0:r.visible)??!0,this.pickable=(r==null?void 0:r.pickable)??!0,this.updatePolicy=(r==null?void 0:r.updatePolicy)??Zt.ASYNC,this._disableOctree=(r==null?void 0:r.disableOctree)??!1,e.add(this);for(const s of Qn)this._handles.add(this.events.on(s,a=>e.handleEvent(s,a)))}destroy(){this._handles.size&&(this._handles.destroy(),this.stage.remove(this),this.invalidateSpatialQueryAccelerator())}add(e){this._objects.push(e),e.parentLayer=this,this.events.emit("layerObjectAdded",{layer:this,object:e}),this._octree!=null&&this._objectsAdded.push(e)}remove(e){this._objects.removeUnordered(e)&&(e.parentLayer=null,this.events.emit("layerObjectRemoved",{layer:this,object:e}),this._octree!=null&&(this._objectsAdded.removeUnordered(e)||this._octree.remove([e])))}addMany(e){this._objects.pushArray(e);for(const r of e)r.parentLayer=this;this.events.emit("layerObjectsAdded",{layer:this,objects:e}),this._octree!=null&&this._objectsAdded.pushArray(e)}removeMany(e){const r=new Array;if(this._objects.removeUnorderedMany(e,e.length,r),r.length!==0){for(const i of r)i.parentLayer=null;if(this.events.emit("layerObjectsRemoved",{layer:this,objects:r}),this._octree!=null){for(let i=0;i<r.length;)this._objectsAdded.removeUnordered(r[i])?(r[i]=r[r.length-1],r.length-=1):++i;this._octree.remove(r)}}}sync(){this.updatePolicy!==Zt.SYNC&&this.stage.syncLayer(this.id)}notifyObjectBBChanged(e,r){this._octree==null||this._objectsAdded.includes(e)||this._octree.update(e,r)}getSpatialQueryAccelerator(){return this._octree==null&&this._objects.length>50&&!this._disableOctree?(this._octree=new zn(e=>e.boundingVolumeWorldSpace.bounds),this._octree.add(this._objects.data,this._objects.length)):this._octree!=null&&this._objectsAdded.length>0&&(this._octree.add(this._objectsAdded.data,this._objectsAdded.length),this._objectsAdded.clear()),this._octree}shaderTransformationChanged(){this.invalidateSpatialQueryAccelerator(),this.events.emit("shaderTransformationChanged",this)}invalidateSpatialQueryAccelerator(){this._octree=Us(this._octree),this._objectsAdded.clear()}},pa=class{constructor(e,r){this._fbo=null;const i=new Dr;i.wrapMode=di.CLAMP_TO_EDGE,i.samplingMode=br.LINEAR_MIPMAP_LINEAR,i.hasMipmap=r,i.maxAnisotropy=8,this._fbo=new na(e,i)}dispose(){this._fbo=je(this._fbo)}getTexture(){var e;return(e=this._fbo)==null?void 0:e.colorTexture}isValid(){return this._fbo!=null}resize(e,r){var i;(i=this._fbo)==null||i.resize(e,r)}bind(e){e.bindFramebuffer(this._fbo)}generateMipMap(){var r;const e=(r=this._fbo)==null?void 0:r.colorTexture;e!=null&&e.descriptor.hasMipmap&&e.generateMipmap()}disposeRenderTargetMemory(){var e;(e=this._fbo)==null||e.resize(0,0)}get gpuMemoryUsage(){var e;return((e=this._fbo)==null?void 0:e.gpuMemoryUsage)??0}},pt=class{constructor(e,r,i,s=!0){this.output=r,this.type=i,this.valid=!1,this.lastUsed=Bt(1/0),this.fbo=new pa(e,s)}},el=class{constructor(e){this.renderTargets=[new pt(e,E.Color,ze.Color),new pt(e,E.Color,ze.ColorNoRasterImage),new pt(e,E.Highlight,ze.Highlight,!1),new pt(e,E.Normal,ze.Water),new pt(e,E.Color,ze.Occluded)],it("enable-feature:objectAndLayerId-rendering")&&this.renderTargets.push(new pt(e,E.ObjectAndLayerIdColor,ze.ObjectAndLayerIdColor))}getTarget(e){return this.renderTargets[e].fbo}dispose(){for(const e of this.renderTargets)e.fbo.dispose()}disposeRenderTargetMemory(){for(const e of this.renderTargets)e.fbo.disposeRenderTargetMemory()}validateUsageForTarget(e,r,i){return e?(r.lastUsed=i,!1):i-r.lastUsed>tl?(r.fbo.disposeRenderTargetMemory(),r.lastUsed=Bt(1/0),!1):r.lastUsed<1/0}get gpuMemoryUsage(){return this.renderTargets.reduce((e,r)=>e+r.fbo.gpuMemoryUsage,0)}};const tl=Bt(1e3);let fa=class extends Ua{constructor(){super(...arguments),this.color=kt(1,1,1,1)}};function rl(){const t=new Si;return t.include(Yo),t.fragment.uniforms.add(new nt("tex",e=>e.texture),new at("uColor",e=>e.color)),t.fragment.code.add(m`void main() {
vec4 texColor = texture(tex, uv);
fragColor = texColor * uColor;
}`),t}const il=Object.freeze(Object.defineProperty({__proto__:null,TextureOnlyPassParameters:fa,build:rl},Symbol.toStringTag,{value:"Module"}));let sl=class{constructor(e){this._context=e,this._perConstructorInstances=new Di,this._frameCounter=0,this._keepAliveFrameCount=ss}get viewingMode(){return this._context.viewingMode}get constructionContext(){return this._context}destroy(){this._perConstructorInstances.forEach(e=>e.forEach(r=>r.technique.destroy())),this._perConstructorInstances.clear()}acquire(e,r=ol){const i=r.key;let s=this._perConstructorInstances.get(e,i);if(s==null){const a=new e(this._context,r,()=>this.release(a));s=new al(a),this._perConstructorInstances.set(e,i,s)}return++s.refCount,s.technique}releaseAndAcquire(e,r,i){if(i!=null){if(r.key===i.key)return i;this.release(i)}return this.acquire(e,r)}release(e){if(e==null||this._perConstructorInstances.empty)return;const r=this._perConstructorInstances.get(e.constructor,e.key);r!=null&&(--r.refCount,r.refCount===0&&(r.refZeroFrame=this._frameCounter))}frameUpdate(){this._frameCounter++,this._keepAliveFrameCount!==ss&&this._perConstructorInstances.forEach((e,r)=>{e.forEach((i,s)=>{i.refCount===0&&i.refZeroFrame+this._keepAliveFrameCount<this._frameCounter&&(i.technique.destroy(),this._perConstructorInstances.delete(r,s))})})}async reloadAll(){const e=new Array;this._perConstructorInstances.forEach((r,i)=>{const s=async(a,o)=>{const n=o.shader;n&&(await n.reload(),a.forEach(l=>l.technique.reload(this._context)))};e.push(s(r,i))}),await Promise.all(e)}},al=class{constructor(e){this.technique=e,this.refCount=0,this.refZeroFrame=0}};const ss=-1,ol=new Zs;function nl(t,e,r){return 2*Math.atan(Math.sqrt(e*e+r*r)*Math.tan(.5*t)/e)}function ll(t,e,r){return 2*Math.atan(Math.sqrt(e*e+r*r)*Math.tan(.5*t)/r)}function cl(t,e,r){return 2*Math.atan(e*Math.tan(.5*t)/Math.sqrt(e*e+r*r))}function dl(t,e,r){return 2*Math.atan(r*Math.tan(.5*t)/Math.sqrt(e*e+r*r))}var pi;let F=pi=class extends gi{constructor(t={}){super(t),this._center=N(),this._up=N(),this._viewUp=N(),this._viewForward=N(),this._viewRight=N(),this._ray=Va(),this._viewport=kt(0,0,1,1),this._padding=kt(0,0,0,0),this._fov=55/180*Math.PI,this._nearFar=Vs(1,1e3),this._viewDirty=!0,this._viewMatrix=W(),this._viewProjectionDirty=!0,this._viewProjectionMatrix=W(),this._viewInverseTransposeMatrixDirty=!0,this._viewInverseTransposeMatrix=W(),this._frustumDirty=!0,this._frustum=jn(),this._fullViewport=Ve(),this._pixelRatio=1,this.relativeElevation=0}get pixelRatio(){return this._pixelRatio}set pixelRatio(t){this._pixelRatio=t>0?t:1}get eye(){return this._ray.origin}set eye(t){this._compareAndSetView(t,this._ray.origin)}get center(){return this._center}set center(t){this._compareAndSetView(t,this._center,"_center")}get ray(){return le(this._ray.direction,this.center,this.eye),this._ray}get up(){return this._up}set up(t){this._compareAndSetView(t,this._up,"_up")}get viewMatrix(){return this._ensureViewClean(),this._viewMatrix}set viewMatrix(t){rt(this._viewMatrix,t),this._viewDirty=!1,this._viewInverseTransposeMatrixDirty=!0,this._viewProjectionDirty=!0,this._frustumDirty=!0}get viewForward(){return this._ensureViewClean(),this._viewForward}get viewUp(){return this._ensureViewClean(),this._viewUp}get viewRight(){return this._ensureViewClean(),this._viewRight}get nearFar(){return this._nearFar}get near(){return this._nearFar[0]}set near(t){this._nearFar[0]!==t&&(this._nearFar[0]=t,this._viewProjectionDirty=!0,this._frustumDirty=!0,this.notifyChange("_nearFar"))}get far(){return this._nearFar[1]}set far(t){this._nearFar[1]!==t&&(this._nearFar[1]=t,this._viewProjectionDirty=!0,this._frustumDirty=!0,this.notifyChange("_nearFar"))}get viewport(){return this._viewport}set viewport(t){this.x=t[0],this.y=t[1],this.width=t[2],this.height=t[3]}get screenViewport(){if(this.pixelRatio===1)return this._viewport;const t=Ei(Ve(),this._viewport,1/this.pixelRatio),e=this._get("screenViewport");return e&&Ii(t,e)?e:t}get screenPadding(){if(this.pixelRatio===1)return this._padding;const t=Ei(Ve(),this._padding,1/this.pixelRatio),e=this._get("screenPadding");return e&&Ii(t,e)?e:t}get x(){return this._viewport[0]}set x(t){t+=this._padding[j.LEFT],this._viewport[0]!==t&&(this._viewport[0]=t,this._viewProjectionDirty=!0,this._frustumDirty=!0,this.notifyChange("_viewport"))}get y(){return this._viewport[1]}set y(t){t+=this._padding[j.BOTTOM],this._viewport[1]!==t&&(this._viewport[1]=t,this._viewProjectionDirty=!0,this._frustumDirty=!0,this.notifyChange("_viewport"))}get width(){return this._viewport[2]}set width(t){this._viewport[2]!==t&&(this._viewport[2]=t,this._viewProjectionDirty=!0,this._frustumDirty=!0,this.notifyChange("_viewport"))}get height(){return this._viewport[3]}set height(t){this._viewport[3]!==t&&(this._viewport[3]=t,this._viewProjectionDirty=!0,this._frustumDirty=!0,this.notifyChange("_viewport"))}get fullWidth(){return this._viewport[2]+this._padding[j.RIGHT]+this._padding[j.LEFT]}set fullWidth(t){this.width=t-(this._padding[j.RIGHT]+this._padding[j.LEFT])}get fullHeight(){return this._viewport[3]+this._padding[j.TOP]+this._padding[j.BOTTOM]}set fullHeight(t){this.height=t-(this._padding[j.TOP]+this._padding[j.BOTTOM])}get fullViewport(){return this._fullViewport[0]=this._viewport[0]-this._padding[j.LEFT],this._fullViewport[1]=this._viewport[1]-this._padding[j.BOTTOM],this._fullViewport[2]=this.fullWidth,this._fullViewport[3]=this.fullHeight,this._fullViewport}get _aspect(){return this.width/this.height}get padding(){return this._padding}set padding(t){Ur(this._padding,t)||(this._viewport[0]+=t[j.LEFT]-this._padding[j.LEFT],this._viewport[1]+=t[j.BOTTOM]-this._padding[j.BOTTOM],this._viewport[2]-=t[j.RIGHT]+t[j.LEFT]-(this._padding[j.RIGHT]+this._padding[j.LEFT]),this._viewport[3]-=t[j.TOP]+t[j.BOTTOM]-(this._padding[j.TOP]+this._padding[j.BOTTOM]),Kt(this._padding,t),this._viewProjectionDirty=!0,this._frustumDirty=!0,this.notifyChange("_padding"),this.notifyChange("_viewport"))}get viewProjectionMatrix(){return this._viewProjectionDirty&&(ot(this._viewProjectionMatrix,this.projectionMatrix,this.viewMatrix),this._viewProjectionDirty=!1),this._viewProjectionMatrix}get projectionMatrix(){const t=this.width,e=this.height,r=this.near*Math.tan(this.fovY/2),i=r*this._aspect,s=Ha(W(),-i*(1+2*this._padding[j.LEFT]/t),i*(1+2*this._padding[j.RIGHT]/t),-r*(1+2*this._padding[j.BOTTOM]/e),r*(1+2*this._padding[j.TOP]/e),this.near,this.far),a=this._get("projectionMatrix");return a&&Wa(a,s)?a:s}get inverseProjectionMatrix(){return Vt(W(),this.projectionMatrix)||this._get("inverseProjectionMatrix")||W()}get fov(){return this._fov}set fov(t){this._fov=t,this._viewProjectionDirty=!0,this._frustumDirty=!0}get fovX(){return cl(this._fov,this.width,this.height)}set fovX(t){this._fov=nl(t,this.width,this.height),this._viewProjectionDirty=!0,this._frustumDirty=!0}get fovY(){return dl(this._fov,this.width,this.height)}set fovY(t){this._fov=ll(t,this.width,this.height),this._viewProjectionDirty=!0,this._frustumDirty=!0}get distance(){return Fr(this.center,this.eye)}get frustum(){return this._recomputeFrustum(),this._frustum}get viewInverseTransposeMatrix(){return(this._viewInverseTransposeMatrixDirty||this._viewDirty)&&(Vt(this._viewInverseTransposeMatrix,this.viewMatrix),Hs(this._viewInverseTransposeMatrix,this._viewInverseTransposeMatrix),this._viewInverseTransposeMatrixDirty=!1),this._viewInverseTransposeMatrix}depthNDCToWorld(t){const e=2*t-1;return 2*this.near*this.far/(this.far+this.near-e*(this.far-this.near))}get perRenderPixelRatio(){return Math.tan(this.fovX/2)/(this.width/2)}get perScreenPixelRatio(){return this.perRenderPixelRatio*this.pixelRatio}get aboveGround(){return this.relativeElevation!=null&&this.relativeElevation>=0}copyFrom(t){K(this._ray.origin,t.eye),this.center=t.center,this.up=t.up,Kt(this._viewport,t.viewport),this.notifyChange("_viewport"),Kt(this._padding,t.padding),this.notifyChange("_padding"),vi(this._nearFar,t.nearFar),this.notifyChange("_nearFar"),this._fov=t.fov,this.relativeElevation=t.relativeElevation;const e=t;return this._viewDirty=e._viewDirty,this._viewDirty||(rt(this._viewMatrix,t.viewMatrix),K(this._viewRight,t.viewRight),K(this._viewUp,t.viewUp),K(this._viewForward,t.viewForward)),this._viewProjectionDirty=!0,this._frustumDirty=e._frustumDirty,this._frustumDirty||(Un(this._frustum,t.frustum),this._frustumDirty=!1),e._viewInverseTransposeMatrixDirty?this._viewInverseTransposeMatrixDirty=!0:(rt(this._viewInverseTransposeMatrix,t.viewInverseTransposeMatrix),this._viewInverseTransposeMatrixDirty=!1),Kt(this._fullViewport,t.fullViewport),this.pixelRatio=t.pixelRatio,this}copyViewFrom(t){this.eye=t.eye,this.center=t.center,this.up=t.up}clone(){return new pi().copyFrom(this)}equals(t){return Rt(this.eye,t.eye)&&Rt(this.center,t.center)&&Rt(this.up,t.up)&&Ur(this._viewport,t.viewport)&&Ur(this._padding,t.padding)&&Ga(this.nearFar,t.nearFar)&&this._fov===t.fov&&this.pixelRatio===t.pixelRatio&&this.relativeElevation===t.relativeElevation}almostEquals(t){if(Math.abs(t.fov-this._fov)>=.001||Pi(t.screenPadding,this.screenPadding)>=1||Pi(this.screenViewport,t.screenViewport)>=1)return!1;$i(ie,t.eye,t.center),$i(kr,this.eye,this.center);const e=Pt(ie,kr),r=Mi(ie),i=Mi(kr),s=5e-4;return e*e>=(1-1e-10)*r*i&&Ba(t.eye,this.eye)<Math.max(r,i)*s*s}computeRenderPixelSizeAt(t){return this.computeRenderPixelSizeAtDist(this._viewDirectionDistance(t))}computeRenderPixelSizeAtDist(t){return t*this.perScreenPixelRatio}computeScreenPixelSizeAt(t){return this.computeScreenPixelSizeAtDist(this._viewDirectionDistance(t))}_viewDirectionDistance(t){return Math.abs(ka(this.viewForward,le(ie,t,this.eye)))}computeScreenPixelSizeAtDist(t){return t*this.perScreenPixelRatio}computeDistanceFromRadius(t,e){return t/Math.tan(Math.min(this.fovX,this.fovY)/(2*(e||1)))}getScreenCenter(t=qa()){return t[0]=(this.padding[j.LEFT]+this.width/2)/this.pixelRatio,t[1]=(this.padding[j.TOP]+this.height/2)/this.pixelRatio,t}getRenderCenter(t,e=.5,r=.5){return t[0]=this.padding[j.LEFT]+this.width*e,t[1]=this.padding[j.BOTTOM]+this.height*r,t[2]=.5,t}setGLViewport(t){const e=this.viewport,r=this.padding;t.setViewport(e[0]-r[3],e[1]-r[2],e[2]+r[1]+r[3],e[3]+r[0]+r[2])}applyProjection(t,e){t!==P&&K(P,t),P[3]=1,jt(P,P,this.projectionMatrix);const r=Math.abs(P[3]);ce(P,P,1/r);const i=this.fullViewport;e[0]=Qe(0,i[0]+i[2],.5+.5*P[0]),e[1]=Qe(0,i[1]+i[3],.5+.5*P[1]),e[2]=.5*(P[2]+1),e[3]=r}unapplyProjection(t,e){const r=this.fullViewport;P[0]=(t[0]/(r[0]+r[2])*2-1)*t[3],P[1]=(t[1]/(r[1]+r[3])*2-1)*t[3],P[2]=(2*t[2]-1)*t[3],P[3]=t[3],this.inverseProjectionMatrix!=null&&(jt(P,P,this.inverseProjectionMatrix),e[0]=P[0],e[1]=P[1],e[2]=P[2])}projectToScreen(t,e){return this.projectToRenderScreen(t,qr),this.renderToScreen(qr,e),e}projectToRenderScreen(t,e){if(P[0]=t[0],P[1]=t[1],P[2]=t[2],P[3]=1,jt(P,P,this.viewProjectionMatrix),P[3]===0)return null;ce(P,P,1/Math.abs(P[3]));const r=this.fullViewport;return"x"in e?(e.x=Qe(0,r[0]+r[2],.5+.5*P[0]),e.y=Qe(0,r[1]+r[3],.5+.5*P[1])):(e[0]=Qe(0,r[0]+r[2],.5+.5*P[0]),e[1]=Qe(0,r[1]+r[3],.5+.5*P[1]),e.length>2&&(e[2]=.5*(P[2]+1))),e}unprojectFromScreen(t,e){return this.unprojectFromRenderScreen(this.screenToRender(t,qr),e)}unprojectFromRenderScreen(t,e){if(ot(ar,this.projectionMatrix,this.viewMatrix),!Vt(ar,ar))return null;const r=this.fullViewport;return P[0]=2*(t[0]-r[0])/r[2]-1,P[1]=2*(t[1]-r[1])/r[3]-1,P[2]=2*t[2]-1,P[3]=1,jt(P,P,ar),P[3]===0?null:(e[0]=P[0]/P[3],e[1]=P[1]/P[3],e[2]=P[2]/P[3],e)}constrainWindowSize(t,e,r,i){const s=t*this.pixelRatio,a=e*this.pixelRatio,o=Math.max(s-r/2,0),n=Math.max(this.fullHeight-a-i/2,0),l=-Math.min(s-r/2,0),c=-Math.min(this.fullHeight-a-i/2,0);return[o,n,r-l- -Math.min(this.fullWidth-s-r/2,0),i-c- -Math.min(a-i/2,0)]}computeUp(t){t===Xt.Global?this._computeUpGlobal():this._computeUpLocal()}screenToRender(t,e){const r=t[0]*this.pixelRatio,i=this.fullHeight-t[1]*this.pixelRatio;return e[0]=r,e[1]=i,e}renderToScreen(t,e){const r=t[0]/this.pixelRatio,i=(this.fullHeight-t[1])/this.pixelRatio;e[0]=r,e[1]=i}_computeUpGlobal(){le(ie,this.center,this.eye);const t=ci(this.center);t<1?(k(this._up,0,0,1),this._markViewDirty(),this.notifyChange("_up")):Math.abs(Pt(ie,this.center))>.9999*ci(ie)*t||(Le(this._up,ie,this.center),Le(this._up,this._up,ie),ne(this._up,this._up),this.notifyChange("_up"),this._markViewDirty())}_computeUpLocal(){Za(ie,this.eye,this.center),Math.abs(ie[2])<=.9999&&(ce(ie,ie,ie[2]),k(this._up,-ie[0],-ie[1],1-ie[2]),ne(this._up,this._up),this.notifyChange("_up"),this._markViewDirty())}_compareAndSetView(t,e,r=""){typeof t[0]=="number"&&isFinite(t[0])&&typeof t[1]=="number"&&isFinite(t[1])&&typeof t[2]=="number"&&isFinite(t[2])?Rt(t,e)||(K(e,t),this._markViewDirty(),r.length&&this.notifyChange(r)):Nr.getLogger("esri.views.3d.webgl-engine.lib.Camera").warn("Camera vector contains invalid number, ignoring value")}_markViewDirty(){this._viewDirty=!0,this._frustumDirty=!0,this._viewProjectionDirty=!0}_recomputeFrustum(){this._frustumDirty&&(Vn(this.viewMatrix,this.projectionMatrix,this._frustum),this._frustumDirty=!1)}_ensureViewClean(){this._viewDirty&&(Ws(this._viewMatrix,this.eye,this.center,this.up),k(this._viewForward,-this._viewMatrix[2],-this._viewMatrix[6],-this._viewMatrix[10]),k(this._viewUp,this._viewMatrix[1],this._viewMatrix[5],this._viewMatrix[9]),k(this._viewRight,this._viewMatrix[0],this._viewMatrix[4],this._viewMatrix[8]),this._viewDirty=!1,this._viewInverseTransposeMatrixDirty=!0)}};v([$()],F.prototype,"_center",void 0),v([$()],F.prototype,"_up",void 0),v([$()],F.prototype,"_viewport",void 0),v([$()],F.prototype,"_padding",void 0),v([$()],F.prototype,"_fov",void 0),v([$()],F.prototype,"_nearFar",void 0),v([$()],F.prototype,"_pixelRatio",void 0),v([$()],F.prototype,"pixelRatio",null),v([$()],F.prototype,"eye",null),v([$()],F.prototype,"center",null),v([$()],F.prototype,"up",null),v([$({readOnly:!0})],F.prototype,"nearFar",null),v([$()],F.prototype,"near",null),v([$()],F.prototype,"far",null),v([$()],F.prototype,"viewport",null),v([$({readOnly:!0})],F.prototype,"screenViewport",null),v([$({readOnly:!0})],F.prototype,"screenPadding",null),v([$()],F.prototype,"x",null),v([$()],F.prototype,"y",null),v([$()],F.prototype,"width",null),v([$()],F.prototype,"height",null),v([$()],F.prototype,"fullWidth",null),v([$()],F.prototype,"fullHeight",null),v([$({readOnly:!0})],F.prototype,"_aspect",null),v([$()],F.prototype,"padding",null),v([$({readOnly:!0})],F.prototype,"projectionMatrix",null),v([$({readOnly:!0})],F.prototype,"inverseProjectionMatrix",null),v([$()],F.prototype,"fov",null),v([$()],F.prototype,"fovX",null),v([$()],F.prototype,"fovY",null),F=pi=v([zr("esri.views.3d.webgl-engine.lib.Camera")],F);const P=Ve(),ar=W(),ie=N(),kr=N(),qr=et();var j;(function(t){t[t.TOP=0]="TOP",t[t.RIGHT=1]="RIGHT",t[t.BOTTOM=2]="BOTTOM",t[t.LEFT=3]="LEFT"})(j||(j={}));let hl=class{constructor(e,r,i,s){this._textureRepository=e,this._techniqueRepository=r,this.materialChanged=i,this.requestRender=s,this._id2glMaterialRef=new Di}dispose(){this._textureRepository.destroy()}acquire(e,r,i){if(this._ownMaterial(e),!e.requiresSlot(r,i))return null;let s=this._id2glMaterialRef.get(i,e.id);if(s==null){const a=e.createGLMaterial({material:e,techniqueRep:this._techniqueRepository,textureRep:this._textureRepository,output:i});s=new ul(a),this._id2glMaterialRef.set(i,e.id,s)}return s.ref(),s.glMaterial}release(e,r){const i=this._id2glMaterialRef.get(r,e.id);i!=null&&(i.unref(),i.referenced||(je(i.glMaterial),this._id2glMaterialRef.delete(r,e.id)))}_ownMaterial(e){e.repository!=null&&e.repository!==this&&Nr.getLogger("esri.views.3d.webgl-engine.lib.GLMaterialRepository").error("Material is already owned by a different material repository"),e.repository=this}},ul=class{constructor(e){this.glMaterial=e,this._refCnt=0}ref(){++this._refCnt}unref(){--this._refCnt,pe(this._refCnt>=0)}get referenced(){return this._refCnt>0}};var lt,Jt;(function(t){t[t.Draped=0]="Draped",t[t.Screen=1]="Screen",t[t.World=2]="World",t[t.COUNT=3]="COUNT"})(lt||(lt={})),function(t){t[t.Center=0]="Center",t[t.Tip=1]="Tip",t[t.COUNT=2]="COUNT"}(Jt||(Jt={}));let te=class extends xi{constructor(){super(...arguments),this.output=E.Color,this.transparencyPassType=ge.NONE,this.occluder=!1,this.hasSlicePlane=!1,this.writeDepth=!1,this.space=lt.Screen,this.hideOnShortSegments=!1,this.hasCap=!1,this.anchor=Jt.Center,this.hasTip=!1,this.vvSize=!1,this.vvColor=!1,this.vvOpacity=!1,this.hasOccludees=!1,this.hasMultipassTerrain=!1,this.cullAboveGround=!1}get draped(){return this.space===lt.Draped}};v([O({count:E.COUNT})],te.prototype,"output",void 0),v([O({count:ge.COUNT})],te.prototype,"transparencyPassType",void 0),v([O()],te.prototype,"occluder",void 0),v([O()],te.prototype,"hasSlicePlane",void 0),v([O()],te.prototype,"writeDepth",void 0),v([O({count:lt.COUNT})],te.prototype,"space",void 0),v([O()],te.prototype,"hideOnShortSegments",void 0),v([O()],te.prototype,"hasCap",void 0),v([O({count:Jt.COUNT})],te.prototype,"anchor",void 0),v([O()],te.prototype,"hasTip",void 0),v([O()],te.prototype,"vvSize",void 0),v([O()],te.prototype,"vvColor",void 0),v([O()],te.prototype,"vvOpacity",void 0),v([O()],te.prototype,"hasOccludees",void 0),v([O()],te.prototype,"hasMultipassTerrain",void 0),v([O()],te.prototype,"cullAboveGround",void 0),v([O({constValue:!0})],te.prototype,"hasVvInstancing",void 0),v([O({constValue:!0})],te.prototype,"hasSliceTranslatedView",void 0);const as=8;function pl(t,e){const r=t.vertex;r.uniforms.add(new Y("intrinsicWidth",i=>i.width)),e.vvSize?(t.attributes.add(p.SIZEFEATUREATTRIBUTE,"float"),r.uniforms.add(new Ct("vvSizeMinSize",i=>i.vvSize.minSize),new Ct("vvSizeMaxSize",i=>i.vvSize.maxSize),new Ct("vvSizeOffset",i=>i.vvSize.offset),new Ct("vvSizeFactor",i=>i.vvSize.factor)),r.code.add(m`float getSize() {
return intrinsicWidth * clamp(vvSizeOffset + sizeFeatureAttribute * vvSizeFactor, vvSizeMinSize, vvSizeMaxSize).x;
}`)):(t.attributes.add(p.SIZE,"float"),r.code.add(m`float getSize(){
return intrinsicWidth * size;
}`)),e.vvOpacity?(t.attributes.add(p.OPACITYFEATUREATTRIBUTE,"float"),r.constants.add("vvOpacityNumber","int",8),r.uniforms.add(new qi("vvOpacityValues",i=>i.vvOpacity.values,as),new qi("vvOpacityOpacities",i=>i.vvOpacity.opacityValues,as)),r.code.add(m`float interpolateOpacity( float value ){
if (value <= vvOpacityValues[0]) {
return vvOpacityOpacities[0];
}
for (int i = 1; i < vvOpacityNumber; ++i) {
if (vvOpacityValues[i] >= value) {
float f = (value - vvOpacityValues[i-1]) / (vvOpacityValues[i] - vvOpacityValues[i-1]);
return mix(vvOpacityOpacities[i-1], vvOpacityOpacities[i], f);
}
}
return vvOpacityOpacities[vvOpacityNumber - 1];
}
vec4 applyOpacity( vec4 color ){
return vec4(color.xyz, interpolateOpacity(opacityFeatureAttribute));
}`)):r.code.add(m`vec4 applyOpacity( vec4 color ){
return color;
}`),e.vvColor?(t.include(Xo,e),t.attributes.add(p.COLORFEATUREATTRIBUTE,"float"),r.code.add(m`vec4 getColor(){
return applyOpacity(interpolateVVColor(colorFeatureAttribute));
}`)):(t.attributes.add(p.COLOR,"vec4"),r.code.add(m`vec4 getColor(){
return applyOpacity(color);
}`))}function ma(t){return t.pattern.map(e=>Math.round(e*t.pixelRatio))}function fl(t){if(t==null)return 1;const e=ma(t);return Math.floor(e.reduce((r,i)=>r+i))}function ml(t){return ma(t).reduce((e,r)=>Math.max(e,r))}const gl=2;function vl(t){return t==null?Ja:t.length===4?t:qt(_l,t[0],t[1],t[2],1)}const _l=Ve();function yl(t,e){t.constants.add("stippleAlphaColorDiscard","float",.001),t.constants.add("stippleAlphaHighlightDiscard","float",.5),e.stippleEnabled?wl(t,e):Tl(t)}function wl(t,e){const r=!(e.draped&&e.stipplePreferContinuous),{vertex:i,fragment:s}=t;s.include(Qo),e.draped||(Js(i,e),i.uniforms.add(new Y("worldToScreenPerDistanceRatio",(a,o)=>1/o.camera.perScreenPixelRatio)),i.code.add(m`float computeWorldToScreenRatio(vec3 segmentCenter) {
float segmentDistanceToCamera = length(segmentCenter - cameraPosition);
return worldToScreenPerDistanceRatio / segmentDistanceToCamera;
}`)),t.varyings.add("vStippleDistance","float"),e.stippleRequiresClamp&&t.varyings.add("vStippleDistanceLimits","vec2"),e.stippleRequiresStretchMeasure&&t.varyings.add("vStipplePatternStretch","float"),i.code.add(m`
    float discretizeWorldToScreenRatio(float worldToScreenRatio) {
      float step = ${xl};

      float discreteWorldToScreenRatio = log(worldToScreenRatio);
      discreteWorldToScreenRatio = ceil(discreteWorldToScreenRatio / step) * step;
      discreteWorldToScreenRatio = exp(discreteWorldToScreenRatio);
      return discreteWorldToScreenRatio;
    }
  `),i.code.add(m`vec2 computeStippleDistanceLimits(float startPseudoScreen, float segmentLengthPseudoScreen, float segmentLengthScreen, float patternLength) {`),i.code.add(m`
    if (segmentLengthPseudoScreen >= ${r?"patternLength":"1e4"}) {
  `),Ri(i,e),i.code.add(m`
        // Round the screen length to get an integer number of pattern repetitions (minimum 1).
        float repetitions = segmentLengthScreen / (patternLength * pixelRatio);
        float flooredRepetitions = max(1.0, floor(repetitions + 0.5));
        float segmentLengthScreenRounded = flooredRepetitions * patternLength;

        ${e.stippleRequiresStretchMeasure?m`
              float stretch = repetitions / flooredRepetitions;

              // We need to impose a lower bound on the stretch factor to prevent the dots from merging together when there is only 1 repetition.
              // 0.75 is the lowest possible stretch value for flooredRepetitions > 1, so it makes sense as lower bound.
              vStipplePatternStretch = max(0.75, stretch);`:""}

        return vec2(0.0, segmentLengthScreenRounded);
      }
      return vec2(startPseudoScreen, startPseudoScreen + segmentLengthPseudoScreen);
    }
  `),s.constants.add("stippleTexturePadding","float",gl),s.uniforms.add(new nt("stipplePatternTexture",a=>a.stippleTexture),new Y("stipplePatternSDFNormalizer",a=>Sl(a.stipplePattern)),new Y("stipplePatternPixelSizeInv",a=>1/ga(a))),s.code.add(m`float padStippleTexture(float u) {
float paddedTextureSize = float(textureSize(stipplePatternTexture, 0).x);
float unpaddedTextureSize = paddedTextureSize - stippleTexturePadding;
return (u * unpaddedTextureSize + stippleTexturePadding * 0.5) / paddedTextureSize;
}`),s.code.add(m`
    float getStippleSDF(out bool isClamped) {
      ${e.stippleRequiresClamp?m`
          float stippleDistanceClamped = clamp(vStippleDistance, vStippleDistanceLimits.x, vStippleDistanceLimits.y);
          vec2 aaCorrectedLimits = vStippleDistanceLimits + vec2(1.0, -1.0) / gl_FragCoord.w;
          isClamped = vStippleDistance < aaCorrectedLimits.x || vStippleDistance > aaCorrectedLimits.y;`:m`
          float stippleDistanceClamped = vStippleDistance;
          isClamped = false;`}

      float u = stippleDistanceClamped * gl_FragCoord.w * stipplePatternPixelSizeInv;
      ${e.stippleScaleWithLineWidth?m`u *= vLineSizeInv;`:""}
      u = padStippleTexture(fract(u));

      float encodedSDF = rgba2float(texture(stipplePatternTexture, vec2(u, 0.5)));
      float sdf = (encodedSDF * 2.0 - 1.0) * stipplePatternSDFNormalizer;

      ${e.stippleRequiresStretchMeasure?m`return (sdf - 0.5) * vStipplePatternStretch + 0.5;`:m`return sdf;`}
    }

    float getStippleSDF() {
      bool ignored;
      return getStippleSDF(ignored);
    }

    float getStippleAlpha() {
      bool isClamped;
      float stippleSDF = getStippleSDF(isClamped);

      float antiAliasedResult = ${e.stippleScaleWithLineWidth?m`clamp(stippleSDF * vLineWidth + 0.5, 0.0, 1.0);`:m`clamp(stippleSDF + 0.5, 0.0, 1.0);`}

      return isClamped ? floor(antiAliasedResult + 0.5) : antiAliasedResult;
    }
  `),e.stippleOffColorEnabled?(s.uniforms.add(new at("stippleOffColor",a=>vl(a.stippleOffColor))),s.code.add(m`#define discardByStippleAlpha(stippleAlpha, threshold) {}
#define blendStipple(color, stippleAlpha) mix(color, stippleOffColor, stippleAlpha)`)):s.code.add(m`#define discardByStippleAlpha(stippleAlpha, threshold) if (stippleAlpha < threshold) { discard; }
#define blendStipple(color, stippleAlpha) vec4(color.rgb, color.a * stippleAlpha)`)}function Tl(t){t.fragment.code.add(m`float getStippleAlpha() { return 1.0; }
#define discardByStippleAlpha(_stippleAlpha_, _threshold_) {}
#define blendStipple(color, _stippleAlpha_) color`)}function Sl(t){return t?(Math.floor(.5*(ml(t)-1))+.5)/t.pixelRatio:1}function ga(t){const e=t.stipplePattern;return e?fl(t.stipplePattern)/e.pixelRatio:1}const xl=m.float(.4),va=64,Rl=va/2,Cl=Rl/5,bl=va/Cl,lh=.25;function Ol(t,e){const{vertex:r,constants:i}=t;i.add("markerSizePerLineWidth","float",bl),Ri(r,e),r.uniforms.get("markerScale")==null&&r.constants.add("markerScale","float",1),r.code.add(m`float getLineWidth() {
return max(getSize(), 1.0) * pixelRatio;
}
float getScreenMarkerSize() {
return markerSizePerLineWidth * markerScale * getLineWidth();
}`),e.space===lt.World&&(r.constants.add("maxSegmentLengthFraction","float",.45),r.uniforms.add(new Y("perRenderPixelRatio",(s,a)=>a.camera.perRenderPixelRatio)),r.code.add(m`bool areWorldMarkersHidden(vec4 pos, vec4 other) {
vec3 midPoint = mix(pos.xyz, other.xyz, 0.5);
float distanceToCamera = length(midPoint);
float screenToWorldRatio = perRenderPixelRatio * distanceToCamera * 0.5;
float worldMarkerSize = getScreenMarkerSize() * screenToWorldRatio;
float segmentLen = length(pos.xyz - other.xyz);
return worldMarkerSize > maxSegmentLengthFraction * segmentLen;
}
float getWorldMarkerSize(vec4 pos) {
float distanceToCamera = length(pos.xyz);
float screenToWorldRatio = perRenderPixelRatio * distanceToCamera * 0.5;
return getScreenMarkerSize() * screenToWorldRatio;
}`))}var ct;(function(t){t[t.BUTT=0]="BUTT",t[t.SQUARE=1]="SQUARE",t[t.ROUND=2]="ROUND",t[t.COUNT=3]="COUNT"})(ct||(ct={}));let V=class extends xi{constructor(){super(...arguments),this.output=E.Color,this.capType=ct.BUTT,this.transparencyPassType=ge.NONE,this.occluder=!1,this.hasSlicePlane=!1,this.hasPolygonOffset=!1,this.writeDepth=!1,this.draped=!1,this.stippleEnabled=!1,this.stippleOffColorEnabled=!1,this.stippleScaleWithLineWidth=!1,this.stipplePreferContinuous=!0,this.roundJoins=!1,this.applyMarkerOffset=!1,this.vvSize=!1,this.vvColor=!1,this.vvOpacity=!1,this.falloffEnabled=!1,this.innerColorEnabled=!1,this.hasOccludees=!1,this.hasMultipassTerrain=!1,this.cullAboveGround=!1,this.wireframe=!1,this.objectAndLayerIdColorInstanced=!1}};v([O({count:E.COUNT})],V.prototype,"output",void 0),v([O({count:ct.COUNT})],V.prototype,"capType",void 0),v([O({count:ge.COUNT})],V.prototype,"transparencyPassType",void 0),v([O()],V.prototype,"occluder",void 0),v([O()],V.prototype,"hasSlicePlane",void 0),v([O()],V.prototype,"hasPolygonOffset",void 0),v([O()],V.prototype,"writeDepth",void 0),v([O()],V.prototype,"draped",void 0),v([O()],V.prototype,"stippleEnabled",void 0),v([O()],V.prototype,"stippleOffColorEnabled",void 0),v([O()],V.prototype,"stippleScaleWithLineWidth",void 0),v([O()],V.prototype,"stipplePreferContinuous",void 0),v([O()],V.prototype,"roundJoins",void 0),v([O()],V.prototype,"applyMarkerOffset",void 0),v([O()],V.prototype,"vvSize",void 0),v([O()],V.prototype,"vvColor",void 0),v([O()],V.prototype,"vvOpacity",void 0),v([O()],V.prototype,"falloffEnabled",void 0),v([O()],V.prototype,"innerColorEnabled",void 0),v([O()],V.prototype,"hasOccludees",void 0),v([O()],V.prototype,"hasMultipassTerrain",void 0),v([O()],V.prototype,"cullAboveGround",void 0),v([O()],V.prototype,"wireframe",void 0),v([O({constValue:!0})],V.prototype,"stippleRequiresClamp",void 0),v([O({constValue:!0})],V.prototype,"stippleRequiresStretchMeasure",void 0),v([O({constValue:!0})],V.prototype,"hasVvInstancing",void 0),v([O({constValue:!0})],V.prototype,"hasSliceTranslatedView",void 0),v([O()],V.prototype,"objectAndLayerIdColorInstanced",void 0);const Ir=1;function Dl(t){const e=new Si,{vertex:r,fragment:i}=e,s=t.hasMultipassTerrain&&(t.output===E.Color||t.output===E.Alpha);e.include(Ko),e.include(pl,t),e.include(yl,t);const a=t.applyMarkerOffset&&!t.draped;a&&(r.uniforms.add(new Y("markerScale",h=>h.markerScale)),e.include(Ol,{space:lt.World,draped:!1})),t.output===E.Depth&&e.include(en,t),e.include(Ys,t),Xs(r,t),r.uniforms.add(new $t("inverseProjectionMatrix",(h,g)=>g.camera.inverseProjectionMatrix),new jr("nearFar",(h,g)=>g.camera.nearFar),new Y("miterLimit",h=>h.join!=="miter"?0:h.miterLimit),new at("viewport",(h,g)=>g.camera.fullViewport)),r.constants.add("LARGE_HALF_FLOAT","float",65500),e.attributes.add(p.POSITION,"vec3"),e.attributes.add(p.SUBDIVISIONFACTOR,"float"),e.attributes.add(p.UV0,"vec2"),e.attributes.add(p.AUXPOS1,"vec3"),e.attributes.add(p.AUXPOS2,"vec3"),e.varyings.add("vColor","vec4"),e.varyings.add("vpos","vec3"),tn(e),s&&e.varyings.add("depth","float");const o=t.stippleEnabled&&t.stippleScaleWithLineWidth;o&&e.varyings.add("vLineSizeInv","float");const n=t.capType===ct.ROUND,l=o||n;l&&e.varyings.add("vLineWidth","float");const c=t.innerColorEnabled||n;c&&e.varyings.add("vLineDistance","float");const d=t.stippleEnabled&&n,u=t.falloffEnabled||d;u&&e.varyings.add("vLineDistanceNorm","float"),n&&(e.varyings.add("vSegmentSDF","float"),e.varyings.add("vReverseSegmentSDF","float")),r.code.add(m`#define PERPENDICULAR(v) vec2(v.y, -v.x);
float interp(float ncp, vec4 a, vec4 b) {
return (-ncp - a.z) / (b.z - a.z);
}
vec2 rotate(vec2 v, float a) {
float s = sin(a);
float c = cos(a);
mat2 m = mat2(c, -s, s, c);
return m * v;
}`),r.code.add(m`vec4 projectAndScale(vec4 pos) {
vec4 posNdc = proj * pos;
posNdc.xy *= viewport.zw / posNdc.w;
return posNdc;
}`),rn(e),r.code.add(m`
    void clipAndTransform(inout vec4 pos, inout vec4 prev, inout vec4 next, in bool isStartVertex) {
      float vnp = nearFar[0] * 0.99;

      if(pos.z > -nearFar[0]) {
        //current pos behind ncp --> we need to clip
        if (!isStartVertex) {
          if(prev.z < -nearFar[0]) {
            //previous in front of ncp
            pos = mix(prev, pos, interp(vnp, prev, pos));
            next = pos;
          } else {
            pos = vec4(0.0, 0.0, 0.0, 1.0);
          }
        } else {
          if(next.z < -nearFar[0]) {
            //next in front of ncp
            pos = mix(pos, next, interp(vnp, pos, next));
            prev = pos;
          } else {
            pos = vec4(0.0, 0.0, 0.0, 1.0);
          }
        }
      } else {
        //current position visible
        if (prev.z > -nearFar[0]) {
          //previous behind ncp
          prev = mix(pos, prev, interp(vnp, pos, prev));
        }
        if (next.z > -nearFar[0]) {
          //next behind ncp
          next = mix(next, pos, interp(vnp, next, pos));
        }
      }

      ${s?"depth = pos.z;":""}
      linearDepth = calculateLinearDepth(nearFar,pos.z);

      pos = projectAndScale(pos);
      next = projectAndScale(next);
      prev = projectAndScale(prev);
    }
  `),Ri(r,t),r.code.add(m`
  void main(void) {
    // unpack values from uv0.y
    bool isStartVertex = abs(abs(uv0.y)-3.0) == 1.0;

    float coverage = 1.0;

    // Check for special value of uv0.y which is used by the Renderer when graphics
    // are removed before the VBO is recompacted. If this is the case, then we just
    // project outside of clip space.
    if (uv0.y == 0.0) {
      // Project out of clip space
      gl_Position = vec4(1e038, 1e038, 1e038, 1.0);
    }
    else {
      bool isJoin = abs(uv0.y) < 3.0;

      float lineSize = getSize();
      float lineWidth = lineSize * pixelRatio;

      ${l?m`vLineWidth = lineWidth;`:""}
      ${o?m`vLineSizeInv = 1.0 / lineSize;`:""}

      // convert sub-pixel coverage to alpha
      if (lineWidth < 1.0) {
        coverage = lineWidth;
        lineWidth = 1.0;
      }else{
        // Ribbon lines cannot properly render non-integer sizes. Round width to integer size if
        // larger than one for better quality. Note that we do render < 1 pixels more or less correctly
        // so we only really care to round anything larger than 1.
        lineWidth = floor(lineWidth + 0.5);
      }

      vec4 pos  = view * vec4(position.xyz, 1.0);
      vec4 prev = view * vec4(auxpos1.xyz, 1.0);
      vec4 next = view * vec4(auxpos2.xyz, 1.0);
  `),a&&r.code.add(m`vec4 other = isStartVertex ? next : prev;
bool markersHidden = areWorldMarkersHidden(pos, other);
if(!isJoin && !markersHidden) {
pos.xyz += normalize(other.xyz - pos.xyz) * getWorldMarkerSize(pos) * 0.5;
}`),r.code.add(m`clipAndTransform(pos, prev, next, isStartVertex);
vec2 left = (pos.xy - prev.xy);
vec2 right = (next.xy - pos.xy);
float leftLen = length(left);
float rightLen = length(right);`),(t.stippleEnabled||n)&&r.code.add(m`
      float isEndVertex = float(!isStartVertex);
      vec2 segmentOrigin = mix(pos.xy, prev.xy, isEndVertex);
      vec2 segment = mix(right, left, isEndVertex);
      ${n?m`vec2 segmentEnd = mix(next.xy, pos.xy, isEndVertex);`:""}
    `),r.code.add(m`left = (leftLen > 0.001) ? left/leftLen : vec2(0.0, 0.0);
right = (rightLen > 0.001) ? right/rightLen : vec2(0.0, 0.0);
vec2 capDisplacementDir = vec2(0, 0);
vec2 joinDisplacementDir = vec2(0, 0);
float displacementLen = lineWidth;
if (isJoin) {
bool isOutside = (left.x * right.y - left.y * right.x) * uv0.y > 0.0;
joinDisplacementDir = normalize(left + right);
joinDisplacementDir = PERPENDICULAR(joinDisplacementDir);
if (leftLen > 0.001 && rightLen > 0.001) {
float nDotSeg = dot(joinDisplacementDir, left);
displacementLen /= length(nDotSeg * left - joinDisplacementDir);
if (!isOutside) {
displacementLen = min(displacementLen, min(leftLen, rightLen)/abs(nDotSeg));
}
}
if (isOutside && (displacementLen > miterLimit * lineWidth)) {`),t.roundJoins?r.code.add(m`
        vec2 startDir = leftLen < 0.001 ? right : left;
        startDir = PERPENDICULAR(startDir);

        vec2 endDir = rightLen < 0.001 ? left : right;
        endDir = PERPENDICULAR(endDir);

        float factor = ${t.stippleEnabled?m`min(1.0, subdivisionFactor * ${m.float((Ir+2)/(Ir+1))})`:m`subdivisionFactor`};

        float rotationAngle = acos(clamp(dot(startDir, endDir), -1.0, 1.0));
        joinDisplacementDir = rotate(startDir, -sign(uv0.y) * factor * rotationAngle);
      `):r.code.add(m`if (leftLen < 0.001) {
joinDisplacementDir = right;
}
else if (rightLen < 0.001) {
joinDisplacementDir = left;
}
else {
joinDisplacementDir = (isStartVertex || subdivisionFactor > 0.0) ? right : left;
}
joinDisplacementDir = PERPENDICULAR(joinDisplacementDir);`);const f=t.capType!==ct.BUTT;return r.code.add(m`
        displacementLen = lineWidth;
      }
    } else {
      // CAP handling ---------------------------------------------------
      joinDisplacementDir = isStartVertex ? right : left;
      joinDisplacementDir = PERPENDICULAR(joinDisplacementDir);

      ${f?m`capDisplacementDir = isStartVertex ? -right : left;`:""}
    }
  `),r.code.add(m`
    // Displacement (in pixels) caused by join/or cap
    vec2 dpos = joinDisplacementDir * sign(uv0.y) * displacementLen + capDisplacementDir * displacementLen;

    ${u||c?m`float lineDistNorm = sign(uv0.y) * pos.w;`:""}

    ${c?m`vLineDistance = lineWidth * lineDistNorm;`:""}
    ${u?m`vLineDistanceNorm = lineDistNorm;`:""}

    pos.xy += dpos;
  `),n&&r.code.add(m`vec2 segmentDir = normalize(segment);
vSegmentSDF = (isJoin && isStartVertex) ? LARGE_HALF_FLOAT : (dot(pos.xy - segmentOrigin, segmentDir) * pos.w) ;
vReverseSegmentSDF = (isJoin && !isStartVertex) ? LARGE_HALF_FLOAT : (dot(pos.xy - segmentEnd, -segmentDir) * pos.w);`),t.stippleEnabled&&(t.draped?r.uniforms.add(new Y("worldToScreenRatio",(h,g)=>1/g.screenToPCSRatio)):r.code.add(m`vec3 segmentCenter = mix((auxpos2 + position) * 0.5, (position + auxpos1) * 0.5, isEndVertex);
float worldToScreenRatio = computeWorldToScreenRatio(segmentCenter);`),r.code.add(m`float segmentLengthScreenDouble = length(segment);
float segmentLengthScreen = segmentLengthScreenDouble * 0.5;
float discreteWorldToScreenRatio = discretizeWorldToScreenRatio(worldToScreenRatio);
float segmentLengthRender = length(mix(auxpos2 - position, position - auxpos1, isEndVertex));
vStipplePatternStretch = worldToScreenRatio / discreteWorldToScreenRatio;`),t.draped?r.code.add(m`float segmentLengthPseudoScreen = segmentLengthScreen / pixelRatio * discreteWorldToScreenRatio / worldToScreenRatio;
float startPseudoScreen = uv0.x * discreteWorldToScreenRatio - mix(0.0, segmentLengthPseudoScreen, isEndVertex);`):r.code.add(m`float startPseudoScreen = mix(uv0.x, uv0.x - segmentLengthRender, isEndVertex) * discreteWorldToScreenRatio;
float segmentLengthPseudoScreen = segmentLengthRender * discreteWorldToScreenRatio;`),r.uniforms.add(new Y("stipplePatternPixelSize",h=>ga(h))),r.code.add(m`
      float patternLength = ${t.stippleScaleWithLineWidth?"lineSize * ":""} stipplePatternPixelSize;

      // Compute the coordinates at both start and end of the line segment, because we need both to clamp to in the fragment shader
      vStippleDistanceLimits = computeStippleDistanceLimits(startPseudoScreen, segmentLengthPseudoScreen, segmentLengthScreen, patternLength);

      vStippleDistance = mix(vStippleDistanceLimits.x, vStippleDistanceLimits.y, isEndVertex);

      // Adjust the coordinate to the displaced position (the pattern is shortened/overextended on the in/outside of joins)
      if (segmentLengthScreenDouble >= 0.001) {
        // Project the actual vertex position onto the line segment. Note that the resulting factor is within [0..1] at the
        // original vertex positions, and slightly outside of that range at the displaced positions
        vec2 stippleDisplacement = pos.xy - segmentOrigin;
        float stippleDisplacementFactor = dot(segment, stippleDisplacement) / (segmentLengthScreenDouble * segmentLengthScreenDouble);

        // Apply this offset to the actual vertex coordinate (can be screen or pseudo-screen space)
        vStippleDistance += (stippleDisplacementFactor - isEndVertex) * (vStippleDistanceLimits.y - vStippleDistanceLimits.x);
      }

      // Cancel out perspective correct interpolation because we want this length the really represent the screen distance
      vStippleDistanceLimits *= pos.w;
      vStippleDistance *= pos.w;

      // Disable stipple distance limits on caps
      vStippleDistanceLimits = isJoin ?
                                 vStippleDistanceLimits :
                                 isStartVertex ?
                                  vec2(-1e038, vStippleDistanceLimits.y) :
                                  vec2(vStippleDistanceLimits.x, 1e038);
    `)),r.code.add(m`
      // Convert back into NDC
      pos.xy = (pos.xy / viewport.zw) * pos.w;

      vColor = getColor();
      vColor.a *= coverage;

      ${t.wireframe&&!t.draped?"pos.z -= 0.001 * pos.w;":""}

      // transform final position to camera space for slicing
      vpos = (inverseProjectionMatrix * pos).xyz;
      gl_Position = pos;
      forwardObjectAndLayerIdColor();
    }
  }
  `),s&&e.include(Qs,t),e.include(xt,t),i.include(Ks),i.code.add(m`
  void main() {
    discardBySlice(vpos);
    ${s?"terrainDepthTest(gl_FragCoord, depth);":""}
  `),t.wireframe?i.code.add(m`vec4 finalColor = vec4(1.0, 0.0, 1.0, 1.0);`):(n&&i.code.add(m`
      float sdf = min(vSegmentSDF, vReverseSegmentSDF);
      vec2 fragmentPosition = vec2(
        min(sdf, 0.0),
        vLineDistance
      ) * gl_FragCoord.w;

      float fragmentRadius = length(fragmentPosition);
      float fragmentCapSDF = (fragmentRadius - vLineWidth) * 0.5; // Divide by 2 to transform from double pixel scale
      float capCoverage = clamp(0.5 - fragmentCapSDF, 0.0, 1.0);

      if (capCoverage < ${m.float(Be)}) {
        discard;
      }
    `),d?i.code.add(m`
      vec2 stipplePosition = vec2(
        min(getStippleSDF() * 2.0 - 1.0, 0.0),
        vLineDistanceNorm * gl_FragCoord.w
      );
      float stippleRadius = length(stipplePosition * vLineWidth);
      float stippleCapSDF = (stippleRadius - vLineWidth) * 0.5; // Divide by 2 to transform from double pixel scale
      float stippleCoverage = clamp(0.5 - stippleCapSDF, 0.0, 1.0);
      float stippleAlpha = step(${m.float(Be)}, stippleCoverage);
      `):i.code.add(m`float stippleAlpha = getStippleAlpha();`),i.uniforms.add(new at("intrinsicColor",h=>h.color)),t.output!==E.ObjectAndLayerIdColor&&i.code.add(m`discardByStippleAlpha(stippleAlpha, stippleAlphaColorDiscard);`),i.code.add(m`vec4 color = intrinsicColor * vColor;`),t.innerColorEnabled&&(i.uniforms.add(new at("innerColor",h=>h.innerColor??h.color),new Y("innerWidth",(h,g)=>h.innerWidth*g.camera.pixelRatio)),i.code.add(m`float distToInner = abs(vLineDistance * gl_FragCoord.w) - innerWidth;
float innerAA = clamp(0.5 - distToInner, 0.0, 1.0);
float innerAlpha = innerColor.a + color.a * (1.0 - innerColor.a);
color = mix(color, vec4(innerColor.rgb, innerAlpha), innerAA);`)),i.code.add(m`vec4 finalColor = blendStipple(color, stippleAlpha);`),t.falloffEnabled&&(i.uniforms.add(new Y("falloff",h=>h.falloff)),i.code.add(m`finalColor.a *= pow(max(0.0, 1.0 - abs(vLineDistanceNorm * gl_FragCoord.w)), falloff);`))),i.code.add(m`
    ${t.output===E.ObjectAndLayerIdColor?m`finalColor.a = 1.0;`:""}

    if (finalColor.a < ${m.float(Be)}) {
      discard;
    }

    ${t.output===E.Alpha?m`fragColor = vec4(finalColor.a);`:""}
    ${t.output===E.Color?m`fragColor = highlightSlice(finalColor, vpos);`:""}
    ${t.output===E.Color&&t.transparencyPassType===ge.Color?"fragColor = premultiplyAlpha(fragColor);":""}
    ${t.output===E.Highlight?m`fragColor = vec4(1.0);`:""}
    ${t.output===E.Depth?m`outputDepth(linearDepth);`:""}
    ${t.output===E.ObjectAndLayerIdColor?m`outputObjectAndLayerIdColor();`:""}
  }
  `),e}const Al=Object.freeze(Object.defineProperty({__proto__:null,RIBBONLINE_NUM_ROUND_JOIN_SUBDIVISIONS:Ir,build:Dl},Symbol.toStringTag,{value:"Module"})),_a=new Map([[p.POSITION,0],[p.SUBDIVISIONFACTOR,1],[p.UV0,2],[p.AUXPOS1,3],[p.AUXPOS2,4],[p.COLOR,5],[p.COLORFEATUREATTRIBUTE,5],[p.SIZE,6],[p.SIZEFEATUREATTRIBUTE,6],[p.OPACITYFEATUREATTRIBUTE,7],[p.OBJECTANDLAYERIDCOLOR,8]]);let ya=class wa extends Ci{initializeProgram(e){return new bi(e.rctx,wa.shader.get().build(this.configuration),_a)}_makePipelineState(e,r){const i=this.configuration,s=e===ge.NONE,a=e===ge.FrontFace;return tt({blending:i.output===E.Color||i.output===E.Alpha?s?vr:la(e):null,depthTest:{func:ca(e)},depthWrite:s?i.writeDepth?da:null:ha(e),colorWrite:Ot,stencilWrite:i.hasOccludees?Zi:null,stencilTest:i.hasOccludees?r?Ji:sn:null,polygonOffset:s||a?i.hasPolygonOffset?os:null:Wn})}initializePipeline(){const e=this.configuration;if(e.occluder){const r=e.hasPolygonOffset?os:null;this._occluderPipelineTransparent=tt({blending:vr,polygonOffset:r,depthTest:Yi,depthWrite:null,colorWrite:Ot,stencilWrite:null,stencilTest:an}),this._occluderPipelineOpaque=tt({blending:vr,polygonOffset:r,depthTest:Yi,depthWrite:null,colorWrite:Ot,stencilWrite:on,stencilTest:nn}),this._occluderPipelineMaskWrite=tt({blending:null,polygonOffset:r,depthTest:ln,depthWrite:null,colorWrite:null,stencilWrite:Zi,stencilTest:Ji})}return this._occludeePipelineState=this._makePipelineState(this.configuration.transparencyPassType,!0),this._makePipelineState(this.configuration.transparencyPassType,!1)}get primitiveType(){return this.configuration.wireframe?hi.LINES:hi.TRIANGLE_STRIP}getPipelineState(e,r){return r?this._occludeePipelineState:this.configuration.occluder?e===J.TRANSPARENT_OCCLUDER_MATERIAL?this._occluderPipelineTransparent:e===J.OCCLUDER_MATERIAL?this._occluderPipelineOpaque:this._occluderPipelineMaskWrite:super.getPipelineState(e,r)}};ya.shader=new Oi(Al,()=>_i(()=>import("./RibbonLine.glsl-cdfb69e7.js"),["./RibbonLine.glsl-cdfb69e7.js","./FloatArray-73ba570e.js","./index-4457faad.js","..\\index-add6cbc1.css","./requestImageUtils-a82830fa.js","./basicInterfaces-bb952591.js","./enums-b14466b3.js","./Texture-53149a07.js","./Indices-836a5a9a.js","./triangle-6e9991e3.js","./doublePrecisionUtils-e3c3d0d8.js","./BufferView-eb3bc1bb.js","./VertexElementDescriptor-2925c6af.js","./VertexArrayObject-79e51137.js","./OrderIndependentTransparency-2a607a9a.js","./floatRGBA-45eb4edf.js","./DoubleArray-28266794.js","./hydratedFeatures-1f5e8f4b.js","./triangulationUtils-2852bf6d.js","./earcut-938ec344.js","./deduplicate-34be5e74.js","./NestedMap-1b5db22e.js","./Octree-30686065.js","./InterleavedLayout-2de7b1c4.js","./types-1305598a.js","./glUtil-0b7ee6ea.js"],import.meta.url));const os={factor:0,units:-4};var me;(function(t){t[t.LEFT_JOIN_START=-2]="LEFT_JOIN_START",t[t.LEFT_JOIN_END=-1]="LEFT_JOIN_END",t[t.LEFT_CAP_START=-4]="LEFT_CAP_START",t[t.LEFT_CAP_END=-5]="LEFT_CAP_END",t[t.RIGHT_JOIN_START=2]="RIGHT_JOIN_START",t[t.RIGHT_JOIN_END=1]="RIGHT_JOIN_END",t[t.RIGHT_CAP_START=4]="RIGHT_CAP_START",t[t.RIGHT_CAP_END=5]="RIGHT_CAP_END"})(me||(me={}));let El=class extends Bs{constructor(e){super(e,new Pl),this._configuration=new V,this._vertexAttributeLocations=_a}isClosed(e,r){return Sa(this.parameters,e,r)}getConfiguration(e,r){this._configuration.output=e,this._configuration.draped=r.slot===J.DRAPED_MATERIAL;const i=this.parameters.stipplePattern!=null&&e!==E.Highlight;return this._configuration.stippleEnabled=i,this._configuration.stippleOffColorEnabled=i&&this.parameters.stippleOffColor!=null,this._configuration.stippleScaleWithLineWidth=i&&this.parameters.stippleScaleWithLineWidth,this._configuration.stipplePreferContinuous=i&&this.parameters.stipplePreferContinuous,this._configuration.hasSlicePlane=this.parameters.hasSlicePlane,this._configuration.hasOccludees=this.parameters.hasOccludees,this._configuration.roundJoins=this.parameters.join==="round",this._configuration.capType=this.parameters.cap,this._configuration.applyMarkerOffset=this.parameters.markerParameters!=null&&Ml(this.parameters.markerParameters),this._configuration.hasPolygonOffset=this.parameters.hasPolygonOffset,this._configuration.writeDepth=this.parameters.writeDepth,this._configuration.vvSize=!!this.parameters.vvSize,this._configuration.vvColor=!!this.parameters.vvColor,this._configuration.vvOpacity=!!this.parameters.vvOpacity,this._configuration.innerColorEnabled=this.parameters.innerWidth>0&&this.parameters.innerColor!=null,this._configuration.falloffEnabled=this.parameters.falloff>0,this._configuration.occluder=this.parameters.renderOccluded===st.OccludeAndTransparentStencil,this._configuration.transparencyPassType=r.transparencyPassType,this._configuration.hasMultipassTerrain=r.multipassTerrain.enabled,this._configuration.cullAboveGround=r.multipassTerrain.cullAboveGround,this._configuration.wireframe=this.parameters.wireframe,this._configuration}intersectDraped(e,r,i,s,a,o){if(!i.options.selectionMode)return;const n=e.vertexAttributes.get(p.POSITION).data,l=e.vertexAttributes.get(p.SIZE);let c=this.parameters.width;if(this.parameters.vvSize){const T=e.vertexAttributes.get(p.SIZEFEATUREATTRIBUTE).data[0];c*=Ht(this.parameters.vvSize.offset[0]+T*this.parameters.vvSize.factor[0],this.parameters.vvSize.minSize[0],this.parameters.vvSize.maxSize[0])}else l&&(c*=l.data[0]);const d=s[0],u=s[1],f=(c/2+4)*e.screenToWorldRatio;let h=Number.MAX_VALUE,g=0;for(let T=0;T<n.length-5;T+=3){const w=n[T],b=n[T+1],S=d-w,_=u-b,D=n[T+3]-w,y=n[T+4]-b,x=Ht((D*S+y*_)/(D*D+y*y),0,1),z=D*x-S,C=y*x-_,U=z*z+C*C;U<h&&(h=U,g=T/3)}h<f*f&&a(o.dist,o.normal,g,!1)}intersect(e,r,i,s,a,o){if(!i.options.selectionMode||!e.visible)return;if(!Ya(r))return void Nr.getLogger("esri.views.3d.webgl-engine.materials.RibbonLineMaterial").error("intersection assumes a translation-only matrix");const n=e.vertexAttributes,l=n.get(p.POSITION).data;let c=this.parameters.width;if(this.parameters.vvSize){const S=n.get(p.SIZEFEATUREATTRIBUTE).data[0];c*=Ht(this.parameters.vvSize.offset[0]+S*this.parameters.vvSize.factor[0],this.parameters.vvSize.minSize[0],this.parameters.vvSize.maxSize[0])}else n.has(p.SIZE)&&(c*=n.get(p.SIZE).data[0]);const d=i.camera,u=Ll;vi(u,i.point);const f=c*d.pixelRatio/2+4*d.pixelRatio;k(Nt[0],u[0]-f,u[1]+f,0),k(Nt[1],u[0]+f,u[1]+f,0),k(Nt[2],u[0]+f,u[1]-f,0),k(Nt[3],u[0]-f,u[1]-f,0);for(let S=0;S<4;S++)if(!d.unprojectFromRenderScreen(Nt[S],Fe[S]))return;er(d.eye,Fe[0],Fe[1],Jr),er(d.eye,Fe[1],Fe[2],Yr),er(d.eye,Fe[2],Fe[3],Xr),er(d.eye,Fe[3],Fe[0],Qr);let h=Number.MAX_VALUE,g=0;const T=Ta(this.parameters,n,e.indices)?l.length-2:l.length-5;for(let S=0;S<T;S+=3){de[0]=l[S]+r[12],de[1]=l[S+1]+r[13],de[2]=l[S+2]+r[14];const _=(S+3)%l.length;if(he[0]=l[_]+r[12],he[1]=l[_+1]+r[13],he[2]=l[_+2]+r[14],Ee(Jr,de)<0&&Ee(Jr,he)<0||Ee(Yr,de)<0&&Ee(Yr,he)<0||Ee(Xr,de)<0&&Ee(Xr,he)<0||Ee(Qr,de)<0&&Ee(Qr,he)<0)continue;if(d.projectToRenderScreen(de,Je),d.projectToRenderScreen(he,Ye),Je[2]<0&&Ye[2]>0){le(Ie,de,he);const y=d.frustum,x=-Ee(y[sr.NEAR],de)/Pt(Ie,Li(y[sr.NEAR]));ce(Ie,Ie,x),oe(de,de,Ie),d.projectToRenderScreen(de,Je)}else if(Je[2]>0&&Ye[2]<0){le(Ie,he,de);const y=d.frustum,x=-Ee(y[sr.NEAR],he)/Pt(Ie,Li(y[sr.NEAR]));ce(Ie,Ie,x),oe(he,he,Ie),d.projectToRenderScreen(he,Ye)}else if(Je[2]<0&&Ye[2]<0)continue;Je[2]=0,Ye[2]=0;const D=Xa(Vr(Je,Ye,cs),u);D<h&&(h=D,K(ns,de),K(ls,he),g=S/3)}const w=i.rayBegin,b=i.rayEnd;if(h<f*f){let S=Number.MAX_VALUE;if(Qa(Vr(ns,ls,cs),Vr(w,b,Fl),Ze)){le(Ze,Ze,w);const _=ci(Ze);ce(Ze,Ze,1/_),S=_/Fr(w,b)}o(S,Ze,g,!1)}}get _layout(){const e=dt().vec3f(p.POSITION).f32(p.SUBDIVISIONFACTOR).vec2f(p.UV0).vec3f(p.AUXPOS1).vec3f(p.AUXPOS2);return this.parameters.vvSize?e.f32(p.SIZEFEATUREATTRIBUTE):e.f32(p.SIZE),this.parameters.vvColor?e.f32(p.COLORFEATUREATTRIBUTE):e.vec4f(p.COLOR),this.parameters.vvOpacity&&e.f32(p.OPACITYFEATUREATTRIBUTE),it("enable-feature:objectAndLayerId-rendering")&&e.vec4u8(p.OBJECTANDLAYERIDCOLOR),e}createBufferWriter(){return new $l(this._layout,this.parameters)}requiresSlot(e,r){return r===E.Color||r===E.Alpha||r===E.Highlight||r===E.Depth||r===E.ObjectAndLayerIdColor?e===J.DRAPED_MATERIAL?!0:this.parameters.renderOccluded===st.OccludeAndTransparentStencil?e===J.OPAQUE_MATERIAL||e===J.OCCLUDER_MATERIAL||e===J.TRANSPARENT_OCCLUDER_MATERIAL:r===E.Color||r===E.Alpha?e===(this.parameters.writeDepth?J.TRANSPARENT_MATERIAL:J.TRANSPARENT_DEPTH_WRITE_DISABLED_MATERIAL):e===J.OPAQUE_MATERIAL:!1}createGLMaterial(e){return new Il(e)}validateParameters(e){e.join!=="miter"&&(e.miterLimit=0),e.markerParameters!=null&&(e.markerScale=e.markerParameters.width/e.width)}},Il=class extends ea{constructor(){super(...arguments),this._stipplePattern=null}dispose(){super.dispose(),this._stippleTextureRepository.release(this._stipplePattern),this._stipplePattern=null}_updateOccludeeState(e){e.hasOccludees!==this._material.parameters.hasOccludees&&this._material.setParameters({hasOccludees:e.hasOccludees})}beginSlot(e){this._output!==E.Color&&this._output!==E.Alpha||this._updateOccludeeState(e);const r=this._material.parameters.stipplePattern;return this._stipplePattern!==r&&(this._material.setParameters({stippleTexture:this._stippleTextureRepository.swap(r,this._stipplePattern)}),this._stipplePattern=r),this.ensureTechnique(ya,e)}},Pl=class extends cn{constructor(){super(...arguments),this.width=0,this.color=yi,this.join="miter",this.cap=ct.BUTT,this.miterLimit=5,this.writeDepth=!0,this.hasPolygonOffset=!1,this.stippleTexture=null,this.stippleScaleWithLineWidth=!1,this.stipplePreferContinuous=!0,this.markerParameters=null,this.markerScale=1,this.hasSlicePlane=!1,this.vvFastUpdate=!1,this.isClosed=!1,this.falloff=0,this.innerWidth=0,this.hasOccludees=!1,this.wireframe=!1}},$l=class{constructor(e,r){this._parameters=r,this.numJoinSubdivisions=0,this.vertexBufferLayout=e;const i=r.stipplePattern?1:0;switch(this._parameters.join){case"miter":case"bevel":this.numJoinSubdivisions=i;break;case"round":this.numJoinSubdivisions=Ir+i}}_isClosed(e){return Ta(this._parameters,e.vertexAttributes,e.indices)}allocate(e){return this.vertexBufferLayout.createBuffer(e)}elementCount(e){const i=e.indices.get(p.POSITION).length/2+1,s=this._isClosed(e);let a=s?2:2*2;return a+=((s?i:i-1)-(s?0:1))*(2*this.numJoinSubdivisions+4),a+=2,this._parameters.wireframe&&(a=2+4*(a-2)),a}write(e,r,i,s,a){var ht;const o=Nl,n=zl,l=jl,c=i.vertexAttributes.get(p.POSITION).data,d=i.indices&&i.indices.get(p.POSITION),u=(ht=i.vertexAttributes.get(p.DISTANCETOSTART))==null?void 0:ht.data;d&&d.length!==2*(c.length/3-1)&&console.warn("RibbonLineMaterial does not support indices");let f=1,h=0;this._parameters.vvSize?h=i.vertexAttributes.get(p.SIZEFEATUREATTRIBUTE).data[0]:i.vertexAttributes.has(p.SIZE)&&(f=i.vertexAttributes.get(p.SIZE).data[0]);let g=[1,1,1,1],T=0;this._parameters.vvColor?T=i.vertexAttributes.get(p.COLORFEATUREATTRIBUTE).data[0]:i.vertexAttributes.has(p.COLOR)&&(g=i.vertexAttributes.get(p.COLOR).data);const w=it("enable-feature:objectAndLayerId-rendering")?i.objectAndLayerIdColor:null;let b=0;this._parameters.vvOpacity&&(b=i.vertexAttributes.get(p.OPACITYFEATUREATTRIBUTE).data[0]);const S=c.length/3,_=new Float32Array(s.buffer),D=it("enable-feature:objectAndLayerId-rendering")?new Uint8Array(s.buffer):null,y=this.vertexBufferLayout.stride/4;let x=a*y;const z=x;let C=0;const U=u?(G,Se,be)=>C=u[be]:(G,Se,be)=>C+=Fr(G,Se),Te=it("enable-feature:objectAndLayerId-rendering"),A=(G,Se,be,I,ke,Ae,Lt)=>{if(_[x++]=Se[0],_[x++]=Se[1],_[x++]=Se[2],_[x++]=I,_[x++]=Lt,_[x++]=ke,_[x++]=G[0],_[x++]=G[1],_[x++]=G[2],_[x++]=be[0],_[x++]=be[1],_[x++]=be[2],_[x++]=this._parameters.vvSize?h:f,this._parameters.vvColor)_[x++]=T;else{const He=Math.min(4*Ae,g.length-4);_[x++]=g[He],_[x++]=g[He+1],_[x++]=g[He+2],_[x++]=g[He+3]}this._parameters.vvOpacity&&(_[x++]=b),Te&&(w!=null&&(D[4*x]=w[0],D[4*x+1]=w[1],D[4*x+2]=w[2],D[4*x+3]=w[3]),x++)};x+=y,k(n,c[0],c[1],c[2]),e&&ye(n,n,e);const H=this._isClosed(i);if(H){const G=c.length-3;k(o,c[G],c[G+1],c[G+2]),e&&ye(o,o,e)}else k(l,c[3],c[4],c[5]),e&&ye(l,l,e),A(n,n,l,1,me.LEFT_CAP_START,0,0),A(n,n,l,1,me.RIGHT_CAP_START,0,0),K(o,n),K(n,l);const re=H?0:1,De=H?S:S-1;for(let G=re;G<De;G++){const Se=(G+1)%S*3;k(l,c[Se],c[Se+1],c[Se+2]),e&&ye(l,l,e),U(o,n,G),A(o,n,l,0,me.LEFT_JOIN_END,G,C),A(o,n,l,0,me.RIGHT_JOIN_END,G,C);const be=this.numJoinSubdivisions;for(let I=0;I<be;++I){const ke=(I+1)/(be+1);A(o,n,l,ke,me.LEFT_JOIN_END,G,C),A(o,n,l,ke,me.RIGHT_JOIN_END,G,C)}A(o,n,l,1,me.LEFT_JOIN_START,G,C),A(o,n,l,1,me.RIGHT_JOIN_START,G,C),K(o,n),K(n,l)}H?(k(l,c[3],c[4],c[5]),e&&ye(l,l,e),C=U(o,n,De),A(o,n,l,0,me.LEFT_JOIN_END,re,C),A(o,n,l,0,me.RIGHT_JOIN_END,re,C)):(C=U(o,n,De),A(o,n,n,0,me.LEFT_CAP_END,De,C),A(o,n,n,0,me.RIGHT_CAP_END,De,C)),Zr(_,z+y,_,z,y),x=Zr(_,x-y,_,x,y),this._parameters.wireframe&&this._addWireframeVertices(s,z,x,y)}_addWireframeVertices(e,r,i,s){const a=new Float32Array(e.buffer,i*Float32Array.BYTES_PER_ELEMENT),o=new Float32Array(e.buffer,r*Float32Array.BYTES_PER_ELEMENT,i-r);let n=0;const l=c=>n=Zr(o,c,a,n,s);for(let c=0;c<o.length-1;c+=2*s)l(c),l(c+2*s),l(c+1*s),l(c+2*s),l(c+1*s),l(c+3*s)}};function Zr(t,e,r,i,s){for(let a=0;a<s;a++)r[i++]=t[e++];return i}function Ta(t,e,r){return Sa(t,e.get(p.POSITION).data,r?r.get(p.POSITION):null)}function Sa(t,e,r){return!!t.isClosed&&(r?r.length>2:e.length>6)}function Ml(t){return t.anchor===Jt.Tip&&t.hideOnShortSegments&&t.placement==="begin-end"&&t.worldSpace}const de=N(),he=N(),Ie=N(),Ze=N(),Ll=N(),Je=et(),Ye=et(),ns=N(),ls=N(),cs=Gs(),Fl=Gs(),Nl=N(),zl=N(),jl=N(),Nt=[et(),et(),et(),et()],Fe=[N(),N(),N(),N()],Jr=Qt(),Yr=Qt(),Xr=Qt(),Qr=Qt();let Ul=class{constructor(e){this._originSR=e,this._origins=new Map,this._objects=new Map,this._gridSize=5e5,this._rootOriginId="root/"+ks()}getOrigin(e){const r=this._origins.get(this._rootOriginId);if(r==null){const d=Xi(e[0]+Math.random()-.5,e[1]+Math.random()-.5,e[2]+Math.random()-.5,this._rootOriginId);return this._origins.set(this._rootOriginId,d),d}const i=this._gridSize,s=Math.round(e[0]/i),a=Math.round(e[1]/i),o=Math.round(e[2]/i),n=`${s}/${a}/${o}`;let l=this._origins.get(n);const c=.5*i;if(le(ee,e,r.vec3),ee[0]=Math.abs(ee[0]),ee[1]=Math.abs(ee[1]),ee[2]=Math.abs(ee[2]),ee[0]<c&&ee[1]<c&&ee[2]<c){if(l){const d=Math.max(...ee);if(le(ee,e,l.vec3),ee[0]=Math.abs(ee[0]),ee[1]=Math.abs(ee[1]),ee[2]=Math.abs(ee[2]),Math.max(...ee)<d)return l}return r}return l||(l=Xi(s*i,a*i,o*i,n),this._origins.set(n,l)),l}_drawOriginBox(e,r=kt(1,1,0,1)){const i=window.view,s=i._stage,a=r.toString();if(!this._objects.has(a)){this._material=new El({width:2,color:r}),s.add(this._material);const h=new Kn(s,{pickable:!1}),g=new Jn({castShadow:!1});s.add(g),h.add(g),this._objects.set(a,g)}const o=this._objects.get(a),n=[0,1,5,4,0,2,1,7,6,2,0,1,3,7,5,4,6,2,0],l=n.length,c=new Array(3*l),d=new Array,u=.5*this._gridSize;for(let h=0;h<l;h++)c[3*h]=e[0]+(1&n[h]?u:-u),c[3*h+1]=e[1]+(2&n[h]?u:-u),c[3*h+2]=e[2]+(4&n[h]?u:-u),h>0&&d.push(h-1,h);xr(c,this._originSR,0,c,i.renderSpatialReference,0,l);const f=new we(this._material,[[p.POSITION,new L(c,3,!0)]],[[p.POSITION,d]],null,Mt.Line);s.add(f),o.addGeometry(f)}get test(){const e=this;return{set gridSize(r){e._gridSize=r}}}};const ee=N();var Yt,Pr;(function(t){t[t.RENDERING=0]="RENDERING",t[t.FINISHED_RENDERING=1]="FINISHED_RENDERING",t[t.FADING_TEXTURE_CHANNELS=2]="FADING_TEXTURE_CHANNELS",t[t.SWITCH_CHANNELS=3]="SWITCH_CHANNELS",t[t.FINISHED=4]="FINISHED"})(Yt||(Yt={})),function(t){t[t.RG=0]="RG",t[t.BA=1]="BA"}(Pr||(Pr={}));let Vl=class{constructor(){this.readChannels=Pr.RG,this.renderingStage=Yt.FINISHED,this.startTime=0,this.startTimeHeightFade=0,this.cameraPositionLastFrame=N(),this.isCameraPositionFinal=!0,this.parallax=new ds,this.parallaxNew=new ds,this.crossFade={enabled:!1,factor:1,distanceThresholdFactor:.3},this.fadeInOut={stage:Dt.FINISHED,factor:1,distanceThresholdFactor:.6},this.fadeIn={stage:$r.FINISHED,factor:1,distanceThresholdFactor:2},this.fadeInOutHeight={stage:Mr.FINISHED,factor:-1}}get isFading(){return this.fadeInOut.stage===Dt.FADE_OUT||this.fadeInOut.stage===Dt.FADE_IN||this.fadeIn.stage===$r.FADE_IN||this.fadeInOutHeight.stage!==Mr.FINISHED||this.renderingStage===Yt.FADING_TEXTURE_CHANNELS}};var $r,Dt,Mr;(function(t){t[t.FINISHED=0]="FINISHED",t[t.CHANGE_ANCHOR=1]="CHANGE_ANCHOR",t[t.FADE_IN=2]="FADE_IN"})($r||($r={})),function(t){t[t.FINISHED=0]="FINISHED",t[t.FADE_OUT=1]="FADE_OUT",t[t.SWITCH=2]="SWITCH",t[t.FADE_IN=3]="FADE_IN"}(Dt||(Dt={})),function(t){t[t.FINISHED=0]="FINISHED",t[t.HEIGHT_FADE=1]="HEIGHT_FADE"}(Mr||(Mr={}));let ds=class{constructor(){this.anchorPointClouds=N(),this.cloudsHeight=1e5,this.radiusCurvatureCorrectionFactor=0,this.transform=W()}};function vh(t){t.include(ta),t.uniforms.add(new nt("geometryDepthTexture",(e,r)=>r.multipassGeometry.linearDepthTexture),new jr("nearFar",(e,r)=>r.camera.nearFar)),t.code.add(m`bool geometryDepthTest(vec2 pos, float elementDepth) {
float geometryDepth = linearDepthFromTexture(geometryDepthTexture, pos, nearFar);
return (elementDepth < (geometryDepth - 1.0));
}`)}let Hl=class{constructor(){this.enabled=!1}};function Wl(t,e){const r=t.fragment;r.include(ta),r.uniforms.add(new jr("nearFar",(i,s)=>s.camera.nearFar)),r.uniforms.add(new nt("depthMap",(i,s)=>s.linearDepthTexture)),r.uniforms.add(new $t("proj",(i,s)=>s.ssr.camera.projectionMatrix)),r.uniforms.add(new Y("invResolutionHeight",(i,s)=>1/s.ssr.camera.height)),r.uniforms.add(new $t("reprojectionMatrix",(i,s)=>s.ssr.reprojectionMatrix)),r.code.add(m`
  vec2 reprojectionCoordinate(vec3 projectionCoordinate)
  {
    vec4 zw = proj * vec4(0.0, 0.0, -projectionCoordinate.z, 1.0);
    vec4 reprojectedCoord = reprojectionMatrix * vec4(zw.w * (projectionCoordinate.xy * 2.0 - 1.0), zw.z, zw.w);
    reprojectedCoord.xy /= reprojectedCoord.w;
    return reprojectedCoord.xy * 0.5 + 0.5;
  }

  const int maxSteps = ${e.highStepCount?"150":"75"};

  vec4 applyProjectionMat(mat4 projectionMat, vec3 x)
  {
    vec4 projectedCoord =  projectionMat * vec4(x, 1.0);
    projectedCoord.xy /= projectedCoord.w;
    projectedCoord.xy = projectedCoord.xy*0.5 + 0.5;
    return projectedCoord;
  }

  vec3 screenSpaceIntersection(vec3 dir, vec3 startPosition, vec3 viewDir, vec3 normal)
  {
    vec3 viewPos = startPosition;
    vec3 viewPosEnd = startPosition;

    // Project the start position to the screen
    vec4 projectedCoordStart = applyProjectionMat(proj, viewPos);
    vec3  Q0 = viewPos / projectedCoordStart.w; // homogeneous camera space
    float k0 = 1.0/ projectedCoordStart.w;

    // advance the position in the direction of the reflection
    viewPos += dir;

    vec4 projectedCoordVanishingPoint = applyProjectionMat(proj, dir);

    // Project the advanced position to the screen
    vec4 projectedCoordEnd = applyProjectionMat(proj, viewPos);
    vec3  Q1 = viewPos / projectedCoordEnd.w; // homogeneous camera space
    float k1 = 1.0/ projectedCoordEnd.w;

    // calculate the reflection direction in the screen space
    vec2 projectedCoordDir = (projectedCoordEnd.xy - projectedCoordStart.xy);
    vec2 projectedCoordDistVanishingPoint = (projectedCoordVanishingPoint.xy - projectedCoordStart.xy);

    float yMod = min(abs(projectedCoordDistVanishingPoint.y), 1.0);

    float projectedCoordDirLength = length(projectedCoordDir);
    float maxSt = float(maxSteps);

    // normalize the projection direction depending on maximum steps
    // this determines how blocky the reflection looks
    vec2 dP = yMod * (projectedCoordDir)/(maxSt * projectedCoordDirLength);

    // Normalize the homogeneous camera space coordinates
    vec3  dQ = yMod * (Q1 - Q0)/(maxSt * projectedCoordDirLength);
    float dk = yMod * (k1 - k0)/(maxSt * projectedCoordDirLength);

    // initialize the variables for ray marching
    vec2 P = projectedCoordStart.xy;
    vec3 Q = Q0;
    float k = k0;
    float rayStartZ = -startPosition.z; // estimated ray start depth value
    float rayEndZ = -startPosition.z;   // estimated ray end depth value
    float prevEstimateZ = -startPosition.z;
    float rayDiffZ = 0.0;
    float dDepth;
    float depth;
    float rayDiffZOld = 0.0;

    // early outs
    if (dot(normal, dir) < 0.0 || dot(-viewDir, normal) < 0.0)
      return vec3(P, 0.0);

    for(int i = 0; i < maxSteps-1; i++)
    {
      depth = -linearDepthFromTexture(depthMap, P, nearFar); // get linear depth from the depth buffer

      // estimate depth of the marching ray
      rayStartZ = prevEstimateZ;
      dDepth = -rayStartZ - depth;
      rayEndZ = (dQ.z * 0.5 + Q.z)/ ((dk * 0.5 + k));
      rayDiffZ = rayEndZ- rayStartZ;
      prevEstimateZ = rayEndZ;

      if(-rayEndZ > nearFar[1] || -rayEndZ < nearFar[0] || P.y < 0.0  || P.y > 1.0 )
      {
        return vec3(P, 0.);
      }

      // If we detect a hit - return the intersection point, two conditions:
      //  - dDepth > 0.0 - sampled point depth is in front of estimated depth
      //  - if difference between dDepth and rayDiffZOld is not too large
      //  - if difference between dDepth and 0.025/abs(k) is not too large
      //  - if the sampled depth is not behind far plane or in front of near plane

      if((dDepth) < 0.025/abs(k) + abs(rayDiffZ) && dDepth > 0.0 && depth > nearFar[0] && depth < nearFar[1] && abs(P.y - projectedCoordStart.y) > invResolutionHeight)
      {
        return vec3(P, depth);
      }

      // continue with ray marching
      P += dP;
      Q.z += dQ.z;
      k += dk;
      rayDiffZOld = rayDiffZ;
    }
    return vec3(P, 0.0);
  }
  `)}let Gl=class{constructor(){this.enabled=!1,this.fadeFactor=1,this.reprojectionMatrix=W()}},Bl=class{constructor(e,r,i){this.shadowMap=e,this.ssaoHelper=r,this.slicePlane=i,this.slot=J.OPAQUE_MATERIAL,this.hasOccludees=!1,this.enableFillLights=!0,this.transparencyPassType=ge.NONE,this.alignPixelEnabled=!1,this._camera=new F,this._inverseViewport=q(),this.oldLighting=new Gr,this.newLighting=new Gr,this._fadedLighting=new Gr,this._lighting=this.newLighting,this.ssr=new Gl,this.multipassTerrain=new dn,this.multipassGeometry=new Hl,this.overlays=[],this.cloudsFade=new Vl}get camera(){return this._camera}set camera(e){this._camera=this.ssr.camera=e,this._inverseViewport[0]=1/e.fullViewport[2],this._inverseViewport[1]=1/e.fullViewport[3]}get inverseViewport(){return this._inverseViewport}get lighting(){return this._lighting}get weatherFading(){return this._lighting===this._fadedLighting}fadeLighting(e){const{oldLighting:r,newLighting:i}=this;e>=1?this._lighting=i:(this._fadedLighting.lerpLighting(r,i,e),this._lighting=this._fadedLighting)}},kl=class{constructor(e,r,i,s=null){this.rctx=e,this.sliceHelper=s,this.lastFrameCamera=new F,this.output=E.Color,this.renderOccludedMask=hs,this.bindParameters=new Bl(r,i,s!=null?s.plane:null),this.bindParameters.alignPixelEnabled=!0}resetRenderOccludedMask(){this.renderOccludedMask=hs}};const hs=st.Occlude|st.OccludeAndTransparent|st.OccludeAndTransparentStencil;let Ut=class extends F{constructor(){super(...arguments),this._projectionMatrix=W()}get projectionMatrix(){return this._projectionMatrix}};v([$()],Ut.prototype,"_projectionMatrix",void 0),v([$({readOnly:!0})],Ut.prototype,"projectionMatrix",null),Ut=v([zr("esri.views.3d.webgl-engine.lib.CascadeCamera")],Ut);const us=16;function ql(t){return Math.ceil(t/us)*us}var ps;(function(t){t[t.Highlight=0]="Highlight",t[t.Default=1]="Default"})(ps||(ps={}));let or=class{constructor(){this.camera=new Ut,this.lightMat=W()}},Zl=class{constructor(){this.maxNumCascadesHighQuality=4,this.maxNumCascadesLowQuality=4,this.textureSizeModHighQuality=1.3,this.textureSizeModLowQuality=.9,this.splitSchemeLambda=0}},Jl=class{get depthTexture(){var e;return(e=this._fbo)==null?void 0:e.colorTexture}get textureSize(){return this._textureSize}get numCascades(){return this._numCascades}get cascadeDistances(){return qt(this._usedCascadeDistances,this._cascadeDistances[0],this._numCascades>1?this._cascadeDistances[1]:1/0,this._numCascades>2?this._cascadeDistances[2]:1/0,this._numCascades>3?this._cascadeDistances[3]:1/0)}constructor(e,r){this._rctx=e,this._viewingMode=r,this._enabled=!1,this._snapshots=new Array,this._textureSize=0,this._numCascades=1,this.settings=new Zl,this._projectionView=W(),this._projectionViewInverse=W(),this._modelViewLight=W(),this._cascadeDistances=[0,0,0,0,0],this._usedCascadeDistances=Ve(),this._cascades=[new or,new or,new or,new or],this._lastOrigin=null,this._maxTextureSize=Math.min(it("esri-mobile")?2048:8192,this._rctx.parameters.maxTextureSize)}dispose(){this.enabled=!1,this.disposeOffscreenBuffers()}disposeOffscreenBuffers(){this._fbo=je(this._fbo),this._discardAllSnapshots()}set maxCascades(e){this.settings.maxNumCascadesHighQuality=Ht(Math.floor(e),1,4)}get maxCascades(){return this.settings.maxNumCascadesHighQuality}set enabled(e){this._enabled=e,e||this.disposeOffscreenBuffers()}get enabled(){return this._enabled}get ready(){return this._enabled&&this.depthTexture!=null}getSnapshot(e){return this.enabled?this._snapshots[e]:null}get cascades(){for(let e=0;e<this._numCascades;++e)ei[e]=this._cascades[e];return ei.length=this._numCascades,ei}start(e,r,i,s,a){pe(this.enabled),this._textureSize=this._computeTextureSize(e,a,s),this._ensureDepthTexture();const{near:o,far:n}=this._clampNearFar(i);this._computeCascadeDistances(n,o,s),this._setupMatrices(e,r);const{viewMatrix:l,projectionMatrix:c}=e;for(let d=0;d<this._numCascades;++d)this._constructCascade(d,c,l,r);this._lastOrigin=null,this.clear()}finish(e){pe(this.enabled),this._rctx.bindFramebuffer(e)}getShadowMapMatrices(e){if(!this._lastOrigin||!Rt(e,this._lastOrigin)){this._lastOrigin=this._lastOrigin||N(),K(this._lastOrigin,e);for(let r=0;r<this._numCascades;++r){Fi(ys,this._cascades[r].lightMat,e);for(let i=0;i<16;++i)ws[16*r+i]=ys[i]}}return ws}takeCascadeSnapshotTo(e,r){pe(this.enabled);const i=this._ensureSnapshot(r);this._bindFbo();const s=this._rctx,a=s.bindTexture(i,gr.TEXTURE_UNIT_FOR_UPDATES);s.gl.copyTexSubImage2D(Pn.TEXTURE_2D,0,e.camera.viewport[0],e.camera.viewport[1],e.camera.viewport[0],e.camera.viewport[1],e.camera.viewport[2],e.camera.viewport[3]),s.bindTexture(a,gr.TEXTURE_UNIT_FOR_UPDATES)}clear(){const e=this._rctx;this._bindFbo(),e.setClearColor(1,1,1,1),e.clearSafe(Or.COLOR_BUFFER_BIT|Or.DEPTH_BUFFER_BIT)}_computeTextureSize(e,r,i){const s=Math.min(window.devicePixelRatio,r)/e.pixelRatio,a=Math.max(e.fullWidth,e.fullHeight)*s,o=i?this.settings.textureSizeModHighQuality:this.settings.textureSizeModLowQuality;return Math.floor(Math.min(this._maxTextureSize,ql((this.numCascades===1?1:2)*a*o)))}_ensureDepthTexture(){var r,i;if(((r=this._fbo)==null?void 0:r.width)===this._textureSize)return;const e=new Dr(this._textureSize);e.wrapMode=di.CLAMP_TO_EDGE,e.samplingMode=br.NEAREST,(i=this._fbo)==null||i.dispose(),this._fbo=new na(this._rctx,e,new Ln($n.DEPTH_COMPONENT16,this._textureSize))}_ensureSnapshot(e){let r=this._snapshots[e];if(r!=null&&r.descriptor.width===this._textureSize)return r;this._discardSnapshot(e);const i=new Dr;return i.wrapMode=di.CLAMP_TO_EDGE,i.samplingMode=br.NEAREST,i.width=this._textureSize,i.height=this._textureSize,r=new gr(this._rctx,i),this._snapshots[e]=r,r}_discardSnapshot(e){this._snapshots[e]=je(this._snapshots[e])}_discardAllSnapshots(){for(let e=0;e<this._snapshots.length;++e)this._discardSnapshot(e);this._snapshots.length=0}_bindFbo(){const e=this._rctx;e.unbindTexture(this.depthTexture),e.bindFramebuffer(this._fbo)}_constructCascade(e,r,i,s){const a=this._cascades[e],o=-this._cascadeDistances[e],n=-this._cascadeDistances[e+1],l=(r[10]*o+r[14])/Math.abs(r[11]*o+r[15]),c=(r[10]*n+r[14])/Math.abs(r[11]*n+r[15]);pe(l<c);for(let h=0;h<8;++h){qt(fs,h%4==0||h%4==3?-1:1,h%4==0||h%4==1?-1:1,h<4?l:c,1);const g=Re[h];jt(g,fs,this._projectionViewInverse),g[0]/=g[3],g[1]/=g[3],g[2]/=g[3]}Ka(Kr,Re[0]),a.camera.viewMatrix=Fi(Yl,this._modelViewLight,Kr);for(let h=0;h<8;++h)ye(Re[h],Re[h],a.camera.viewMatrix);let d=Re[0][2],u=Re[0][2];for(let h=1;h<8;++h)d=Math.min(d,Re[h][2]),u=Math.max(u,Re[h][2]);d-=200,u+=200,a.camera.near=-u,a.camera.far=-d,ec(i,s,d,u,a.camera),ot(a.lightMat,a.camera.projectionMatrix,a.camera.viewMatrix);const f=this._textureSize/(this.numCascades===1?1:2);a.camera.viewport=[e%2==0?0:f,Math.floor(e/2)===0?0:f,f,f]}_setupMatrices(e,r){ot(this._projectionView,e.projectionMatrix,e.viewMatrix),Vt(this._projectionViewInverse,this._projectionView);const i=this._viewingMode===Xt.Global?e.eye:k(Kr,0,0,1);Ws(this._modelViewLight,[0,0,0],[-r[0],-r[1],-r[2]],i)}_clampNearFar(e){let{near:r,far:i}=e;return r<2&&(r=2),i<2&&(i=2),r>=i&&(r=2,i=4),{near:r,far:i}}_computeCascadeDistances(e,r,i){const s=i?this.settings.maxNumCascadesHighQuality:this.settings.maxNumCascadesLowQuality;this._numCascades=Math.min(1+Math.floor(eo(e/r,4)),s);const a=(e-r)/this._numCascades,o=(e/r)**(1/this._numCascades);let n=r,l=r;for(let c=0;c<this._numCascades+1;++c)this._cascadeDistances[c]=Qe(n,l,this.settings.splitSchemeLambda),n*=o,l+=a}get gpuMemoryUsage(){var e;return this._snapshots.reduce((r,i)=>r+((i==null?void 0:i.gpuMemoryUsage)??0),((e=this._fbo)==null?void 0:e.gpuMemoryUsage)??0)}get test(){return{cascades:this._cascades,textureSize:this._textureSize}}};const Yl=W(),fs=Ve(),Re=[];for(let t=0;t<8;++t)Re.push(Ve());const ms=q(),gs=q(),Xl=q(),vs=q(),_s=q(),Kr=N(),ei=[],ys=W(),ws=new Array(64),_e=q(),ft=q(),Xe=[q(),q(),q(),q()],Z=q(),ti=q(),We=q(),zt=q(),mt=q(),gt=q(),nr=q();function Ql(t,e,r,i,s,a,o,n){Rr(_e,0,0);for(let y=0;y<4;++y)qe(_e,_e,t[y]);Tt(_e,_e,.25),Rr(ft,0,0);for(let y=4;y<8;++y)qe(ft,ft,t[y]);Tt(ft,ft,.25),Ft(Xe[0],t[4],t[5],.5),Ft(Xe[1],t[5],t[6],.5),Ft(Xe[2],t[6],t[7],.5),Ft(Xe[3],t[7],t[4],.5);let l=0,c=Ni(Xe[0],_e);for(let y=1;y<4;++y){const x=Ni(Xe[y],_e);x<c&&(c=x,l=y)}St(Z,Xe[l],t[l+4]);const d=Z[0];let u,f;Z[0]=-Z[1],Z[1]=d,St(ti,ft,_e),ae(ti,Z)<0&&ro(Z,Z),Ft(Z,Z,ti,r),zi(Z,Z),u=f=ae(St(We,t[0],_e),Z);for(let y=1;y<8;++y){const x=ae(St(We,t[y],_e),Z);x<u?u=x:x>f&&(f=x)}vi(i,_e),Tt(We,Z,u-e),qe(i,i,We);let h=-1,g=1,T=0,w=0;for(let y=0;y<8;++y){St(zt,t[y],i),zi(zt,zt);const x=Z[0]*zt[1]-Z[1]*zt[0];x>0?x>h&&(h=x,T=y):x<g&&(g=x,w=y)}ut(h>0,"leftArea"),ut(g<0,"rightArea"),Tt(mt,Z,u),qe(mt,mt,_e),Tt(gt,Z,f),qe(gt,gt,_e),nr[0]=-Z[1],nr[1]=Z[0];const b=tr(i,t[w],gt,qe(We,gt,nr),1,s),S=tr(i,t[T],gt,We,1,a),_=tr(i,t[T],mt,qe(We,mt,nr),1,o),D=tr(i,t[w],mt,We,1,n);ut(b,"rayRay"),ut(S,"rayRay"),ut(_,"rayRay"),ut(D,"rayRay")}function M(t,e){return 3*e+t}const Ts=q();function fe(t,e){return Rr(Ts,t[e],t[e+3]),Ts}const ue=q(),R=io();function Kl(t,e,r,i,s){St(ue,r,i),Tt(ue,ue,.5),R[0]=ue[0],R[1]=ue[1],R[2]=0,R[3]=ue[1],R[4]=-ue[0],R[5]=0,R[6]=ue[0]*ue[0]+ue[1]*ue[1],R[7]=ue[0]*ue[1]-ue[1]*ue[0],R[8]=1,R[M(0,2)]=-ae(fe(R,0),t),R[M(1,2)]=-ae(fe(R,1),t);let a=ae(fe(R,0),r)+R[M(0,2)],o=ae(fe(R,1),r)+R[M(1,2)],n=ae(fe(R,0),i)+R[M(0,2)],l=ae(fe(R,1),i)+R[M(1,2)];a=-(a+n)/(o+l),R[M(0,0)]+=R[M(1,0)]*a,R[M(0,1)]+=R[M(1,1)]*a,R[M(0,2)]+=R[M(1,2)]*a,a=1/(ae(fe(R,0),r)+R[M(0,2)]),o=1/(ae(fe(R,1),r)+R[M(1,2)]),R[M(0,0)]*=a,R[M(0,1)]*=a,R[M(0,2)]*=a,R[M(1,0)]*=o,R[M(1,1)]*=o,R[M(1,2)]*=o,R[M(2,0)]=R[M(1,0)],R[M(2,1)]=R[M(1,1)],R[M(2,2)]=R[M(1,2)],R[M(1,2)]+=1,a=ae(fe(R,1),e)+R[M(1,2)],o=ae(fe(R,2),e)+R[M(2,2)],n=ae(fe(R,1),r)+R[M(1,2)],l=ae(fe(R,2),r)+R[M(2,2)],a=-.5*(a/o+n/l),R[M(1,0)]+=R[M(2,0)]*a,R[M(1,1)]+=R[M(2,1)]*a,R[M(1,2)]+=R[M(2,2)]*a,a=ae(fe(R,1),e)+R[M(1,2)],o=ae(fe(R,2),e)+R[M(2,2)],n=-o/a,R[M(1,0)]*=n,R[M(1,1)]*=n,R[M(1,2)]*=n,s[0]=R[0],s[1]=R[1],s[2]=0,s[3]=R[2],s[4]=R[3],s[5]=R[4],s[6]=0,s[7]=R[5],s[8]=0,s[9]=0,s[10]=1,s[11]=0,s[12]=R[6],s[13]=R[7],s[14]=0,s[15]=R[8]}function ec(t,e,r,i,s){const a=1/Re[0][3],o=1/Re[4][3];pe(a<o);let n=a+Math.sqrt(a*o);const l=Math.sin(to(t[2]*e[0]+t[6]*e[1]+t[10]*e[2]));n/=l,Ql(Re,n,l,ms,gs,Xl,vs,_s),Kl(ms,gs,vs,_s,s.projectionMatrix),s.projectionMatrix[10]=2/(r-i),s.projectionMatrix[14]=-(r+i)/(r-i)}let tc=class{constructor(){this.adds=new Me,this.removes=new Me,this.updates=new Me({allocator:e=>e||new rc,deallocator:e=>(e.renderGeometry=null,e)})}clear(){this.adds.clear(),this.removes.clear(),this.updates.clear()}prune(){this.adds.prune(),this.removes.prune(),this.updates.prune()}get empty(){return this.adds.length===0&&this.removes.length===0&&this.updates.length===0}},rc=class{},ic=class{constructor(){this.adds=new Array,this.removes=new Array,this.updates=new Array}};function sc(t){const e=new Map,r=i=>{let s=e.get(i);return s||(s=new ic,e.set(i,s)),s};return t.removes.forAll(i=>{ri(i)&&r(i.material).removes.push(i)}),t.adds.forAll(i=>{ri(i)&&r(i.material).adds.push(i)}),t.updates.forAll(i=>{ri(i.renderGeometry)&&r(i.renderGeometry.material).updates.push(i)}),e}function ri(t){return t.geometry.indexCount>=1}let ac=class{constructor(e,r){this._material=e,this._repository=r,this._map=new Map}destroy(){this._map.forEach((e,r)=>{e!=null&&this._repository.release(this._material,r)})}load(e,r,i){if(!this._material.requiresSlot(r,i))return null;this._map.has(i)||this._map.set(i,this._repository.acquire(this._material,r,i));const s=this._map.get(i);if(s!=null){if(s.ensureResources(e)===Hn.LOADED)return s;this._repository.requestRender()}return null}},oc=class extends hn{constructor(e=N()){super(),this.origin=e,this.slicePlaneLocalOrigin=this.origin}};const Ih=dt().vec3f(p.POSITION),nc=dt().vec3f(p.POSITION).vec2f(p.UV0),Ph=dt().vec3f(p.POSITION).vec4u8(p.COLOR);dt().vec3f(p.POSITION).vec4u8(p.OBJECTANDLAYERIDCOLOR);const lc=dt().vec3f(p.POSITION).vec2f(p.UV0).vec4u8(p.OBJECTANDLAYERIDCOLOR);dt().vec3f(p.POSITION).vec4u8(p.COLOR).vec4u8(p.OBJECTANDLAYERIDCOLOR);let cc=class extends Bs{intersect(e,r,i,s,a,o){return so(e,i,s,a,void 0,o)}};function dc(t){t.fragment.code.add(m`float normals2FoamIntensity(vec3 n, float waveStrength){
float normalizationFactor =  max(0.015, waveStrength);
return max((n.x + n.y)*0.3303545/normalizationFactor + 0.3303545, 0.0);
}`)}function hc(t){t.fragment.code.add(m`vec3 foamIntensity2FoamColor(float foamIntensityExternal, float foamPixelIntensity, vec3 skyZenitColor, float dayMod){
return foamIntensityExternal * (0.075 * skyZenitColor * pow(foamPixelIntensity, 4.) +  50.* pow(foamPixelIntensity, 23.0)) * dayMod;
}`)}function Ss(t){t.fragment.uniforms.add(new nt("texWaveNormal",e=>e.waveNormal),new nt("texWavePerturbation",e=>e.wavePertubation),new at("waveParams",e=>qt(uc,e.waveStrength,e.waveTextureRepeat,e.flowStrength,e.flowOffset)),new jr("waveDirection",e=>Rr(pc,e.waveDirection[0]*e.waveVelocity,e.waveDirection[1]*e.waveVelocity))),t.include(dc),t.fragment.code.add(m`const vec2  FLOW_JUMP = vec2(6.0/25.0, 5.0/24.0);
vec2 textureDenormalized2D(sampler2D _tex, vec2 _uv) {
return 2.0 * texture(_tex, _uv).rg - 1.0;
}
float sampleNoiseTexture(vec2 _uv) {
return texture(texWavePerturbation, _uv).b;
}
vec3 textureDenormalized3D(sampler2D _tex, vec2 _uv) {
return 2.0 * texture(_tex, _uv).rgb - 1.0;
}
float computeProgress(vec2 uv, float time) {
return fract(time);
}
float computeWeight(vec2 uv, float time) {
float progress = computeProgress(uv, time);
return 1.0 - abs(1.0 - 2.0 * progress);
}
vec3 computeUVPerturbedWeigth(sampler2D texFlow, vec2 uv, float time, float phaseOffset) {
float flowStrength = waveParams[2];
float flowOffset = waveParams[3];
vec2 flowVector = textureDenormalized2D(texFlow, uv) * flowStrength;
float progress = computeProgress(uv, time + phaseOffset);
float weight = computeWeight(uv, time + phaseOffset);
vec2 result = uv;
result -= flowVector * (progress + flowOffset);
result += phaseOffset;
result += (time - progress) * FLOW_JUMP;
return vec3(result, weight);
}
const float TIME_NOISE_TEXTURE_REPEAT = 0.3737;
const float TIME_NOISE_STRENGTH = 7.77;
vec3 getWaveLayer(sampler2D _texNormal, sampler2D _dudv, vec2 _uv, vec2 _waveDir, float time) {
float waveStrength = waveParams[0];
vec2 waveMovement = time * -_waveDir;
float timeNoise = sampleNoiseTexture(_uv * TIME_NOISE_TEXTURE_REPEAT) * TIME_NOISE_STRENGTH;
vec3 uv_A = computeUVPerturbedWeigth(_dudv, _uv + waveMovement, time + timeNoise, 0.0);
vec3 uv_B = computeUVPerturbedWeigth(_dudv, _uv + waveMovement, time + timeNoise, 0.5);
vec3 normal_A = textureDenormalized3D(_texNormal, uv_A.xy) * uv_A.z;
vec3 normal_B = textureDenormalized3D(_texNormal, uv_B.xy) * uv_B.z;
vec3 mixNormal = normalize(normal_A + normal_B);
mixNormal.xy *= waveStrength;
mixNormal.z = sqrt(1.0 - dot(mixNormal.xy, mixNormal.xy));
return mixNormal;
}
vec4 getSurfaceNormalAndFoam(vec2 _uv, float _time) {
float waveTextureRepeat = waveParams[1];
vec3 normal = getWaveLayer(texWaveNormal, texWavePerturbation, _uv * waveTextureRepeat, waveDirection, _time);
float foam  = normals2FoamIntensity(normal, waveParams[0]);
return vec4(normal, foam);
}`)}const uc=Ve(),pc=q();function xs(t,e){e.spherical?t.vertex.code.add(m`vec3 getLocalUp(in vec3 pos, in vec3 origin) {
return normalize(pos + origin);
}`):t.vertex.code.add(m`vec3 getLocalUp(in vec3 pos, in vec3 origin) {
return vec3(0.0, 0.0, 1.0);
}`),e.spherical?t.vertex.code.add(m`mat3 getTBNMatrix(in vec3 n) {
vec3 t = normalize(cross(vec3(0.0, 0.0, 1.0), n));
vec3 b = normalize(cross(n, t));
return mat3(t, b, n);
}`):t.vertex.code.add(m`mat3 getTBNMatrix(in vec3 n) {
vec3 t = vec3(1.0, 0.0, 0.0);
vec3 b = normalize(cross(n, t));
return mat3(t, b, n);
}`)}function fc(t){t.fragment.code.add(m`const float GAMMA = 2.2;
const float INV_GAMMA = 0.4545454545;
vec4 delinearizeGamma(vec4 color) {
return vec4(pow(color.rgb, vec3(INV_GAMMA)), color.w);
}
vec3 linearizeGamma(vec3 color) {
return pow(color, vec3(GAMMA));
}`)}let mc=class extends un{constructor(e,r){super(e,"samplerCube",pn.Pass,(i,s,a)=>i.bindTexture(e,r(s,a)))}};function gc(t){const e=t.fragment;e.uniforms.add(new $t("rotationMatrixClouds",(r,i)=>i.cloudsFade.parallax.transform),new $t("rotationMatrixCloudsCrossFade",(r,i)=>i.cloudsFade.parallaxNew.transform),new Ct("anchorPosition",(r,i)=>i.cloudsFade.parallax.anchorPointClouds),new Ct("anchorPositionCrossFade",(r,i)=>i.cloudsFade.parallaxNew.anchorPointClouds),new Y("cloudsHeight",(r,i)=>i.cloudsFade.parallax.cloudsHeight),new Y("radiusCurvatureCorrectionFactor",(r,i)=>i.cloudsFade.parallax.radiusCurvatureCorrectionFactor),new Y("totalFadeInOut",(r,i)=>i.cloudsFade.fadeInOut.stage===Dt.FINISHED?i.cloudsFade.fadeInOutHeight.factor+1-i.cloudsFade.fadeIn.factor:i.cloudsFade.fadeInOutHeight.factor+1-i.cloudsFade.fadeInOut.factor),new Y("crossFadeAnchorFactor",(r,i)=>Ht(i.cloudsFade.crossFade.factor,0,1)),new mc("cubeMap",(r,i)=>{var s;return(s=i.cloudsFade.data)!=null&&s.cubeMap?i.cloudsFade.data.cubeMap.colorTexture:null}),new Br("crossFade",(r,i)=>i.cloudsFade.crossFade.enabled),new Br("readChannelsRG",(r,i)=>i.cloudsFade.readChannels===Pr.RG),new Br("fadeTextureChannels",(r,i)=>i.cloudsFade.renderingStage===Yt.FADING_TEXTURE_CHANNELS)),e.constants.add("planetRadius","float",ao.radius),e.code.add(m`vec3 intersectWithCloudLayer(vec3 dir, vec3 cameraPosition, vec3 spherePos)
{
float radiusClouds = planetRadius + cloudsHeight;
float B = 2.0 * dot(cameraPosition, dir);
float C = dot(cameraPosition, cameraPosition) - radiusClouds * radiusClouds;
float det = B * B - 4.0 * C;
float pointIntDist = max(0.0, 0.5 *(-B + sqrt(det)));
vec3 intersectionPont = cameraPosition + dir * pointIntDist;
intersectionPont =  intersectionPont - spherePos;
return intersectionPont;
}`),e.code.add(m`vec3 correctForPlanetCurvature(vec3 dir)
{
dir.z = dir.z*(1.-radiusCurvatureCorrectionFactor) + radiusCurvatureCorrectionFactor;
return dir;
}`),e.code.add(m`vec3 rotateDirectionToAnchorPoint(mat4 rotMat, vec3 inVec)
{
return (rotMat * vec4(inVec, 0.0)).xyz;
}`),ra(e),ia(e),e.code.add(m`const float SUNSET_TRANSITION_FACTOR = 0.3;
const vec3 RIM_COLOR = vec3(0.28, 0.175, 0.035);
const float RIM_SCATTERING_FACTOR = 140.0;
const float BACKLIGHT_FACTOR = 0.2;
const float BACKLIGHT_SCATTERING_FACTOR = 10.0;
const float BACKLIGHT_TRANSITION_FACTOR = 0.3;
vec3 calculateCloudColor(vec3 cameraPosition, vec3 worldSpaceRay, vec4 clouds)
{
float upDotLight = dot(normalize(cameraPosition), normalize(mainLightDirection));
float dirDotLight = max(dot(normalize(-worldSpaceRay), normalize(mainLightDirection)), 0.0);
float sunsetTransition = clamp(pow(max(upDotLight, 0.0), SUNSET_TRANSITION_FACTOR), 0.0, 1.0);
vec3 ambientLight = calculateAmbientIrradiance(normalize(cameraPosition),  0.0);
vec3 mainLight = evaluateMainLighting(normalize(cameraPosition),  0.0);
vec3 combinedLight = clamp((mainLightIntensity + ambientLight )/PI, vec3(0.0), vec3(1.0));
vec3 baseCloudColor = pow(combinedLight * pow(clouds.xyz, vec3(GAMMA)), vec3(INV_GAMMA));
float scatteringMod = max(clouds.a < 0.5 ? clouds.a / 0.5 : - clouds.a / 0.5 + 2.0, 0.0);
float rimLightIntensity = 0.5 + 0.5 *pow(max(upDotLight, 0.0), 0.35);
vec3 directSunScattering = RIM_COLOR * rimLightIntensity * (pow(dirDotLight, RIM_SCATTERING_FACTOR)) * scatteringMod;
float additionalLight = BACKLIGHT_FACTOR * pow(dirDotLight, BACKLIGHT_SCATTERING_FACTOR) * (1. - pow(sunsetTransition, BACKLIGHT_TRANSITION_FACTOR)) ;
return vec3(baseCloudColor * (1. + additionalLight) + directSunScattering);
}`),e.code.add(m`vec4 getCloudData(vec3 rayDir, bool readOtherChannel)
{
vec4 cloudData = texture(cubeMap, rayDir);
float mu = dot(rayDir, vec3(0, 0, 1));
bool readChannels = readChannelsRG ^^ readOtherChannel;
if (readChannels) {
cloudData = vec4(vec3(cloudData.r), cloudData.g);
} else {
cloudData = vec4(vec3(cloudData.b), cloudData.a);
}
if (length(cloudData) == 0.0) {
return vec4(cloudData.rgb, 1.0);
}
return cloudData;
}`),e.code.add(m`vec4 renderCloudsNoFade(vec3 worldRay, vec3 cameraPosition)
{
vec3 intersectionPoint = intersectWithCloudLayer(normalize(worldRay), cameraPosition, anchorPosition);
vec3 worldRayRotated = rotateDirectionToAnchorPoint(rotationMatrixClouds, normalize(intersectionPoint));
vec3 worldRayRotatedCorrected = correctForPlanetCurvature(worldRayRotated);
vec4 cloudData = getCloudData(worldRayRotatedCorrected, false);
float totalTransmittance = clamp(cloudData.a * (1.0 - totalFadeInOut) + totalFadeInOut, 0.0 , 1.0);
if (length(cloudData.rgb) == 0.0) {
totalTransmittance = 1.0;
}
return vec4(calculateCloudColor(cameraPosition, normalize(-worldRay), cloudData), totalTransmittance);
}`),e.code.add(m`vec4 renderCloudsCrossFade(vec3 worldRay, vec3 cameraPosition)
{
vec3 intersectionPoint = intersectWithCloudLayer(normalize(worldRay), cameraPosition, anchorPosition);
vec3 worldRayRotated = rotateDirectionToAnchorPoint(rotationMatrixClouds, normalize(intersectionPoint));
vec3 worldRayRotatedCorrected = correctForPlanetCurvature(worldRayRotated);
vec4 cloudData = getCloudData(worldRayRotatedCorrected, false);
vec4 cloudColor = vec4(calculateCloudColor(cameraPosition, normalize(-worldRay), cloudData), cloudData.a);
intersectionPoint = intersectWithCloudLayer(normalize(worldRay), cameraPosition, anchorPositionCrossFade);
worldRayRotated = rotateDirectionToAnchorPoint(rotationMatrixCloudsCrossFade, normalize(intersectionPoint));
worldRayRotatedCorrected = correctForPlanetCurvature(worldRayRotated);
cloudData = getCloudData(worldRayRotatedCorrected, fadeTextureChannels);
vec4 cloudColorCrossFade = vec4(calculateCloudColor(cameraPosition, normalize(-worldRay), cloudData), cloudData.a);
cloudColor = mix(cloudColor, cloudColorCrossFade, crossFadeAnchorFactor);
float totalTransmittance = clamp(cloudColor.a * (1.0 - totalFadeInOut) + totalFadeInOut, 0.0 , 1.0);
if (length(cloudColor.rgb) == 0.0) {
totalTransmittance = 1.0;
}
return vec4(cloudColor.rgb, totalTransmittance);
}`),e.code.add(m`vec4 renderClouds(vec3 worldRay, vec3 cameraPosition)
{
return crossFade ? renderCloudsCrossFade(worldRay, cameraPosition) : renderCloudsNoFade(worldRay, cameraPosition);
}`)}function vc(t,e){t.include(fn,e),t.include(fc),t.include(hc),e.hasCloudsReflections&&t.include(gc,e),e.hasScreenSpaceReflections&&t.include(Wl,e);const r=t.fragment;r.constants.add("fresnelSky","vec3",[.02,1,15]).add("fresnelMaterial","vec2",[.02,.1]).add("roughness","float",.015).add("foamIntensityExternal","float",1.7).add("ssrIntensity","float",.65).add("ssrHeightFadeStart","float",3e5).add("ssrHeightFadeEnd","float",5e5).add("waterDiffusion","float",.92).add("waterSeaColorMod","float",.8).add("correctionViewingPowerFactor","float",.4).add("skyZenitColor","vec3",[.52,.68,.9]).add("skyColor","vec3",[.67,.79,.9]).add("cloudFresnelModifier","vec2",[1.2,.01]),r.code.add(m`PBRShadingWater shadingInfo;
vec3 getSkyGradientColor(in float cosTheta, in vec3 horizon, in vec3 zenit) {
float exponent = pow((1.0 - cosTheta), fresnelSky[2]);
return mix(zenit, horizon, exponent);
}`),r.uniforms.add(new Y("lightingSpecularStrength",(i,s)=>s.lighting.mainLight.specularStrength),new Y("lightingEnvironmentStrength",(i,s)=>s.lighting.mainLight.environmentStrength)),r.code.add(m`vec3 getSeaColor(in vec3 n, in vec3 v, in vec3 l, vec3 color, in vec3 lightIntensity, in vec3 localUp, in float shadow, float foamIntensity, vec3 viewPosition, vec3 position) {
float reflectionHit = 0.0;
float reflectionHitDiffused = 0.0;
vec3 seaWaterColor = linearizeGamma(color);
vec3 h = normalize(l + v);
shadingInfo.NdotL = clamp(dot(n, l), 0.0, 1.0);
shadingInfo.NdotV = clamp(dot(n, v), 0.001, 1.0);
shadingInfo.VdotN = clamp(dot(v, n), 0.001, 1.0);
shadingInfo.NdotH = clamp(dot(n, h), 0.0, 1.0);
shadingInfo.VdotH = clamp(dot(v, h), 0.0, 1.0);
shadingInfo.LdotH = clamp(dot(l, h), 0.0, 1.0);
float upDotV = max(dot(localUp,v), 0.0);
vec3 skyHorizon = linearizeGamma(skyColor);
vec3 skyZenit = linearizeGamma(skyZenitColor);
vec3 skyColor = getSkyGradientColor(upDotV, skyHorizon, skyZenit );
float upDotL = max(dot(localUp,l),0.0);
float daytimeMod = 0.1 + upDotL * 0.9;
skyColor *= daytimeMod;
float shadowModifier = clamp(shadow, 0.8, 1.0);
vec3 fresnelModifier = fresnelReflection(shadingInfo.VdotN, vec3(fresnelSky[0]), fresnelSky[1]);
vec3 reflSky = lightingEnvironmentStrength * fresnelModifier * skyColor * shadowModifier;
vec3 reflSea = seaWaterColor * mix(skyColor, upDotL * lightIntensity * LIGHT_NORMALIZATION, 2.0 / 3.0) * shadowModifier;
vec3 specular = vec3(0.0);
if(upDotV > 0.0 && upDotL > 0.0) {
vec3 specularSun = brdfSpecularWater(shadingInfo, roughness, vec3(fresnelMaterial[0]), fresnelMaterial[1]);
vec3 incidentLight = lightIntensity * LIGHT_NORMALIZATION * shadow;
specular = lightingSpecularStrength * shadingInfo.NdotL * incidentLight * specularSun;
}
vec3 foam = vec3(0.0);
if(upDotV > 0.0) {
foam = foamIntensity2FoamColor(foamIntensityExternal, foamIntensity, skyZenitColor, daytimeMod);
}
float correctionViewingFactor = pow(max(dot(v, localUp), 0.0), correctionViewingPowerFactor);
vec3 normalCorrectedClouds = mix(localUp, n, correctionViewingFactor);
vec3 reflectedWorld = normalize(reflect(-v, normalCorrectedClouds));`),e.hasCloudsReflections&&r.code.add(m`vec4 cloudsColor = renderClouds(reflectedWorld, position);
cloudsColor.a = 1.0 - cloudsColor.a;
cloudsColor = pow(cloudsColor, vec4(GAMMA));
cloudsColor *= clamp(fresnelModifier.y * cloudFresnelModifier[0] - cloudFresnelModifier[1], 0.0, 1.0) * clamp((1.0 - totalFadeInOut), 0.0, 1.0);`),e.hasScreenSpaceReflections?(r.uniforms.add(new $t("view",(i,s)=>s.ssr.camera.viewMatrix),new nt("lastFrameColorTexture",(i,s)=>s.ssr.lastFrameColorTexture),new Y("fadeFactorSSR",(i,s)=>s.ssr.fadeFactor)),r.code.add(m`vec3 viewDir = normalize(viewPosition);
vec4 viewNormalVectorCoordinate = view *vec4(n, 0.0);
vec3 viewNormal = normalize(viewNormalVectorCoordinate.xyz);
vec4 viewUp = view * vec4(localUp, 0.0);
vec3 viewNormalCorrectedSSR = mix(viewUp.xyz, viewNormal, correctionViewingFactor);
vec3 reflected = normalize(reflect(viewDir, viewNormalCorrectedSSR));
vec3 hitCoordinate = screenSpaceIntersection(reflected, viewPosition, viewDir, viewUp.xyz);
vec3 reflectedColor = vec3(0.0);
if (hitCoordinate.z > 0.0)
{
vec2 reprojectedCoordinate = reprojectionCoordinate(hitCoordinate);
vec2 dCoords = smoothstep(0.3, 0.6, abs(vec2(0.5, 0.5) - hitCoordinate.xy));
float heightMod = smoothstep(ssrHeightFadeEnd, ssrHeightFadeStart, -viewPosition.z);
reflectionHit = clamp(1.0 - (1.3 * dCoords.y), 0.0, 1.0) * heightMod * fadeFactorSSR;
reflectionHitDiffused = waterDiffusion * reflectionHit;
reflectedColor = linearizeGamma(texture(lastFrameColorTexture, reprojectedCoordinate).xyz) *
reflectionHitDiffused * fresnelModifier.y * ssrIntensity;
}
float seaColorMod =  mix(waterSeaColorMod, waterSeaColorMod * 0.5, reflectionHitDiffused);
vec3 waterRenderedColor = tonemapACES((1.0 - reflectionHitDiffused) * reflSky + reflectedColor +
reflSea * seaColorMod + specular + foam);`)):r.code.add(m`vec3 waterRenderedColor = tonemapACES(reflSky + reflSea * waterSeaColorMod + specular + foam);`),e.hasCloudsReflections?e.hasScreenSpaceReflections?r.code.add(m`return waterRenderedColor * (1.0 - (1.0 - reflectionHit) * cloudsColor.a) + (1.0 - reflectionHit) * cloudsColor.xyz;
}`):r.code.add(m`return waterRenderedColor * (1.0 - cloudsColor.a) + cloudsColor.xyz;
}`):r.code.add(m`return waterRenderedColor;
}`)}function _c(t){const e=new Si,{vertex:r,fragment:i}=e;Xs(r,t),e.include(mn,t),e.attributes.add(p.POSITION,"vec3"),e.attributes.add(p.UV0,"vec2");const s=new at("waterColor",a=>a.color);if(t.output===E.Color&&t.isDraped)return e.varyings.add("vpos","vec3"),r.uniforms.add(s),r.code.add(m`
        void main(void) {
          if (waterColor.a < ${m.float(Be)}) {
            // Discard this vertex
            gl_Position = vec4(1e38, 1e38, 1e38, 1.0);
            return;
          }

          vpos = position;
          gl_Position = transformPosition(proj, view, vpos);
        }
    `),i.uniforms.add(s),i.code.add(m`void main() {
fragColor = waterColor;
}`),e;switch(t.output!==E.Color&&t.output!==E.Alpha||(e.include(xs,t),e.include(gn,t),e.varyings.add("vuv","vec2"),e.varyings.add("vpos","vec3"),e.varyings.add("vnormal","vec3"),e.varyings.add("vtbnMatrix","mat3"),t.hasMultipassTerrain&&e.varyings.add("depth","float"),r.uniforms.add(s),r.code.add(m`
      void main(void) {
        if (waterColor.a < ${m.float(Be)}) {
          // Discard this vertex
          gl_Position = vec4(1e38, 1e38, 1e38, 1.0);
          return;
        }

        vuv = uv0;
        vpos = position;

        vnormal = getLocalUp(vpos, localOrigin);
        vtbnMatrix = getTBNMatrix(vnormal);

        ${t.hasMultipassTerrain?"depth = (view * vec4(vpos, 1.0)).z;":""}

        gl_Position = transformPosition(proj, view, vpos);
        ${t.output===E.Color?"forwardLinearDepth();":""}
      }
    `)),e.include(Qs,t),t.output){case E.Alpha:e.include(xt,t),i.uniforms.add(s),i.code.add(m`
        void main() {
          discardBySlice(vpos);
          ${t.hasMultipassTerrain?"terrainDepthTest(gl_FragCoord, depth);":""}

          fragColor = vec4(waterColor.a);
        }
      `);break;case E.Color:e.include(_n),e.include(yn,{pbrMode:sa.Disabled,lightingSphericalHarmonicsOrder:2}),e.include(Ss),e.include(xt,t),e.include(wn,t),e.include(vc,t),i.uniforms.add(s,new Y("timeElapsed",a=>a.timeElapsed),r.uniforms.get("view"),r.uniforms.get("localOrigin")),Js(i,t),i.include(Ks),ra(i),ia(i),i.code.add(m`
      void main() {
        discardBySlice(vpos);
        ${t.hasMultipassTerrain?"terrainDepthTest(gl_FragCoord, depth);":""}
        vec3 localUp = vnormal;
        // the created normal is in tangent space
        vec4 tangentNormalFoam = getSurfaceNormalAndFoam(vuv, timeElapsed);

        // we rotate the normal according to the tangent-bitangent-normal-Matrix
        vec3 n = normalize(vtbnMatrix * tangentNormalFoam.xyz);
        vec3 v = -normalize(vpos - cameraPosition);
        float shadow = ${t.receiveShadows?m`1.0 - readShadowMap(vpos, linearDepth)`:"1.0"};
        vec4 vPosView = view * vec4(vpos, 1.0);
        vec4 final = vec4(getSeaColor(n, v, mainLightDirection, waterColor.rgb, mainLightIntensity, localUp, shadow, tangentNormalFoam.w, vPosView.xyz, vpos + localOrigin), waterColor.w);

        // gamma correction
        fragColor = delinearizeGamma(final);
        fragColor = highlightSlice(fragColor, vpos);
        ${t.transparencyPassType===ge.Color?"fragColor = premultiplyAlpha(fragColor);":""}
      }
    `);break;case E.Normal:e.include(xs,t),e.include(Ss,t),e.include(xt,t),e.varyings.add("vpos","vec3"),e.varyings.add("vuv","vec2"),r.uniforms.add(s),r.code.add(m`
        void main(void) {
          if (waterColor.a < ${m.float(Be)}) {
            // Discard this vertex
            gl_Position = vec4(1e38, 1e38, 1e38, 1.0);
            return;
          }

          vuv = uv0;
          vpos = position;

          gl_Position = transformPosition(proj, view, vpos);
        }
    `),i.uniforms.add(new Y("timeElapsed",a=>a.timeElapsed)),i.code.add(m`void main() {
discardBySlice(vpos);
vec4 tangentNormalFoam = getSurfaceNormalAndFoam(vuv, timeElapsed);
tangentNormalFoam.xyz = normalize(tangentNormalFoam.xyz);
fragColor = vec4((tangentNormalFoam.xyz + vec3(1.0)) * 0.5, tangentNormalFoam.w);
}`);break;case E.Highlight:e.include(vn,t),e.varyings.add("vpos","vec3"),r.uniforms.add(s),r.code.add(m`
      void main(void) {
        if (waterColor.a < ${m.float(Be)}) {
          // Discard this vertex
          gl_Position = vec4(1e38, 1e38, 1e38, 1.0);
          return;
        }

        vpos = position;
        gl_Position = transformPosition(proj, view, vpos);
      }
    `),e.include(xt,t),i.code.add(m`void main() {
discardBySlice(vpos);
outputHighlight();
}`);break;case E.ObjectAndLayerIdColor:e.include(Ys,t),e.varyings.add("vpos","vec3"),r.uniforms.add(s),r.code.add(m`
      void main(void) {
        if (waterColor.a < ${m.float(Be)}) {
          // Discard this vertex
          gl_Position = vec4(1e38, 1e38, 1e38, 1.0);
          return;
        }

        vpos = position;
        gl_Position = transformPosition(proj, view, vpos);
        forwardObjectAndLayerIdColor();
      }
    `),e.include(xt,t),i.code.add(m`void main() {
discardBySlice(vpos);
outputObjectAndLayerIdColor();
}`)}return e}const yc=Object.freeze(Object.defineProperty({__proto__:null,build:_c},Symbol.toStringTag,{value:"Module"}));let xa=class Ra extends Ci{initializeConfiguration(e,r){r.spherical=e.viewingMode===Xt.Global,r.doublePrecisionRequiresObfuscation=e.rctx.driverTest.doublePrecisionRequiresObfuscation.result}initializeProgram(e){return new bi(e.rctx,Ra.shader.get().build(this.configuration),qs)}_setPipelineState(e){const r=this.configuration,i=e===ge.NONE,s=e===ge.FrontFace;return tt({blending:r.output!==E.Normal&&r.output!==E.Highlight&&r.output!==E.ObjectAndLayerIdColor&&r.transparent?i?vr:la(e):null,depthTest:{func:ca(e)},depthWrite:i?r.writeDepth?da:null:ha(e),colorWrite:Ot,polygonOffset:i||s?null:Gn(r.enableOffset)})}initializePipeline(){return this._setPipelineState(this.configuration.transparencyPassType)}};xa.shader=new Oi(yc,()=>_i(()=>import("./WaterSurface.glsl-6ae10f9a.js"),["./WaterSurface.glsl-6ae10f9a.js","./FloatArray-73ba570e.js","./index-4457faad.js","..\\index-add6cbc1.css","./requestImageUtils-a82830fa.js","./basicInterfaces-bb952591.js","./enums-b14466b3.js","./Texture-53149a07.js","./Indices-836a5a9a.js","./triangle-6e9991e3.js","./doublePrecisionUtils-e3c3d0d8.js","./BufferView-eb3bc1bb.js","./VertexElementDescriptor-2925c6af.js","./VertexArrayObject-79e51137.js","./OrderIndependentTransparency-2a607a9a.js","./DoubleArray-28266794.js","./hydratedFeatures-1f5e8f4b.js","./triangulationUtils-2852bf6d.js","./earcut-938ec344.js","./deduplicate-34be5e74.js","./NestedMap-1b5db22e.js","./Octree-30686065.js","./InterleavedLayout-2de7b1c4.js","./types-1305598a.js","./floatRGBA-45eb4edf.js","./glUtil-0b7ee6ea.js"],import.meta.url));let X=class extends xi{constructor(){super(...arguments),this.output=E.Color,this.transparencyPassType=ge.NONE,this.spherical=!1,this.receiveShadows=!1,this.hasSlicePlane=!1,this.transparent=!1,this.enableOffset=!0,this.writeDepth=!1,this.hasScreenSpaceReflections=!1,this.doublePrecisionRequiresObfuscation=!1,this.hasCloudsReflections=!1,this.objectAndLayerIdColorInstanced=!1,this.isDraped=!1,this.hasMultipassTerrain=!1,this.cullAboveGround=!1}};v([O({count:E.COUNT})],X.prototype,"output",void 0),v([O({count:ge.COUNT})],X.prototype,"transparencyPassType",void 0),v([O()],X.prototype,"spherical",void 0),v([O()],X.prototype,"receiveShadows",void 0),v([O()],X.prototype,"hasSlicePlane",void 0),v([O()],X.prototype,"transparent",void 0),v([O()],X.prototype,"enableOffset",void 0),v([O()],X.prototype,"writeDepth",void 0),v([O()],X.prototype,"hasScreenSpaceReflections",void 0),v([O()],X.prototype,"doublePrecisionRequiresObfuscation",void 0),v([O()],X.prototype,"hasCloudsReflections",void 0),v([O()],X.prototype,"objectAndLayerIdColorInstanced",void 0),v([O()],X.prototype,"isDraped",void 0),v([O()],X.prototype,"hasMultipassTerrain",void 0),v([O()],X.prototype,"cullAboveGround",void 0),v([O({constValue:sa.Water})],X.prototype,"pbrMode",void 0),v([O({constValue:!0})],X.prototype,"useCustomDTRExponentForWater",void 0),v([O({constValue:!0})],X.prototype,"highStepCount",void 0),v([O({constValue:!1})],X.prototype,"useFillLights",void 0);let wc=class extends ea{_updateShadowState(e){e.shadowMap.enabled!==this._material.parameters.receiveShadows&&this._material.setParameters({receiveShadows:e.shadowMap.enabled})}_updateSSRState(e){e.ssr.enabled!==this._material.parameters.hasScreenSpaceReflections&&this._material.setParameters({hasScreenSpaceReflections:e.ssr.enabled})}_updateCloudsReflectionState(e){const r=e.cloudsFade.data!=null;r!==this._material.parameters.hasCloudsReflections&&this._material.setParameters({hasCloudsReflections:r})}ensureResources(e){return this._techniqueRepository.constructionContext.waterTextureRepository.ensureResources(e)}beginSlot(e){return this._output===E.Color&&(this._updateShadowState(e),this._updateSSRState(e),this._updateCloudsReflectionState(e)),this._material.setParameters(this._techniqueRepository.constructionContext.waterTextureRepository.passParameters),this.ensureTechnique(xa,e)}},Tc=class extends cc{constructor(e){super(e,new Sc),this._configuration=new X,this.animation=new Zn}getConfiguration(e,r){return this._configuration.output=e,this._configuration.writeDepth=this.parameters.writeDepth,this._configuration.receiveShadows=this.parameters.receiveShadows,this._configuration.hasSlicePlane=this.parameters.hasSlicePlane,this._configuration.transparent=this.parameters.transparent,this._configuration.hasScreenSpaceReflections=this.parameters.hasScreenSpaceReflections,this._configuration.hasCloudsReflections=this.parameters.hasCloudsReflections,this._configuration.isDraped=this.parameters.isDraped,this._configuration.transparencyPassType=r.transparencyPassType,this._configuration.enableOffset=r.camera.relativeElevation<Bn,this._configuration.hasMultipassTerrain=r.multipassTerrain.enabled,this._configuration.cullAboveGround=r.multipassTerrain.cullAboveGround,this._configuration}update(e){const r=Math.min(e.camera.relativeElevation,e.camera.distance);this.animation.enabled=Math.sqrt(this.parameters.waveTextureRepeat/this.parameters.waveStrength)*r<xc;const i=this.animation.advance(e);return this.setParameters({timeElapsed:oo(this.animation.time)*this.parameters.animationSpeed},!1),this.animation.enabled&&i}requiresSlot(e,r){switch(r){case E.Normal:return e===J.DRAPED_WATER;case E.Color:if(this.parameters.isDraped)return e===J.DRAPED_MATERIAL;break;case E.Alpha:break;case E.Highlight:case E.ObjectAndLayerIdColor:return e===J.OPAQUE_MATERIAL||e===J.DRAPED_MATERIAL;default:return!1}let i=J.OPAQUE_MATERIAL;return this.parameters.transparent&&(i=this.parameters.writeDepth?J.TRANSPARENT_MATERIAL:J.TRANSPARENT_DEPTH_WRITE_DISABLED_MATERIAL),e===i}createGLMaterial(e){return new wc(e)}createBufferWriter(){return new Tn(it("enable-feature:objectAndLayerId-rendering")?lc:nc)}},Sc=class extends no{constructor(){super(...arguments),this.waveStrength=.06,this.waveTextureRepeat=32,this.waveDirection=Vs(1,0),this.waveVelocity=.05,this.flowStrength=.015,this.flowOffset=-.5,this.animationSpeed=.35,this.timeElapsed=0,this.color=kt(0,0,0,0),this.transparent=!0,this.writeDepth=!0,this.hasSlicePlane=!1,this.isDraped=!1,this.receiveShadows=!0,this.hasScreenSpaceReflections=!1,this.hasCloudsReflections=!1,this.origin=N(),this.modelTransformation=null}};const xc=35e3;let Ai=class{constructor(e=0,r=0){this.from=e,this.to=r}get numElements(){return this.to-this.from}};function Rs(t){const e=new Map;t.forAll(i=>e.set(i.from,i));let r=!0;for(;r;)r=!1,t.forEach(i=>{const s=e.get(i.to);s&&(i.to=s.to,e.delete(s.from),t.removeUnordered(s),r=!0)})}let Cs=class extends Ai{constructor(e,r,i){super(r,i),this.geometry=e}get isVisible(){return this.geometry.visible}get hasHighlights(){return this.geometry.highlights!=null&&this.isVisible}get hasOccludees(){return this.geometry.occludees!=null}},Rc=class{constructor(){this.first=0,this.count=0}},Cc=class{constructor(){this._numElements=0,this._instances=new Map,this.holes=new Me({allocator:e=>e||new Ai,deallocator:null}),this.hasHiddenInstances=!1,this.hasHighlights=!1,this.hasOccludees=!1,this.drawCommandsDirty=!0,this.drawCommandsDefault=lr(),this.drawCommandsHighlight=lr(),this.drawCommandsOccludees=lr(),this.drawCommandsShadowHighlightRest=lr()}get numElements(){return this._numElements}get instances(){return this._instances}addInstance(e,r){this.deleteInstance(e),this._instances.set(e,r),this._numElements+=r.numElements}deleteInstance(e){const r=this._instances.get(e);r&&(this._numElements-=r.numElements,this._instances.delete(e))}updateInstance(e,r,i){const s=this._instances.get(e);s&&(this._numElements-=s.numElements,s.from=r,s.to=i,this._numElements+=s.numElements)}updateDrawState(e){e.isVisible?(e.hasHighlights&&(this.hasHighlights=!0),e.hasOccludees&&(this.hasOccludees=!0)):this.hasHiddenInstances=!0}updateDrawCommands(e){if(this.drawCommandsDefault.clear(),this.drawCommandsHighlight.clear(),this.drawCommandsOccludees.clear(),this.drawCommandsShadowHighlightRest.clear(),this.drawCommandsDirty=!1,this._instances.size===0)return;if(!this.needsMultipleCommands()){const i=this.drawCommandsDefault.pushNew(),s=this.holes.front();return this.vao!=null&&this.holes.length===1&&s.to===Math.floor(this.vao.byteSize/e)?(i.first=0,void(i.count=s.from)):(i.first=1/0,i.count=0,this._instances.forEach(a=>{i.first=Math.min(i.first,a.from),i.count=Math.max(i.count,a.to)}),void(i.count-=i.first))}const r=Array.from(this._instances.values()).sort((i,s)=>i.from===s.from?i.to-s.to:i.from-s.from);for(const i of r)i.isVisible&&(bs(i.hasOccludees?this.drawCommandsOccludees:this.drawCommandsDefault,i),bs(i.hasHighlights?this.drawCommandsHighlight:this.drawCommandsShadowHighlightRest,i))}needsMultipleCommands(){return this.hasOccludees||this.hasHighlights||this.hasHiddenInstances}};function bc(t){return t.vao!=null}function lr(){return new Me({allocator:t=>t||new Rc,deallocator:t=>t})}function bs(t,e){const r=t.back();if(r==null){const i=t.pushNew();return i.first=e.from,void(i.count=e.numElements)}if(Oc(r,e)){const i=e.from-r.first+e.numElements;r.count=i}else{const i=t.pushNew();i.first=e.from,i.count=e.numElements}}function Oc(t,e){return t.first+t.count>=e.from}let Dc=class{constructor(e){this.origin=e,this.buffers=new Array}dispose(){this.buffers.forEach(e=>e.vao.dispose()),this.buffers.length=0}findBuffer(e){return this.buffers.find(r=>r.instances.has(e))}};const Ac=co+1;let Ec=class{constructor(e,r,i){this._rctx=e,this._locations=r,this._layout=i,this._cache=e.newCache("VaoCache",Ic)}dispose(){this._cache.destroy()}newVao(e){const r=e.toString(),i=this._cache.pop(r);if(i!=null){const a=i.pop();return i.length>0&&this._cache.put(r,i,e*i.length,Ac),a}const s=new Sn(this._rctx,this._locations,{geometry:this._layout},{geometry:Fn.createVertex(this._rctx,Mn.STATIC_DRAW)});return s.vertexBuffers.geometry.setSize(e),s}deleteVao(e){if(e==null)return null;const r=e.byteSize,i=r.toString(),s=this._cache.pop(i);return s!=null?(s.push(e),this._cache.put(i,s,r*s.length,-1)):this._cache.put(i,[e],r,-1),null}};function Ic(t,e){if(e===lo.ALL)return void t.forEach(s=>s.dispose());const r=t.pop(),i=t.length*r.byteSize;return r.dispose(),i}let Pc=class{constructor(e,r,i){this._rctx=e,this._materialRepository=r,this.material=i,this._dataByOrigin=new Map,this._hasHighlights=!1,this._hasOccludees=!1,this._glMaterials=new ac(this.material,this._materialRepository),this._bufferWriter=i.createBufferWriter(),this._vaoCache=new Ec(e,i.vertexAttributeLocations,qn(this._bufferWriter.vertexBufferLayout))}dispose(){this._glMaterials.destroy(),this._dataByOrigin.forEach(e=>e.dispose()),this._dataByOrigin.clear(),this._vaoCache.dispose()}get isEmpty(){return this._dataByOrigin.size===0}get hasHighlights(){return this._hasHighlights}get hasOccludees(){return this._hasOccludees}get hasWater(){return!this.isEmpty&&this.material instanceof Tc}get rendersOccluded(){return!this.isEmpty&&this.material.renderOccluded!==st.Occlude}get numGeometries(){let e=0;return this._dataByOrigin.forEach(r=>e+=r.buffers.reduce((i,s)=>i+s.instances.size,0)),e}forEachGeometry(e){this._dataByOrigin.forEach(r=>r.buffers.forEach(i=>i.instances.forEach(s=>e(s.geometry))))}modify(e){this._updateGeometries(e.updates),this._addAndRemoveGeometries(e.adds,e.removes),this._updateDrawCommands()}_updateGeometries(e){const r=this._bufferWriter,i=r.vertexBufferLayout.stride/4;for(const s of e){const a=s.renderGeometry,o=this._dataByOrigin.get(a.localOrigin.id),n=o==null?void 0:o.findBuffer(a.id);if(n==null)return;const l=n.instances.get(a.id);if(s.updateType&($e.GEOMETRY|$e.TRANSFORMATION)){const c=ur(r.elementCount(l.geometry.geometry)*i),d=r.vertexBufferLayout.createView(c.buffer);this._writeGeometry(a,d,0),n.vao.vertexBuffers.geometry.setSubData(c,l.from*i,0,l.numElements*i),pr()}s.updateType&($e.HIGHLIGHT|$e.OCCLUDEE|$e.VISIBILITY)&&(n.drawCommandsDirty=!0)}}_computeDeltas(e,r){const i=new Di;for(const s of e){const a=s.localOrigin;if(a==null)continue;let o=i.get(a.id,null);o==null&&(o=new Os(a.vec3),i.set(a.id,null,o)),o.changes.push(s)}for(const s of r){const a=s.localOrigin;if(a==null)continue;const o=this._dataByOrigin.get(a.id),n=o==null?void 0:o.findBuffer(s.id);if(n==null)continue;let l=i.get(a.id,n);l==null&&(l=new Os(a.vec3),i.set(a.id,n,l)),l.changes.push(s)}return i}_addAndRemoveGeometries(e,r){const{_bufferWriter:i,_dataByOrigin:s}=this,a=i.vertexBufferLayout.stride/4,o=this._computeDeltas(e,r);o.forEach((n,l)=>{const c=n.get(null),d=c!=null?c.changes:[];o.delete(l,null);let u=s.get(l);if(n.forEach((f,h)=>{if(o.delete(l,h),h==null)return void pe(!1,"No VAO for removed geometries");if(h.instances.size===f.changes.length)return this._vaoCache.deleteVao(h.vao),ji(u.buffers,h),void(u.buffers.length===0&&d.length===0&&s.delete(l));const g=h.numElements,T=h.vao.byteSize/4,w=d.reduce((D,y)=>D+i.elementCount(y.geometry),0),b=f.changes.reduce((D,y)=>D+i.elementCount(y.geometry),0),S=Math.min((g+w-b)*a,hr),_=S>T;S>Lr&&S<T/2?(f.changes.forEach(({id:D})=>h.deleteInstance(D)),h.instances.forEach(({geometry:D})=>d.push(D)),this._vaoCache.deleteVao(h.vao),ji(u.buffers,h)):_?this._applyAndRebuild(h,d,f):this._applyRemoves(h,f)}),d.length>0)for(u==null&&(u=new Dc(c.origin),s.set(l,u)),u.buffers.forEach(f=>this._applyAdds(f,d));d.length>0;)u.buffers.push(this._applyAndRebuild(new Cc,d,null))})}_updateDrawCommands(){this._hasHighlights=!1,this._hasOccludees=!1,this._dataByOrigin.forEach(e=>{e.buffers.forEach(r=>{r.drawCommandsDirty&&(r.hasHiddenInstances=!1,r.hasHighlights=!1,r.hasOccludees=!1,Ue(r.instances,i=>(r.updateDrawState(i),r.hasHiddenInstances&&r.hasHighlights&&r.hasOccludees)),r.updateDrawCommands(this._bufferWriter.vertexBufferLayout.stride)),this._hasHighlights=this._hasHighlights||r.hasHighlights,this._hasOccludees=this._hasOccludees||r.hasOccludees})})}_applyAndRebuild(e,r,i){if(i!=null)for(const g of i.changes)e.deleteInstance(g.id);const s=this._bufferWriter,a=s.vertexBufferLayout.stride,o=a/4,n=Math.floor(hr/o);let l=e.numElements;for(;r.length>0;){const g=r.pop(),T=s.elementCount(g.geometry);if(l+T>n&&l>0){r.push(g);break}l+=T;const w=new Cs(g,0,0);pe(e.instances.get(g.id)==null),e.addInstance(g.id,w)}const c=l*o,d=ur(c),u=s.vertexBufferLayout.createView(d.buffer);let f=0;e.hasHiddenInstances=!1,e.hasHighlights=!1,e.hasOccludees=!1,e.instances.forEach((g,T)=>{this._writeGeometry(g.geometry,u,f);const w=f;f+=s.elementCount(g.geometry.geometry),e.updateInstance(T,w,f),e.updateDrawState(g)}),this._vaoCache.deleteVao(e.vao),e.vao=this._vaoCache.newVao(Es(c)),e.vao.vertexBuffers.geometry.setSubData(d,0,0,f*o),pr(),e.holes.clear();const h=e.holes.pushNew();return h.from=f,h.to=Math.floor(e.vao.byteSize/a),e.updateDrawCommands(a),e}_applyRemoves(e,r){if(r.changes.length===0)return;for(const n of r.changes){const l=n.id,c=e.instances.get(l);if(!c)continue;e.deleteInstance(l);const d=Pe.back();if(d){if(d.to===c.from){d.to=c.to;continue}if(d.from===c.to){d.from=c.from;continue}}const u=Pe.pushNew();u.from=c.from,u.to=c.to}Rs(Pe);const i=this._bufferWriter.vertexBufferLayout.stride/4,s=Pe.reduce((n,l)=>Math.max(n,l.numElements),0)*i,a=ur(s);a.fill(0,0,s);const o=e.vao.vertexBuffers.geometry;Pe.forAll(n=>o.setSubData(a,n.from*i,0,n.numElements*i)),pr(),e.holes.pushArray(Pe.data,Pe.length),Pe.forAll((n,l)=>Pe.data[l]=null),Pe.clear(),e.drawCommandsDirty=!0}_applyAdds(e,r){if(r.length===0)return;if(!bc(e))return void this._applyAndRebuild(e,r,null);const i=this._bufferWriter,s=i.vertexBufferLayout.stride/4,a=e.numElements,o=r.reduce((b,S)=>b+i.elementCount(S.geometry),0),n=Math.min((a+o)*s,hr),l=4*n;if(e.vao.byteSize<Es(hr-Lr)&&l>e.vao.byteSize)return void this._applyAndRebuild(e,r,null);Rs(e.holes);const c=new Array;for(const b of r){const S=i.elementCount(b.geometry),_=$c(e.holes,S);c.push(_)}const d=e.vao.vertexBuffers.geometry;let u=0,f=0,h=0;const g=ur(n),T=i.vertexBufferLayout.createView(g.buffer);r.forEach((b,S)=>{const _=c[S];if(_==null)return;if(h!==_){const x=h-f;x>0&&d.setSubData(g,f*s,0,x*s),f=_,u=0}const D=i.elementCount(b.geometry);this._writeGeometry(b,T,u),u+=D,h=_+D;const y=new Cs(b,_,_+D);pe(e.instances.get(b.id)==null),e.addInstance(b.id,y),e.drawCommandsDirty=!0});const w=h-f;w>0&&d.setSubData(g,f*s,0,w*s),ho(r,(b,S)=>c[S]==null),pr()}_writeGeometry(e,r,i){const s=e.localOrigin.vec3;uo(Ds,-s[0],-s[1],-s[2]);const a=ot(Mc,Ds,e.transformation);Vt(cr,a),Hs(cr,cr),this._bufferWriter.write(a,cr,e.geometry,r,i)}updateAnimation(e){return this.material.update(e)}requiresSlot(e,r){return this.material.requiresSlot(e,r)}prepareTechnique(e){const{output:r,bindParameters:i}=e;if(!this.requiresSlot(i.slot,r))return null;const s=r===E.Highlight||r===E.ShadowHighlight;if(s&&!this._hasHighlights)return null;const a=r===E.ShadowExcludeHighlight,o=!(s||a);for(const n of this._dataByOrigin.values())for(const l of n.buffers){if(s&&!l.hasHighlights)continue;const c=(s?l.drawCommandsHighlight:a&&l.needsMultipleCommands()?l.drawCommandsShadowHighlightRest:l.drawCommandsDefault)||null,d=o&&l.drawCommandsOccludees||null;if(c!=null&&c.length||d!=null&&d.length){const u=this._glMaterials.load(e.rctx,i.slot,r),f=u!=null?u.beginSlot(i):null;if(f!=null)return f}}return null}render(e,r){var c;const{output:i,bindParameters:s}=e,a=i===E.Highlight||i===E.ShadowHighlight,o=i===E.ShadowExcludeHighlight,n=!(a||o),l=this._rctx;(c=l.appleAmdDriverHelper)==null||c.resetIndicesType(),l.bindTechnique(r,this.material.parameters,s);for(const d of this._dataByOrigin.values())for(const u of d.buffers){if(a&&!u.hasHighlights)continue;const f=(a?u.drawCommandsHighlight:o&&u.needsMultipleCommands()?u.drawCommandsShadowHighlightRest:u.drawCommandsDefault)||null,h=n&&u.drawCommandsOccludees||null;(f!=null&&f.length||h!=null&&h.length)&&(r.program.bindDraw(new oc(d.origin),s,this.material.parameters),r.ensureAttributeLocations(u.vao),l.bindVAO(u.vao),f!=null&&f.length&&(r.bindPipelineState(l,s.slot,!1),f.forAll(g=>l.drawArrays(r.primitiveType,g.first,g.count))),h!=null&&h.length&&(r.bindPipelineState(l,s.slot,!0),h.forAll(g=>l.drawArrays(r.primitiveType,g.first,g.count))))}}get test(){return{material:this.material,glMaterials:this._glMaterials,dataByOrigin:this._dataByOrigin}}},Os=class{constructor(e){this.origin=e,this.changes=new Array}};function $c(t,e){let r;if(!t.some(s=>!(s.numElements<e)&&(r=s,!0)))return null;const i=r.from;return r.from+=e,r.from>=r.to&&t.removeUnordered(r),i}const Ds=W(),Mc=W(),cr=W(),Pe=new Me({allocator:t=>t||new Ai,deallocator:null}),Lr=65536,dr=4*Lr,As=1024,Ca=16777216,hr=Ca/4;let _r=new Float32Array(Lr);function ur(t){return _r.length<t&&(_r=new Float32Array(t)),_r}function Es(t){const e=4*t;return e<=As?As:e<dr?dr:Math.max(Math.min(Math.ceil(1.5*e/dr)*dr,Ca),e)}function pr(){_r=new Float32Array(2)}let xe=class extends gi{constructor(e){super(e),this._pending=new Lc,this._changes=new tc,this._materialRenderers=new Map,this._sortedMaterialRenderers=new Me,this._geometries=new Map,this._hasHighlights=!1,this._hasWater=!1}destroy(){this._changes.prune(),this._materialRenderers.forEach(e=>e.dispose()),this._materialRenderers.clear(),this._sortedMaterialRenderers.clear(),this._geometries.clear(),this._pending.clear()}get updating(){return!this._pending.empty||this._changes.updates.length>0}get rctx(){return this.rendererContext.rctx}get _materialRepository(){return this.rendererContext.materialRepository}get _localOriginFactory(){return this.rendererContext.localOriginFactory}get hasHighlights(){return this._hasHighlights}get hasWater(){return this._hasWater}get rendersOccluded(){return Ue(this._materialRenderers,e=>e.rendersOccluded)}get isEmpty(){return!this.updating&&this._materialRenderers.size===0&&this._geometries.size===0}commitChanges(){if(!this.updating)return!1;this._processAddsRemoves();const e=sc(this._changes);let r=!1,i=!1,s=!1;return e.forEach((a,o)=>{let n=this._materialRenderers.get(o);if(!n&&a.adds.length>0&&(n=new Pc(this.rctx,this._materialRepository,o),this._materialRenderers.set(o,n),r=!0,i=!0,s=!0),!n)return;const l=i||n.hasHighlights,c=s||n.hasWater;n.modify(a),i=i||l!==n.hasHighlights,s=s||c!==n.hasWater,n.isEmpty&&(this._materialRenderers.delete(o),n.dispose(),r=!0)}),this._changes.clear(),r&&this._updateSortedMaterialRenderers(),i&&(this._hasHighlights=Ue(this._materialRenderers,a=>a.hasHighlights)),s&&(this._hasWater=Ue(this._materialRenderers,a=>a.hasWater)),this.notifyChange("updating"),!0}addGeometries(e,r){if(e.length===0)return;const i=this._validateRenderGeometries(e);for(const a of i)this._geometries.set(a.id,a);const s=this._pending.empty;for(const a of i)this._pending.adds.add(a);s&&this.notifyChange("updating"),r===Er.UPDATE&&this._notifyGraphicGeometryChanged(e)}removeGeometries(e,r){const i=this._pending.empty,s=this._pending.adds;for(const a of e)s.has(a)?(this._pending.removed.add(a),s.delete(a)):this._pending.removed.has(a)||this._pending.removes.add(a),this._geometries.delete(a.id);i&&!this._pending.empty&&this.notifyChange("updating"),r===Er.UPDATE&&this._notifyGraphicGeometryChanged(e)}modifyGeometries(e,r){const i=this._changes.updates.length===0;for(const s of e){const a=this._changes.updates.pushNew();a.renderGeometry=this._validateRenderGeometry(s),a.updateType=r}switch(i&&this._changes.updates.length>0&&this.notifyChange("updating"),r){case $e.TRANSFORMATION:case $e.GEOMETRY:return this._notifyGraphicGeometryChanged(e);case $e.VISIBILITY:return this._notifyGraphicVisibilityChanged(e)}}updateAnimation(e){let r=!1;return this._sortedMaterialRenderers.forAll(i=>r=i.updateAnimation(e)||r),r}render(e){this._sortedMaterialRenderers.forAll(r=>{if(r.material.shouldRender(e)){const i=r.prepareTechnique(e);i!=null&&r.render(e,i)}})}intersect(e,r,i,s,a){return this._geometries.forEach(o=>{if(s&&!s(o))return;this._intersectRenderGeometry(o,i,r,0,e,a);const n=this.rendererContext.longitudeCyclical;n&&(o.boundingSphere[0]-o.boundingSphere[3]<n.min&&this._intersectRenderGeometry(o,i,r,n.range,e,a),o.boundingSphere[0]+o.boundingSphere[3]>n.max&&this._intersectRenderGeometry(o,i,r,-n.range,e,a)),a++}),a}_updateSortedMaterialRenderers(){this._sortedMaterialRenderers.clear();let e=0;this._materialRenderers.forEach((r,i)=>{i.insertOrder=e++,this._sortedMaterialRenderers.push(r)}),this._sortedMaterialRenderers.sort((r,i)=>{const s=i.material.renderPriority-r.material.renderPriority;return s!==0?s:r.material.insertOrder-i.material.insertOrder})}_processAddsRemoves(){this._changes.adds.clear(),this._changes.removes.clear(),this._changes.adds.pushArray(Array.from(this._pending.adds)),this._changes.removes.pushArray(Array.from(this._pending.removes));for(let e=0;e<this._changes.updates.length;){const r=this._changes.updates.data[e];this._pending.has(r.renderGeometry)?this._changes.updates.removeUnorderedIndex(e):e++}this._pending.clear()}_intersectRenderGeometry(e,r,i,s,a,o){if(!e.visible)return;let n=0;s+=e.transformation[12],n=e.transformation[13],ii[0]=i[0]-s,ii[1]=i[1]-n,e.screenToWorldRatio=this.rendererContext.screenToWorldRatio,e.material.intersectDraped(e,null,a,ii,(l,c,d)=>{Fc(r,d,e.material.renderPriority,o,a,e.layerUid,e.graphicUid)},r)}_notifyGraphicGeometryChanged(e){if(this.drapeSource.notifyGraphicGeometryChanged==null)return;let r;for(const i of e){const s=i.graphicUid;s!=null&&s!==r&&(this.drapeSource.notifyGraphicGeometryChanged(s),r=s)}}_notifyGraphicVisibilityChanged(e){if(this.drapeSource.notifyGraphicVisibilityChanged==null)return;let r;for(const i of e){const s=i.graphicUid;s!=null&&s!==r&&(this.drapeSource.notifyGraphicVisibilityChanged(s),r=s)}}_validateRenderGeometries(e){for(const r of e)this._validateRenderGeometry(r);return e}_validateRenderGeometry(e){return e.localOrigin==null&&(e.localOrigin=this._localOriginFactory.getOrigin(e.boundingSphere)),e}get test(){return{sortedMaterialRenderers:this._sortedMaterialRenderers}}};v([$()],xe.prototype,"drapeSource",void 0),v([$()],xe.prototype,"updating",null),v([$()],xe.prototype,"rctx",null),v([$()],xe.prototype,"rendererContext",void 0),v([$()],xe.prototype,"_materialRepository",null),v([$()],xe.prototype,"_localOriginFactory",null),v([$({readOnly:!0})],xe.prototype,"isEmpty",null),v([$()],xe.prototype,"_materialRenderers",void 0),v([$()],xe.prototype,"_geometries",void 0),xe=v([zr("esri.views.3d.webgl-engine.lib.SortedRenderGeometryRenderer")],xe);let Lc=class{constructor(){this.adds=new Set,this.removes=new Set,this.removed=new Set}get empty(){return this.adds.size===0&&this.removes.size===0&&this.removed.size===0}has(e){return this.adds.has(e)||this.removes.has(e)||this.removed.has(e)}clear(){this.adds.clear(),this.removes.clear(),this.removed.clear()}};function Fc(t,e,r,i,s,a,o){const n=new po(a,o,e),l=c=>{c.set(mo.OVERLAY,n,t.dist,t.normal,t.transformation,r,i)};if((s.results.min.drapedLayerOrder==null||r>=s.results.min.drapedLayerOrder)&&(s.results.min.dist==null||s.results.ground.dist<=s.results.min.dist)&&l(s.results.min),s.options.store!==Ui.MIN&&(s.results.max.drapedLayerOrder==null||r<s.results.max.drapedLayerOrder)&&(s.results.max.dist==null||s.results.ground.dist>s.results.max.dist)&&l(s.results.max),s.options.store===Ui.ALL){const c=fo(s.ray);l(c),s.results.all.push(c)}}const ii=q();let ba=class Oa extends Ci{initializeProgram(e){return new bi(e.rctx,Oa.shader.get().build(),qs)}initializePipeline(){return this.configuration.hasAlpha?tt({blending:kn(ir.SRC_ALPHA,ir.ONE,ir.ONE_MINUS_SRC_ALPHA,ir.ONE_MINUS_SRC_ALPHA),colorWrite:Ot}):tt({colorWrite:Ot})}};ba.shader=new Oi(il,()=>_i(()=>import("./TextureOnly.glsl-5b77bb75.js"),["./TextureOnly.glsl-5b77bb75.js","./index-4457faad.js","..\\index-add6cbc1.css","./FloatArray-73ba570e.js","./requestImageUtils-a82830fa.js","./basicInterfaces-bb952591.js","./enums-b14466b3.js","./Texture-53149a07.js","./Indices-836a5a9a.js","./triangle-6e9991e3.js","./doublePrecisionUtils-e3c3d0d8.js","./BufferView-eb3bc1bb.js","./VertexElementDescriptor-2925c6af.js","./VertexArrayObject-79e51137.js","./OrderIndependentTransparency-2a607a9a.js","./DoubleArray-28266794.js","./hydratedFeatures-1f5e8f4b.js","./triangulationUtils-2852bf6d.js","./earcut-938ec344.js","./deduplicate-34be5e74.js","./NestedMap-1b5db22e.js","./Octree-30686065.js","./InterleavedLayout-2de7b1c4.js","./types-1305598a.js","./floatRGBA-45eb4edf.js","./glUtil-0b7ee6ea.js"],import.meta.url));let Da=class extends Zs{constructor(){super(...arguments),this.hasAlpha=!1}};v([O()],Da.prototype,"hasAlpha",void 0);let Ne=class extends gi{get _bindParameters(){return this._renderContext.bindParameters}get _rctx(){return this.view._stage.renderView.renderingContext}get rctx(){return this._rctx}get materialRepository(){return this._materialRepository}get screenToWorldRatio(){return this._screenToWorldRatio}get localOriginFactory(){return this._localOriginFactory}constructor(t){super(t),this._overlays=null,this._overlayRenderTarget=null,this._hasHighlights=!1,this._rendersOccluded=!1,this._hasWater=!1,this._handles=new js,this._renderers=new Map,this._sortedDrapeSourceRenderersDirty=!1,this._sortedRenderers=new Me,this._passParameters=new fa,this._materialRepository=null,this._screenToWorldRatio=1,this._localOriginFactory=null,this._camera=new F,this.worldToPCSRatio=1,this.events=new zs,this.longitudeCyclical=null}initialize(){const t=this.view._stage.renderView,{waterTextureRepository:e,stippleTextureRepository:r,markerTextureRepository:i}=t;this._shaderTechniqueRepository=new sl({rctx:this._rctx,viewingMode:Xt.Local,stippleTextureRepository:r,markerTextureRepository:i,waterTextureRepository:e}),this._renderContext=new kl(this._rctx,new Jl(this._rctx,this.view.state.viewingMode),new xn(this.view,this._shaderTechniqueRepository,this._rctx,()=>{})),this._handles.add([Hr(()=>e.updating,()=>this.events.emit("content-changed"),Vi),Hr(()=>this.spatialReference,s=>this._localOriginFactory=new Ul(s),Vi),go(()=>this.view.allLayerViews,"after-changes",()=>this._sortedDrapeSourceRenderersDirty=!0)]),this._materialRepository=new hl(t.textureRepository,this._shaderTechniqueRepository,s=>{(s.renderOccluded&Is)>0!==this._rendersOccluded&&this._updateRendersOccluded(),this.events.emit("content-changed"),this.notifyChange("updating"),this.notifyChange("isEmpty")},()=>this.events.emit("content-changed")),this._bindParameters.slot=J.DRAPED_MATERIAL,this._bindParameters.highlightDepthTexture=Rn(this._rctx),this._camera.near=1,this._camera.far=1e4,this._camera.relativeElevation=null,this._bindParameters.camera=this._camera,this._bindParameters.transparencyPassType=ge.NONE,this._bindParameters.newLighting.noonFactor=0,this._bindParameters.newLighting.globalFactor=0,this._bindParameters.newLighting.set([new Cn(li(1,1,1))]),this._handles.add(this.view.resourceController.scheduler.registerTask(vo.STAGE,this))}destroy(){this._handles.destroy(),this._renderers.forEach(t=>t.destroy()),this._renderers.clear(),this._debugTextureTechnique=_o(this._debugTextureTechnique),this._passParameters.texture=je(this._passParameters.texture),this._bindParameters.highlightDepthTexture=je(this._bindParameters.highlightDepthTexture),this._shaderTechniqueRepository=Us(this._shaderTechniqueRepository),this._temporaryFBO=je(this._temporaryFBO),this._quadVAO=je(this._quadVAO),this.disposeOverlays()}get updating(){return this._sortedDrapeSourceRenderersDirty||Ue(this._renderers,t=>t.updating)}get hasOverlays(){return this._overlays!=null&&this._overlayRenderTarget!=null}get gpuMemoryUsage(){return this._overlayRenderTarget!=null?this._overlayRenderTarget.gpuMemoryUsage:0}createGeometryDrapeSourceRenderer(t){return this.createDrapeSourceRenderer(t,xe)}createDrapeSourceRenderer(t,e,r){const i=this._renderers.get(t);i!=null&&i.destroy();const s=new e({...r,rendererContext:this,drapeSource:t});return this._renderers.set(t,s),this._sortedDrapeSourceRenderersDirty=!0,"fullOpacity"in t&&this._handles.add(Hr(()=>t.fullOpacity,()=>this.events.emit("content-changed")),t),s}removeDrapeSourceRenderer(t){if(t==null)return;const e=this._renderers.get(t);e!=null&&(this._sortedDrapeSourceRenderersDirty=!0,this._renderers.delete(t),this._handles.remove(t),e.destroy())}collectUnusedRenderTargetMemory(){let t=!1;const e=yo();if(this._overlayRenderTarget!=null)for(const r of this._overlayRenderTarget.renderTargets){const i=this.overlays[rr.INNER].validTargets[r.type];t=this._overlayRenderTarget.validateUsageForTarget(i,r,e)||t}return t}get overlays(){return this._overlays??[]}ensureDrapeTargets(t){this._overlays!=null&&this._overlays.forEach(e=>e.hasTargetWithoutRasterImage=Wr(t,r=>r.drapeTargetType===ui.WithoutRasterImage))}ensureDrapeSources(t){this._overlays!=null&&this._overlays.forEach(e=>{e.hasDrapedFeatureSource=Wr(t,r=>r.drapeSourceType===Wt.Features),e.hasDrapedRasterSource=Wr(t,r=>r.drapeSourceType===Wt.RasterImage)})}ensureOverlays(t,e){this._overlays==null&&(this._overlayRenderTarget=new el(this._rctx),this._overlays=[new Qi(rr.INNER,this._overlayRenderTarget),new Qi(rr.OUTER,this._overlayRenderTarget)]),this.ensureDrapeTargets(t),this.ensureDrapeSources(e)}disposeOverlays(){this._overlays=null,this._overlayRenderTarget=je(this._overlayRenderTarget),this.events.emit("textures-disposed")}get running(){return this.updating}runTask(t){this._processDrapeSources(t,()=>!0)}_processDrapeSources(t,e){let r=!1;for(const[i,s]of this._renderers){if(t.done)break;(i.destroyed||e(i))&&s.commitChanges()&&(r=!0,t.madeProgress())}this._sortedDrapeSourceRenderersDirty&&(this._sortedDrapeSourceRenderersDirty=!1,r=!0,this._updateSortedDrapeSourceRenderers()),r&&(this._overlays!=null&&this._renderers.size===0&&this.disposeOverlays(),this.notifyChange("updating"),this.notifyChange("isEmpty"),this.events.emit("content-changed"),this._updateHasHighlights(),this._updateRendersOccluded(),this._updateHasWater())}processSyncDrapeSources(){this._processDrapeSources(wo,t=>t.updatePolicy===Zt.SYNC)}get isEmpty(){return!Ki.OVERLAY_DRAW_DEBUG_TEXTURE&&!Ue(this._renderers,t=>!t.isEmpty)}get hasHighlights(){return this._hasHighlights}get hasWater(){return this._hasWater}get rendersOccluded(){return this._rendersOccluded}updateAnimation(t){let e=!1;return this._renderers.forEach(r=>e=r.updateAnimation(t)||e),e}updateDrapeSourceOrder(){this._sortedDrapeSourceRenderersDirty=!0}drawTarget(t,e,r){const i=t.canvasGeometries;if(i.numViews===0)return!1;const{alignPixelEnabled:s,contentPixelRatio:a}=r;this._screenToWorldRatio=a*t.mapUnitsPerPixel/bn;const o=e.output;if(this.isEmpty||o===E.Highlight&&!this.hasHighlights||o===E.Normal&&!this.hasWater||!t.hasSomeSizedView())return!1;const n=e.fbo;if(!n.isValid())return!1;const l=2*t.resolution,c=t.resolution;n.resize(l,c);const d=this._rctx;if(this._camera.pixelRatio=t.pixelRatio*a,this._renderContext.output=o,this._bindParameters.alignPixelEnabled=s,this._bindParameters.screenToWorldRatio=this._screenToWorldRatio,this._bindParameters.screenToPCSRatio=this._screenToWorldRatio*this.worldToPCSRatio,this._bindParameters.slot=o===E.Normal?J.DRAPED_WATER:J.DRAPED_MATERIAL,t.applyViewport(this._rctx),n.bind(d),t.index===rr.INNER&&(d.setClearColor(0,0,0,0),d.clearSafe(Or.COLOR_BUFFER_BIT)),e.type===ze.Occluded&&(this._renderContext.renderOccludedMask=Is),Ki.OVERLAY_DRAW_DEBUG_TEXTURE&&e.type!==ze.Occluded)for(let u=0;u<i.numViews;u++)this._setViewParameters(i.extents[u],t),this._drawDebugTexture(t.resolution,zc[t.index]);return this._renderers.size>0&&this._sortedRenderers.forAll(({drapeSource:u,renderer:f})=>{if(e.type===ze.ColorNoRasterImage&&u.drapeSourceType===Wt.RasterImage)return;const{fullOpacity:h}=u,g=h!=null&&h<1&&o===E.Color;g&&(this.bindTemporaryFramebuffer(this._rctx,l,c),d.clearSafe(Or.COLOR_BUFFER_BIT));for(let T=0;T<i.numViews;T++)this._setViewParameters(i.extents[T],t),f.render(this._renderContext);g&&this._temporaryFBO!=null&&(n.bind(d),this.view._stage.renderView.compositingHelper.compositeOverlay(this._renderContext.bindParameters,this._temporaryFBO.getTexture(),h,t.index))}),d.bindFramebuffer(null),n.generateMipMap(),this._renderContext.resetRenderOccludedMask(),!0}bindTemporaryFramebuffer(t,e,r){this._temporaryFBO==null&&(this._temporaryFBO=new pa(t,!1)),this._temporaryFBO.resize(e,r),this._temporaryFBO.bind(t)}async reloadShaders(){await this._shaderTechniqueRepository.reloadAll()}notifyContentChanged(){this.events.emit("content-changed")}intersect(t,e,r,i){var a;let s=0;for(const o of this._renderers.values())s=((a=o.intersect)==null?void 0:a.call(o,t,e,r,i,s))??s}_updateSortedDrapeSourceRenderers(){if(this._sortedRenderers.clear(),this._renderers.size===0)return;const t=this.view.map.allLayers;this._renderers.forEach((e,r)=>{const i=t.indexOf(r.layer),s=i>=0,a=this._renderers.size*(r.renderGroup??(s?Ar.MapLayer:Ar.ViewLayer))+(s?i:0);this._sortedRenderers.push(new Nc(r,e,a))}),this._sortedRenderers.sort((e,r)=>e.index-r.index)}_setViewParameters(t,e){const r=this._camera;r.viewport=[0,0,e.resolution,e.resolution],To(r.projectionMatrix,0,t[2]-t[0],0,t[3]-t[1],r.near,r.far),So(r.viewMatrix,[-t[0],-t[1],0])}_updateHasWater(){const t=Ue(this._renderers,e=>e.hasWater);t!==this._hasWater&&(this._hasWater=t,this.events.emit("has-water",t))}_updateHasHighlights(){const t=Ue(this._renderers,e=>e.hasHighlights);t!==this._hasHighlights&&(this._hasHighlights=t,this.events.emit("has-highlights",t))}_updateRendersOccluded(){const t=Ue(this._renderers,e=>e.rendersOccluded);t!==this._rendersOccluded&&(this._rendersOccluded=t,this.events.emit("renders-occluded",t))}_drawDebugTexture(t,e){this._ensureDebugPatternResources(t,e);const r=this._rctx;r.bindTechnique(this._debugTextureTechnique,this._passParameters,null),r.bindVAO(this._quadVAO),r.drawArrays(hi.TRIANGLE_STRIP,0,Nn(this._quadVAO,"geometry"))}_ensureDebugPatternResources(t,e){if(k(this._passParameters.color,e[0],e[1],e[2]),this._passParameters.texture)return;const r=new Uint8Array(t*t*4);let i=0;for(let o=0;o<t;o++)for(let n=0;n<t;n++){const l=Math.floor(n/10),c=Math.floor(o/10);l<2||c<2||10*l>t-20||10*c>t-20?(r[i++]=255,r[i++]=255,r[i++]=255,r[i++]=255):(r[i++]=255,r[i++]=255,r[i++]=255,r[i++]=1&l&&1&c?1&n^1&o?0:255:1&l^1&c?0:128)}const s=new Dr(t);s.samplingMode=br.NEAREST,this._passParameters.texture=new gr(this._rctx,s,r);const a=new Da;a.hasAlpha=!0,this._debugTextureTechnique=this._shaderTechniqueRepository.acquire(ba,a),this._quadVAO=On(this._rctx)}get test(){return{drapedRenderers:Array.from(this._renderers.values()),getDrapeSourceRenderer:t=>this._renderers.get(t)}}};v([$()],Ne.prototype,"_sortedDrapeSourceRenderersDirty",void 0),v([$({autoDestroy:!0})],Ne.prototype,"_shaderTechniqueRepository",void 0),v([$({constructOnly:!0})],Ne.prototype,"view",void 0),v([$()],Ne.prototype,"worldToPCSRatio",void 0),v([$()],Ne.prototype,"spatialReference",void 0),v([$({type:Boolean,readOnly:!0})],Ne.prototype,"updating",null),v([$()],Ne.prototype,"isEmpty",null),Ne=v([zr("esri.views.3d.terrain.OverlayRenderer")],Ne);class Nc{constructor(e,r,i){this.drapeSource=e,this.renderer=r,this.index=i}}const zc=[[1,.5,.5],[.5,.5,1]],jc=-2,Is=st.OccludeAndTransparent;var fi;(function(t){function e(o,n){const l=o[n],c=o[n+1],d=o[n+2];return Math.sqrt(l*l+c*c+d*d)}function r(o,n){const l=o[n],c=o[n+1],d=o[n+2],u=1/Math.sqrt(l*l+c*c+d*d);o[n]*=u,o[n+1]*=u,o[n+2]*=u}function i(o,n,l){o[n]*=l,o[n+1]*=l,o[n+2]*=l}function s(o,n,l,c,d,u=n){(d=d||o)[u]=o[n]+l[c],d[u+1]=o[n+1]+l[c+1],d[u+2]=o[n+2]+l[c+2]}function a(o,n,l,c,d,u=n){(d=d||o)[u]=o[n]-l[c],d[u+1]=o[n+1]-l[c+1],d[u+2]=o[n+2]-l[c+2]}t.length=e,t.normalize=r,t.scale=i,t.add=s,t.subtract=a})(fi||(fi={}));const vt=fi,si=[[-.5,-.5,.5],[.5,-.5,.5],[.5,.5,.5],[-.5,.5,.5],[-.5,-.5,-.5],[.5,-.5,-.5],[.5,.5,-.5],[-.5,.5,-.5]],Uc=[0,0,1,-1,0,0,1,0,0,0,-1,0,0,1,0,0,0,-1],Vc=[0,0,1,0,1,1,0,1],Hc=[0,1,2,2,3,0,4,0,3,3,7,4,1,5,6,6,2,1,1,0,4,4,5,1,3,2,6,6,7,3,5,4,7,7,6,5],Aa=new Array(36);for(let t=0;t<6;t++)for(let e=0;e<6;e++)Aa[6*t+e]=t;const Ke=new Array(36);for(let t=0;t<6;t++)Ke[6*t]=0,Ke[6*t+1]=1,Ke[6*t+2]=2,Ke[6*t+3]=2,Ke[6*t+4]=3,Ke[6*t+5]=0;function Yh(t,e){Array.isArray(e)||(e=[e,e,e]);const r=new Array(24);for(let i=0;i<8;i++)r[3*i]=si[i][0]*e[0],r[3*i+1]=si[i][1]*e[1],r[3*i+2]=si[i][2]*e[2];return new we(t,[[p.POSITION,new L(r,3,!0)],[p.NORMAL,new L(Uc,3)],[p.UV0,new L(Vc,2)]],[[p.POSITION,Hc],[p.NORMAL,Aa],[p.UV0,Ke]])}const ai=[[-.5,0,-.5],[.5,0,-.5],[.5,0,.5],[-.5,0,.5],[0,-.5,0],[0,.5,0]],Wc=[0,1,-1,1,1,0,0,1,1,-1,1,0,0,-1,-1,1,-1,0,0,-1,1,-1,-1,0],Gc=[5,1,0,5,2,1,5,3,2,5,0,3,4,0,1,4,1,2,4,2,3,4,3,0],Bc=[0,0,0,1,1,1,2,2,2,3,3,3,4,4,4,5,5,5,6,6,6,7,7,7];function Xh(t,e){Array.isArray(e)||(e=[e,e,e]);const r=new Array(18);for(let i=0;i<6;i++)r[3*i]=ai[i][0]*e[0],r[3*i+1]=ai[i][1]*e[1],r[3*i+2]=ai[i][2]*e[2];return new we(t,[[p.POSITION,new L(r,3,!0)],[p.NORMAL,new L(Wc,3)]],[[p.POSITION,Gc],[p.NORMAL,Bc]])}const yr=Q(-.5,0,-.5),wr=Q(.5,0,-.5),Tr=Q(0,0,.5),Sr=Q(0,.5,0),_t=B(),yt=B(),At=B(),Et=B(),It=B();le(_t,yr,Sr),le(yt,yr,wr),Le(At,_t,yt),ne(At,At),le(_t,wr,Sr),le(yt,wr,Tr),Le(Et,_t,yt),ne(Et,Et),le(_t,Tr,Sr),le(yt,Tr,yr),Le(It,_t,yt),ne(It,It);const oi=[yr,wr,Tr,Sr],kc=[0,-1,0,At[0],At[1],At[2],Et[0],Et[1],Et[2],It[0],It[1],It[2]],qc=[0,1,2,3,1,0,3,2,1,3,0,2],Zc=[0,0,0,1,1,1,2,2,2,3,3,3];function Qh(t,e){Array.isArray(e)||(e=[e,e,e]);const r=new Array(12);for(let i=0;i<4;i++)r[3*i]=oi[i][0]*e[0],r[3*i+1]=oi[i][1]*e[1],r[3*i+2]=oi[i][2]*e[2];return new we(t,[[p.POSITION,new L(r,3,!0)],[p.NORMAL,new L(kc,3)]],[[p.POSITION,qc],[p.NORMAL,Zc]])}function Kh(t,e,r,i,s={uv:!0}){const a=-Math.PI,o=2*Math.PI,n=-Math.PI/2,l=Math.PI,c=Math.max(3,Math.floor(r)),d=Math.max(2,Math.floor(i)),u=(c+1)*(d+1),f=Ce(3*u),h=Ce(3*u),g=Ce(2*u),T=[];let w=0;for(let D=0;D<=d;D++){const y=[],x=D/d,z=n+x*l,C=Math.cos(z);for(let U=0;U<=c;U++){const Te=U/c,A=a+Te*o,H=Math.cos(A)*C,re=Math.sin(z),De=-Math.sin(A)*C;f[3*w]=H*e,f[3*w+1]=re*e,f[3*w+2]=De*e,h[3*w]=H,h[3*w+1]=re,h[3*w+2]=De,g[2*w]=Te,g[2*w+1]=x,y.push(w),++w}T.push(y)}const b=new Array;for(let D=0;D<d;D++)for(let y=0;y<c;y++){const x=T[D][y],z=T[D][y+1],C=T[D+1][y+1],U=T[D+1][y];D===0?(b.push(x),b.push(C),b.push(U)):D===d-1?(b.push(x),b.push(z),b.push(C)):(b.push(x),b.push(z),b.push(C),b.push(C),b.push(U),b.push(x))}const S=[[p.POSITION,b],[p.NORMAL,b]],_=[[p.POSITION,new L(f,3,!0)],[p.NORMAL,new L(h,3,!0)]];return s.uv&&(_.push([p.UV0,new L(g,2,!0)]),S.push([p.UV0,b])),s.offset&&(S[0][0]=p.OFFSET,_[0][0]=p.OFFSET,S.push([p.POSITION,aa(b.length)]),_.push([p.POSITION,new L(Float64Array.from(s.offset),3,!0)])),new we(t,_,S)}function eu(t,e,r,i){const{vertexAttributes:s,indices:a}=Jc(e,r,i);return new we(t,s,a)}function Jc(t,e,r){const i=t;let s,a;if(r)s=[0,-1,0,1,0,0,0,0,1,-1,0,0,0,0,-1,0,1,0],a=[0,1,2,0,2,3,0,3,4,0,4,1,1,5,2,2,5,3,3,5,4,4,5,1];else{const d=i*(1+Math.sqrt(5))/2;s=[-i,d,0,i,d,0,-i,-d,0,i,-d,0,0,-i,d,0,i,d,0,-i,-d,0,i,-d,d,0,-i,d,0,i,-d,0,-i,-d,0,i],a=[0,11,5,0,5,1,0,1,7,0,7,10,0,10,11,1,5,9,5,11,4,11,10,2,10,7,6,7,1,8,3,9,4,3,4,2,3,2,6,3,6,8,3,8,9,4,9,5,2,4,11,6,2,10,8,6,7,9,8,1]}for(let d=0;d<s.length;d+=3)vt.scale(s,d,t/vt.length(s,d));let o={};function n(d,u){d>u&&([d,u]=[u,d]);const f=d.toString()+"."+u.toString();if(o[f])return o[f];let h=s.length;return s.length+=3,vt.add(s,3*d,s,3*u,s,h),vt.scale(s,h,t/vt.length(s,h)),h/=3,o[f]=h,h}for(let d=0;d<e;d++){const u=a.length,f=new Array(4*u);for(let h=0;h<u;h+=3){const g=a[h],T=a[h+1],w=a[h+2],b=n(g,T),S=n(T,w),_=n(w,g),D=4*h;f[D]=g,f[D+1]=b,f[D+2]=_,f[D+3]=T,f[D+4]=S,f[D+5]=b,f[D+6]=w,f[D+7]=_,f[D+8]=S,f[D+9]=b,f[D+10]=S,f[D+11]=_}a=f,o={}}const l=es(s);for(let d=0;d<l.length;d+=3)vt.normalize(l,d);const c=[[p.POSITION,a],[p.NORMAL,a]];return{vertexAttributes:[[p.POSITION,new L(es(s),3,!0)],[p.NORMAL,new L(l,3,!0)]],indices:c}}function tu(t,e,r,i,s,a,o,n,l=null){const c=r?[r[0],r[1],r[2]]:[0,0,0],d=e?[e[0],e[1],e[2]]:[0,0,1];o=o||[0,0];const u=i?[255*i[0],255*i[1],255*i[2],i.length>3?255*i[3]:255]:[255,255,255,255],f=s!=null&&s.length===2?s:[1,1],h=[[p.POSITION,new L(c,3,!0)],[p.NORMAL,new L(d,3,!0)],[p.UV0,new L(o,o.length)],[p.COLOR,new L(u,4,!0)],[p.SIZE,new L(f,2)]];if(a!=null){const g=[a[0],a[1],a[2],a[3]];h.push([p.AUXPOS1,new L(g,4)])}if(n!=null){const g=[n[0],n[1],n[2],n[3]];h.push([p.AUXPOS2,new L(g,4)])}return new we(t,h,null,null,Mt.Point,l)}function ru(t,e,r,i,s,a=!0,o=!0){let n=0;const l=r,c=e;let d=Q(0,n,0),u=Q(0,n+c,0),f=Q(0,-1,0),h=Q(0,1,0);s&&(n=c,u=Q(0,0,0),d=Q(0,n,0),f=Q(0,1,0),h=Q(0,-1,0));const g=[u,d],T=[f,h],w=i+2,b=Math.sqrt(c*c+l*l);if(s)for(let C=i-1;C>=0;C--){const U=C*(2*Math.PI/i),Te=Q(Math.cos(U)*l,n,Math.sin(U)*l);g.push(Te);const A=Q(c*Math.cos(U)/b,-l/b,c*Math.sin(U)/b);T.push(A)}else for(let C=0;C<i;C++){const U=C*(2*Math.PI/i),Te=Q(Math.cos(U)*l,n,Math.sin(U)*l);g.push(Te);const A=Q(c*Math.cos(U)/b,l/b,c*Math.sin(U)/b);T.push(A)}const S=new Array,_=new Array;if(a){for(let C=3;C<g.length;C++)S.push(1),S.push(C-1),S.push(C),_.push(0),_.push(0),_.push(0);S.push(g.length-1),S.push(2),S.push(1),_.push(0),_.push(0),_.push(0)}if(o){for(let C=3;C<g.length;C++)S.push(C),S.push(C-1),S.push(0),_.push(C),_.push(C-1),_.push(1);S.push(0),S.push(2),S.push(g.length-1),_.push(1),_.push(2),_.push(T.length-1)}const D=Ce(3*w);for(let C=0;C<w;C++)D[3*C]=g[C][0],D[3*C+1]=g[C][1],D[3*C+2]=g[C][2];const y=Ce(3*w);for(let C=0;C<w;C++)y[3*C]=T[C][0],y[3*C+1]=T[C][1],y[3*C+2]=T[C][2];const x=[[p.POSITION,S],[p.NORMAL,_]],z=[[p.POSITION,new L(D,3,!0)],[p.NORMAL,new L(y,3,!0)]];return new we(t,z,x)}function iu(t,e,r,i,s,a,o){const n=s?Hi(s):Q(1,0,0),l=a?Hi(a):Q(0,0,0);o??(o=!0);const c=B();ne(c,n);const d=B();ce(d,c,Math.abs(e));const u=B();ce(u,d,-.5),oe(u,u,l);const f=Q(0,1,0);Math.abs(1-Pt(c,f))<.2&&k(f,0,0,1);const h=B();Le(h,c,f),ne(h,h),Le(f,h,c);const g=2*i+(o?2:0),T=i+(o?2:0),w=Ce(3*g),b=Ce(3*T),S=Ce(2*g),_=new Array(3*i*(o?4:2)),D=new Array(3*i*(o?4:2));o&&(w[3*(g-2)]=u[0],w[3*(g-2)+1]=u[1],w[3*(g-2)+2]=u[2],S[2*(g-2)]=0,S[2*(g-2)+1]=0,w[3*(g-1)]=w[3*(g-2)]+d[0],w[3*(g-1)+1]=w[3*(g-2)+1]+d[1],w[3*(g-1)+2]=w[3*(g-2)+2]+d[2],S[2*(g-1)]=1,S[2*(g-1)+1]=1,b[3*(T-2)]=-c[0],b[3*(T-2)+1]=-c[1],b[3*(T-2)+2]=-c[2],b[3*(T-1)]=c[0],b[3*(T-1)+1]=c[1],b[3*(T-1)+2]=c[2]);const y=(A,H,re)=>{_[A]=H,D[A]=re};let x=0;const z=B(),C=B();for(let A=0;A<i;A++){const H=A*(2*Math.PI/i);ce(z,f,Math.sin(H)),ce(C,h,Math.cos(H)),oe(z,z,C),b[3*A]=z[0],b[3*A+1]=z[1],b[3*A+2]=z[2],ce(z,z,r),oe(z,z,u),w[3*A]=z[0],w[3*A+1]=z[1],w[3*A+2]=z[2],S[2*A]=A/i,S[2*A+1]=0,w[3*(A+i)]=w[3*A]+d[0],w[3*(A+i)+1]=w[3*A+1]+d[1],w[3*(A+i)+2]=w[3*A+2]+d[2],S[2*(A+i)]=A/i,S[2*A+1]=1;const re=(A+1)%i;y(x++,A,A),y(x++,A+i,A),y(x++,re,re),y(x++,re,re),y(x++,A+i,A),y(x++,re+i,re)}if(o){for(let A=0;A<i;A++){const H=(A+1)%i;y(x++,g-2,T-2),y(x++,A,T-2),y(x++,H,T-2)}for(let A=0;A<i;A++){const H=(A+1)%i;y(x++,A+i,T-1),y(x++,g-1,T-1),y(x++,H+i,T-1)}}const U=[[p.POSITION,_],[p.NORMAL,D],[p.UV0,_]],Te=[[p.POSITION,new L(w,3,!0)],[p.NORMAL,new L(b,3,!0)],[p.UV0,new L(S,2,!0)]];return new we(t,Te,U)}function su(t,e,r,i,s,a){i=i||10,s=s==null||s,pe(e.length>1);const o=[[0,0,0]],n=[],l=[];for(let c=0;c<i;c++){n.push([0,-c-1,-(c+1)%i-1]);const d=c/i*2*Math.PI;l.push([Math.cos(d)*r,Math.sin(d)*r])}return Yc(t,l,e,o,n,s,a)}function Yc(t,e,r,i,s,a,o=Q(0,0,0)){const n=e.length,l=Ce(r.length*n*3+(6*i.length||0)),c=Ce(r.length*n*3+(i?6:0)),d=new Array,u=new Array;let f=0,h=0;const g=B(),T=B(),w=B(),b=B(),S=B(),_=B(),D=B(),y=N(),x=B(),z=B(),C=B(),U=B(),Te=B(),A=Qt();k(x,0,1,0),le(T,r[1],r[0]),ne(T,T),a?(oe(y,r[0],o),ne(w,y)):k(w,0,0,1),Ps(T,w,x,x,S,w,$s),K(b,w),K(U,S);for(let I=0;I<i.length;I++)ce(_,S,i[I][0]),ce(y,w,i[I][2]),oe(_,_,y),oe(_,_,r[0]),l[f++]=_[0],l[f++]=_[1],l[f++]=_[2];c[h++]=-T[0],c[h++]=-T[1],c[h++]=-T[2];for(let I=0;I<s.length;I++)d.push(s[I][0]>0?s[I][0]:-s[I][0]-1+i.length),d.push(s[I][1]>0?s[I][1]:-s[I][1]-1+i.length),d.push(s[I][2]>0?s[I][2]:-s[I][2]-1+i.length),u.push(0),u.push(0),u.push(0);let H=i.length;const re=i.length-1;for(let I=0;I<r.length;I++){let ke=!1;I>0&&(K(g,T),I<r.length-1?(le(T,r[I+1],r[I]),ne(T,T)):ke=!0,oe(z,g,T),ne(z,z),oe(C,r[I-1],b),xo(r[I],z,A),Ro(A,Co(C,g),y)?(le(y,y,r[I]),ne(w,y),Le(S,z,w),ne(S,S)):Ps(z,b,U,x,S,w,$s),K(b,w),K(U,S)),a&&(oe(y,r[I],o),ne(Te,y));for(let Ae=0;Ae<n;Ae++)if(ce(_,S,e[Ae][0]),ce(y,w,e[Ae][1]),oe(_,_,y),ne(D,_),c[h++]=D[0],c[h++]=D[1],c[h++]=D[2],oe(_,_,r[I]),l[f++]=_[0],l[f++]=_[1],l[f++]=_[2],!ke){const Lt=(Ae+1)%n;d.push(H+Ae),d.push(H+n+Ae),d.push(H+Lt),d.push(H+Lt),d.push(H+n+Ae),d.push(H+n+Lt);for(let He=0;He<6;He++){const Fa=d.length-6;u.push(d[Fa+He]-re)}}H+=n}const De=r[r.length-1];for(let I=0;I<i.length;I++)ce(_,S,i[I][0]),ce(y,w,i[I][1]),oe(_,_,y),oe(_,_,De),l[f++]=_[0],l[f++]=_[1],l[f++]=_[2];const ht=h/3;c[h++]=T[0],c[h++]=T[1],c[h++]=T[2];const G=H-n;for(let I=0;I<s.length;I++)d.push(s[I][0]>=0?H+s[I][0]:-s[I][0]-1+G),d.push(s[I][2]>=0?H+s[I][2]:-s[I][2]-1+G),d.push(s[I][1]>=0?H+s[I][1]:-s[I][1]-1+G),u.push(ht),u.push(ht),u.push(ht);const Se=[[p.POSITION,d],[p.NORMAL,u]],be=[[p.POSITION,new L(l,3,!0)],[p.NORMAL,new L(c,3,!0)]];return new we(t,be,Se)}function au(t,e,r,i){pe(e.length>1,"createPolylineGeometry(): polyline needs at least 2 points"),pe(e[0].length===3,"createPolylineGeometry(): malformed vertex"),pe(r==null||r.length===e.length,"createPolylineGeometry: need same number of points and normals"),pe(r==null||r[0].length===3,"createPolylineGeometry(): malformed normal");const s=Ti(3*e.length),a=new Array(2*(e.length-1));let o=0,n=0;for(let d=0;d<e.length;d++){for(let u=0;u<3;u++)s[o++]=e[d][u];d>0&&(a[n++]=d-1,a[n++]=d)}const l=[],c=[];if(l.push([p.POSITION,a]),c.push([p.POSITION,new L(s,3,!0)]),r){const d=Ce(3*r.length);let u=0;for(let f=0;f<e.length;f++)for(let h=0;h<3;h++)d[u++]=r[f][h];l.push([p.NORMAL,a]),c.push([p.NORMAL,new L(d,3,!0)])}return i&&(c.push([p.COLOR,new L(i,4)]),l.push([p.COLOR,Dn(i.length/4)])),new we(t,c,l,null,Mt.Line)}function ou(t,e,r,i,s,a=0){const o=new Array(18),n=[[-r,a,s/2],[i,a,s/2],[0,e+a,s/2],[-r,a,-s/2],[i,a,-s/2],[0,e+a,-s/2]],l=[0,1,2,3,0,2,2,5,3,1,4,5,5,2,1,1,0,3,3,4,1,4,3,5];for(let c=0;c<6;c++)o[3*c]=n[c][0],o[3*c+1]=n[c][1],o[3*c+2]=n[c][2];return new we(t,[[p.POSITION,new L(o,3,!0)]],[[p.POSITION,l]])}function nu(t,e){const r=t.getMutableAttribute(p.POSITION).data;for(let i=0;i<r.length;i+=3){const s=r[i],a=r[i+1],o=r[i+2];k(wt,s,a,o),ye(wt,wt,e),r[i]=wt[0],r[i+1]=wt[1],r[i+2]=wt[2]}}function lu(t,e=t){const r=t.vertexAttributes,i=r.get(p.POSITION).data,s=r.get(p.NORMAL).data;if(s){const a=e.getMutableAttribute(p.NORMAL).data;for(let o=0;o<s.length;o+=3){const n=s[o+1];a[o+1]=-s[o+2],a[o+2]=n}}if(i){const a=e.getMutableAttribute(p.POSITION).data;for(let o=0;o<i.length;o+=3){const n=i[o+1];a[o+1]=-i[o+2],a[o+2]=n}}}function ni(t,e,r,i,s){return!(Math.abs(Pt(e,t))>s)&&(Le(r,t,e),ne(r,r),Le(i,r,t),ne(i,i),!0)}function Ps(t,e,r,i,s,a,o){return ni(t,e,s,a,o)||ni(t,r,s,a,o)||ni(t,i,s,a,o)}const $s=.99619469809,wt=B();let cu=class{constructor(e,r={}){this.geometry=e,this.screenToWorldRatio=1,this._transformation=W(),this._shaderTransformation=null,this._boundingSphere=null,this.id=ks(),this.layerUid=r.layerUid,this.graphicUid=r.graphicUid,this.shaderTransformer=r.shaderTransformer,this.castShadow=r.castShadow??!1}get transformation(){return this._transformation}get boundingInfo(){return this.geometry.boundingInfo}updateTransformation(e){e(this._transformation),this._shaderTransformation=this._boundingSphere=null}shaderTransformationChanged(){this._shaderTransformation=null}get boundingSphere(){return this._boundingSphere?this._boundingSphere:this.boundingInfo?(this._boundingSphere=ye(Ns(),this.boundingInfo.center,this.shaderTransformation),this._boundingSphere[3]=this.boundingInfo.radius*Fs(this.shaderTransformation),this._boundingSphere):bo}get hasShaderTransformation(){return this.shaderTransformer!=null}get material(){return this.geometry.material}get type(){return this.geometry.type}get shaderTransformation(){return this.shaderTransformer==null?this.transformation:(this._shaderTransformation||(this._shaderTransformation=rt(W(),this.shaderTransformer(this.transformation))),this._shaderTransformation)}get indices(){return this.geometry.indices}get vertexAttributes(){return this.geometry.vertexAttributes}get highlights(){return this.geometry.highlights}get occludees(){return this.geometry.occludees}get visible(){return this.geometry.visible}set visible(e){this.geometry.visible=e}};function Ea(t){return t.type==="point"}function hu(t,e){if(t.type==="point")return Ge(t,e,!1);if(An(t))switch(t.type){case"extent":return Ge(t.center,e,!1);case"polygon":return Ge(t.centroid,e,!1);case"polyline":return Ge(Ms(t),e,!0);case"mesh":return Ge(t.origin,e,!1)}else switch(t.type){case"extent":return Ge(Xc(t),e,!0);case"polygon":return Ge(Qc(t),e,!0);case"polyline":return Ge(Ms(t),e,!0)}}function Ms(t){const e=t.paths[0];if(!e||e.length===0)return null;const r=Oo(e,Do(e)/2);return wi(r[0],r[1],r[2],t.spatialReference)}function Xc(t){return wi(.5*(t.xmax+t.xmin),.5*(t.ymax+t.ymin),t.zmin!=null&&t.zmax!=null&&isFinite(t.zmin)&&isFinite(t.zmax)?.5*(t.zmax+t.zmin):void 0,t.spatialReference)}function Qc(t){const e=t.rings[0];if(!e||e.length===0)return null;const r=Ao(t.rings,!!t.hasZ);return wi(r[0],r[1],r[2],t.spatialReference)}function Ge(t,e,r){const i=r?t:En(t);return e&&t?Eo(t,i,e)?i:null:i}function uu(t,e,r,i=0){if(t){e||(e=Io());const s=t;let a=.5*s.width*(r-1),o=.5*s.height*(r-1);return s.width<1e-7*s.height?a+=o/20:s.height<1e-7*s.width&&(o+=a/20),qt(e,s.xmin-a-i,s.ymin-o-i,s.xmax+a+i,s.ymax+o+i),e}return null}function Kc(t,e){for(let r=0;r<t.geometries.length;++r){const i=t.geometries[r].getMutableAttribute(p.AUXPOS1);i&&i.data[3]!==e&&(i.data[3]=e,t.geometryVertexAttrsUpdated(t.geometries[r]))}}function pu(t,e,r=null){const i=Po(yi);return t!=null&&(i[0]=t[0],i[1]=t[1],i[2]=t[2]),e!=null?i[3]=e:t!=null&&t.length>3&&(i[3]=t[3]),r&&(i[0]*=r,i[1]*=r,i[2]*=r,i[3]*=r),i}function fu(t=Mo,e,r,i=1){const s=new Array(3);if(e==null||r==null)s[0]=1,s[1]=1,s[2]=1;else{let a,o=0;for(let n=2;n>=0;n--){const l=t[n];let c;const d=l!=null,u=n===0&&!a&&!d,f=r[n];l==="symbol-value"||u?c=f!==0?e[n]/f:1:d&&l!=="proportional"&&isFinite(l)&&(c=f!==0?l/f:1),c!=null&&(s[n]=c,a=c,o=Math.max(o,Math.abs(c)))}for(let n=2;n>=0;n--)s[n]==null?s[n]=a:s[n]===0&&(s[n]=.001*o)}for(let a=2;a>=0;a--)s[a]/=i;return $o(s)}function ed(t){return t.isPrimitive!=null}function mu(t){return td(ed(t)?[t.width,t.depth,t.height]:t)?null:"Symbol sizes may not be negative values"}function td(t){const e=r=>r==null||r>=0;return Array.isArray(t)?t.every(e):e(t)}function gu(t,e,r,i=W()){return t&&Lo(i,i,-t/180*Math.PI),e&&Fo(i,i,e/180*Math.PI),r&&No(i,i,r/180*Math.PI),i}function vu(t,e,r){if(r.minDemResolution!=null)return r.minDemResolution;const i=zo(e),s=jo(t)*i,a=Uo(t)*i,o=Vo(t)*(e.isGeographic?1:i);return s===0&&a===0&&o===0?r.minDemResolutionForPoints:.01*Math.max(s,a,o)}class _u{constructor(e,r=null,i=0){this.array=e,this.spatialReference=r,this.offset=i}}function Ia(t){return"array"in t}function fr(t,e,r="ground"){if(Ea(e))return t.getElevation(e.x,e.y,e.z||0,e.spatialReference,r);if(Ia(e)){let i=e.offset;return t.getElevation(e.array[i++],e.array[i++],e.array[i]||0,e.spatialReference??t.spatialReference,r)}return t.getElevation(e[0],e[1],e[2]||0,t.spatialReference,r)}function rd(t,e,r,i,s,a,o,n,l,c,d){const u=cd[d.mode];let f,h,g=0;if(xr(t,e,r,i,l.spatialReference,s,n))return u.requiresAlignment(d)?(g=u.applyElevationAlignmentBuffer(i,s,a,o,n,l,c,d),f=a,h=o):(f=i,h=s),xr(f,l.spatialReference,h,a,c.spatialReference,o,n)?g:void 0}function Pa(t,e,r,i,s){const a=(Ea(t)?t.z:Ia(t)?t.array[t.offset+2]:t[2])||0;switch(r.mode){case"on-the-ground":{const o=fr(e,t,"ground")??0;return s.verticalDistanceToGround=0,s.sampledElevation=o,void(s.z=o)}case"relative-to-ground":{const o=fr(e,t,"ground")??0,n=r.geometryZWithOffset(a,i);return s.verticalDistanceToGround=n,s.sampledElevation=o,void(s.z=n+o)}case"relative-to-scene":{const o=fr(e,t,"scene")??0,n=r.geometryZWithOffset(a,i);return s.verticalDistanceToGround=n,s.sampledElevation=o,void(s.z=n+o)}case"absolute-height":{const o=r.geometryZWithOffset(a,i),n=fr(e,t,"ground")??0;return s.verticalDistanceToGround=o-n,s.sampledElevation=n,void(s.z=o)}default:return void(s.z=0)}}function yu(t,e,r,i){return Pa(t,e,r,i,bt),bt.z}function wu(t,e,r){return e==null||r==null?t.definedChanged:e==="on-the-ground"&&r==="on-the-ground"?t.staysOnTheGround:e===r||e!=="on-the-ground"&&r!=="on-the-ground"?mi.UPDATE:t.onTheGroundChanged}function Tu(t){return t==="relative-to-ground"||t==="relative-to-scene"}function Su(t){return t!=="absolute-height"}function xu(t,e,r,i,s){Pa(e,r,s,i,bt),Kc(t,bt.verticalDistanceToGround);const a=bt.sampledElevation,o=rt(dd,t.transformation);return mr[0]=e.x,mr[1]=e.y,mr[2]=bt.z,Ho(e.spatialReference,mr,o,i.spatialReference)?t.transformation=o:console.warn("Could not locate symbol object properly, it might be misplaced"),a}function id(t,e,r,i,s,a){let o=0;const n=a.spatialReference;e*=3,i*=3;for(let l=0;l<s;++l){const c=t[e],d=t[e+1],u=t[e+2],f=a.getElevation(c,d,u,n,"ground")??0;o+=f,r[i]=c,r[i+1]=d,r[i+2]=f,e+=3,i+=3}return o/s}function sd(t,e,r,i,s,a,o,n){let l=0;const c=n.calculateOffsetRenderUnits(o),d=n.featureExpressionInfoContext,u=a.spatialReference;e*=3,i*=3;for(let f=0;f<s;++f){const h=t[e],g=t[e+1],T=t[e+2],w=a.getElevation(h,g,T,u,"ground")??0;l+=w,r[i]=h,r[i+1]=g,r[i+2]=d==null?T+w+c:w+c,e+=3,i+=3}return l/s}function ad(t,e,r,i,s,a,o,n){let l=0;const c=n.calculateOffsetRenderUnits(o),d=n.featureExpressionInfoContext,u=a.spatialReference;e*=3,i*=3;for(let f=0;f<s;++f){const h=t[e],g=t[e+1],T=t[e+2],w=a.getElevation(h,g,T,u,"scene")??0;l+=w,r[i]=h,r[i+1]=g,r[i+2]=d==null?T+w+c:w+c,e+=3,i+=3}return l/s}function od(t){const e=t.meterUnitOffset,r=t.featureExpressionInfoContext;return e!==0||r!=null}function nd(t,e,r,i,s,a,o,n){const l=n.calculateOffsetRenderUnits(o),c=n.featureExpressionInfoContext;e*=3,i*=3;for(let d=0;d<s;++d){const u=t[e],f=t[e+1],h=t[e+2];r[i]=u,r[i+1]=f,r[i+2]=c==null?h+l:l,e+=3,i+=3}return 0}let ld=class{constructor(){this.verticalDistanceToGround=0,this.sampledElevation=0,this.z=0}};var mi;(function(t){t[t.NONE=0]="NONE",t[t.UPDATE=1]="UPDATE",t[t.RECREATE=2]="RECREATE"})(mi||(mi={}));const cd={"absolute-height":{applyElevationAlignmentBuffer:nd,requiresAlignment:od},"on-the-ground":{applyElevationAlignmentBuffer:id,requiresAlignment:()=>!0},"relative-to-ground":{applyElevationAlignmentBuffer:sd,requiresAlignment:()=>!0},"relative-to-scene":{applyElevationAlignmentBuffer:ad,requiresAlignment:()=>!0}},dd=W(),bt=new ld,mr=N(),hd=Nr.getLogger("esri.views.3d.layers.graphics.featureExpressionInfoUtils");function ud(t){return{cachedResult:t.cachedResult,arcade:t.arcade?{func:t.arcade.func,context:t.arcade.modules.arcadeUtils.createExecContext(null,{sr:t.arcade.context.spatialReference}),modules:t.arcade.modules}:null}}async function Cu(t,e,r,i){const s=t&&t.expression;if(typeof s!="string")return null;const a=gd(s);if(a!=null)return{cachedResult:a};const o=await Wo();Go(r);const n=o.arcadeUtils,l=n.createSyntaxTree(s);return n.dependsOnView(l)?(i!=null&&i.error("Expressions containing '$view' are not supported on ElevationInfo"),{cachedResult:0}):{arcade:{func:n.createFunction(l),context:n.createExecContext(null,{sr:e}),modules:o}}}function pd(t,e,r){return t.arcadeUtils.createFeature(e.attributes,e.geometry,r)}function fd(t,e){if(t!=null&&!$a(t)){if(!e||!t.arcade)return void hd.errorOncePerTick("Arcade support required but not provided");const r=e;r._geometry&&(r._geometry=In(r._geometry)),t.arcade.modules.arcadeUtils.updateExecContext(t.arcade.context,e)}}function md(t){if(t!=null){if($a(t))return t.cachedResult;const e=t.arcade;let r=e==null?void 0:e.modules.arcadeUtils.executeFunction(e.func,e.context);return typeof r!="number"&&(t.cachedResult=0,r=0),r}return 0}function bu(t,e=!1){let r=t&&t.featureExpressionInfo;const i=r&&r.expression;return e||i==="0"||(r=null),r??null}const Ou={cachedResult:0};function $a(t){return t.cachedResult!=null}function gd(t){return t==="0"?0:null}let Du=class Ma{constructor(){this._meterUnitOffset=0,this._renderUnitOffset=0,this._unit="meters",this._metersPerElevationInfoUnit=1,this._featureExpressionInfoContext=null,this.centerPointInElevationSR=null,this.mode=null}get featureExpressionInfoContext(){return this._featureExpressionInfoContext}get meterUnitOffset(){return this._meterUnitOffset}get unit(){return this._unit}set unit(e){this._unit=e,this._metersPerElevationInfoUnit=Bo(e)}get requiresSampledElevationInfo(){return this.mode!=="absolute-height"}reset(){this.mode=null,this._meterUnitOffset=0,this._renderUnitOffset=0,this._featureExpressionInfoContext=null,this.unit="meters"}set offsetMeters(e){this._meterUnitOffset=e,this._renderUnitOffset=0}set offsetElevationInfoUnits(e){this._meterUnitOffset=e*this._metersPerElevationInfoUnit,this._renderUnitOffset=0}addOffsetRenderUnits(e){this._renderUnitOffset+=e}geometryZWithOffset(e,r){const i=this.calculateOffsetRenderUnits(r);return this.featureExpressionInfoContext!=null?i:e+i}calculateOffsetRenderUnits(e){let r=this._meterUnitOffset;const i=this.featureExpressionInfoContext;return i!=null&&(r+=md(i)*this._metersPerElevationInfoUnit),r/e.unitInMeters+this._renderUnitOffset}setFromElevationInfo(e){this.mode=e.mode,this.unit=ko(e.unit)?e.unit:"meters",this.offsetElevationInfoUnits=e.offset??0}updateFeatureExpressionInfoContext(e,r,i){if(e==null)return void(this._featureExpressionInfoContext=null);const s=e&&e.arcade;s&&r!=null&&i!=null?(this._featureExpressionInfoContext=ud(e),fd(this._featureExpressionInfoContext,pd(s.modules,r,i))):this._featureExpressionInfoContext=e}static fromElevationInfo(e){const r=new Ma;return e!=null&&r.setFromElevationInfo(e),r}};const se={dash:[4,3],dot:[1,3],"long-dash":[8,3],"short-dash":[4,1],"short-dot":[1,1]},vd={dash:se.dash,"dash-dot":[...se.dash,...se.dot],dot:se.dot,"long-dash":se["long-dash"],"long-dash-dot":[...se["long-dash"],...se.dot],"long-dash-dot-dot":[...se["long-dash"],...se.dot,...se.dot],none:null,"short-dash":se["short-dash"],"short-dash-dot":[...se["short-dash"],...se["short-dot"]],"short-dash-dot-dot":[...se["short-dash"],...se["short-dot"],...se["short-dot"]],"short-dot":se["short-dot"],solid:null},_d=8;function yd(t,e){return t==null?t:{pattern:t.slice(),pixelRatio:e}}function Au(t){return{pattern:[t,t],pixelRatio:2}}function Eu(t){return t!=null&&t.type==="style"?wd(t.style):null}function wd(t){return t!=null?yd(vd[t],_d):null}function Iu(t,e,r=null){const i=[],s=[],a=e.mapPositions;Td(e,s,i);const o=s[0][1].data,n=i[0][1].length,l=aa(n);return Sd(e,s,i,l),Cd(e,s,i,l),xd(e,s,i,l),Rd(e,s,i,l),bd(e,s,i,l),Od(e,s,i,l),Dd(e,s,i,o),new we(t,s,i,a,Mt.Line,r)}function Td(t,e,r){const{attributeData:{position:i},removeDuplicateStartEnd:s}=t,a=Ad(i)&&s,o=i.length/3-(a?1:0),n=new Array(2*(o-1)),l=a?i.slice(0,i.length-3):i;let c=0;for(let d=0;d<o-1;d++)n[c++]=d,n[c++]=d+1;e.push([p.POSITION,new L(l,3,a)]),r.push([p.POSITION,n])}function Sd(t,e,r,i){if(t.attributeData.colorFeature!=null)return;const s=t.attributeData.color;e.push([p.COLOR,new L(s??yi,4)]),r.push([p.COLOR,i])}function xd(t,e,r,i){if(t.attributeData.normal==null)return;const s=t.attributeData.normal;e.push([p.NORMAL,new L(s,3)]),r.push([p.NORMAL,i])}function Rd(t,e,r,i){t.attributeData.colorFeature!=null&&(e.push([p.COLORFEATUREATTRIBUTE,new L([t.attributeData.colorFeature],1,!0)]),r.push([p.COLOR,i]))}function Cd(t,e,r,i){t.attributeData.sizeFeature==null&&(e.push([p.SIZE,new L([t.attributeData.size??1],1,!0)]),r.push([p.SIZE,i]))}function bd(t,e,r,i){t.attributeData.sizeFeature!=null&&(e.push([p.SIZEFEATUREATTRIBUTE,new L([t.attributeData.sizeFeature],1,!0)]),r.push([p.SIZEFEATUREATTRIBUTE,i]))}function Od(t,e,r,i){const s=t.attributeData.opacityFeature;s!=null&&(e.push([p.OPACITYFEATUREATTRIBUTE,new L([s],1,!0)]),r.push([p.OPACITYFEATUREATTRIBUTE,i]))}function Dd(t,e,r,i){if(t.overlayInfo==null||t.overlayInfo.renderCoordsHelper.viewingMode!==Xt.Global||!t.overlayInfo.spatialReference.isGeographic)return;const s=Ti(i.length),a=qo(t.overlayInfo.spatialReference);for(let f=0;f<s.length;f+=3)Zo(i,f,s,f,a);const o=i.length/3,n=Ce(o+1);let l=Ed,c=Id,d=0,u=0;k(l,s[u++],s[u++],s[u++]),n[0]=0;for(let f=1;f<o+1;++f)f===o&&(u=0),k(c,s[u++],s[u++],s[u++]),d+=Jo(l,c),n[f]=d,[l,c]=[c,l];e.push([p.DISTANCETOSTART,new L(n,1,!0)]),r.push([p.DISTANCETOSTART,r[0][1]])}function Ad(t){const e=t.length;return t[0]===t[e-3]&&t[1]===t[e-2]&&t[2]===t[e-1]}const Ed=N(),Id=N();function Pu(t,e,r,i){const s=t.type==="polygon"?Cr.CCW_IS_HOLE:Cr.NONE,a=t.type==="polygon"?t.rings:t.paths,{position:o,outlines:n}=oa(a,!!t.hasZ,s),l=Ti(o.length),c=rd(o,t.spatialReference,0,l,0,o,0,o.length/3,e,r,i),d=c!=null;return{lines:d?La(n,o,l):[],projectionSuccess:d,sampledElevation:c}}function $u(t,e){const r=t.type==="polygon"?Cr.CCW_IS_HOLE:Cr.NONE,i=t.type==="polygon"?t.rings:t.paths,{position:s,outlines:a}=oa(i,!1,r),o=xr(s,t.spatialReference,0,s,e,0,s.length/3);for(let n=2;n<s.length;n+=3)s[n]=jc;return{lines:o?La(a,s):[],projectionSuccess:o}}function La(t,e,r=null){const i=new Array;for(const{index:s,count:a}of t){if(a<=1)continue;const o=3*s,n=3*a;i.push({position:Wi(e,3*s,3*a),mapPositions:r!=null?Wi(r,o,n):void 0})}return i}export{F as $,Dl as A,El as B,Zt as C,ou as D,Er as E,iu as F,su as G,ru as H,Ih as I,Yc as J,bu as K,Cu as L,Pa as M,_u as N,nu as O,Kc as P,fd as Q,ld as R,_c as S,vu as T,lu as U,Jn as V,Xh as W,Qh as X,Yh as Y,eu as Z,Ou as _,Ar as a,pu as a0,mi as a1,xu as a2,wu as a3,Tu as a4,pd as a5,mu as a6,Su as a7,$e as a8,ct as a9,lt as aa,pl as ab,Ol as ac,Jt as ad,va as ae,Rl as af,lh as ag,te as ah,Eu as ai,ac as aj,fu as ak,gu as al,Ps as am,xs as an,td as ao,Sc as ap,Tc as aq,Ul as ar,uu as as,cu as b,Kn as c,$u as d,Wt as e,Iu as f,Pu as g,Au as h,fa as i,Ir as j,vh as k,rl as l,cc as m,jc as n,Du as o,au as p,yl as q,ga as r,yu as s,tu as t,rd as u,Ph as v,Kh as w,fr as x,nc as y,hu as z};

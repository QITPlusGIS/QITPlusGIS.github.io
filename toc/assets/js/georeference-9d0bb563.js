import{s as P,fv as v,fw as h,fx as E,d7 as J,bI as F,dJ as N,bJ as $,fy as W,bQ as d,bG as q,bS as S,fz as I,fA as L,fB as Q,fC as D,bR as H}from"./index-36a9098f.js";import{c as O}from"./spatialReferenceEllipsoidUtils-ad2ece80.js";import{t as b,o as K}from"./DoubleArray-eb3748da.js";import{m as X}from"./MeshGeoreferencedRelativeVertexSpace-97f40d93.js";import{m as Y,p as Z}from"./MeshLocalVertexSpace-2dee28a4.js";import{N as k}from"./MeshTransform-ea38f94f.js";import{r as m,n as y}from"./vec32-0f17e166.js";import{E as U,j as V,v as nn,h as en,_ as tn,R as rn,M as on,O as an}from"./projection-67dffb3d.js";function z(n,t){return n.isGeographic||n.isWebMercator&&((t==null?void 0:t.geographic)??!0)}function zn(n,t,e){const r=!n.isGeoreferenced;(e==null?void 0:e.geographic)!=null&&e.geographic!==r&&P.getLogger(t).warnOnce(`Specifying the 'geographic' parameter (${e.geographic}) for a Mesh vertex space of type "${n.type}" is not supported. This parameter will be ignored.`)}function A(n,t,e){return z(t.spatialReference,e)?un(n,t,e):fn(n,t,e)}function T(n,t,e,r){const{position:i,normal:o,tangent:a}=n;if(!t.isRelative)return{position:i,normal:o,tangent:a};const s=(e==null?void 0:e.localMatrix)??h;return A({position:m(new Float64Array(i.length),i,s),normal:o!=null?on(o,new Float32Array(o.length),s):null,tangent:a!=null?an(a,new Float32Array(a.length),s):null},t.getOriginPoint(r),{geographic:!t.isGeoreferenced})}function ln(n,t,e){if(e!=null&&e.useTransform){const{position:r,normal:i,tangent:o}=n,{x:a,y:s,z:c}=t,l=q(a,s,c??0);return{vertexAttributes:{position:r,normal:i,tangent:o},vertexSpace:e.geographic??1?new Y({origin:l}):new X({origin:l}),transform:new k}}return{vertexAttributes:A(n,t,e),vertexSpace:new Z,transform:null}}function w(n,t,e){return z(t.spatialReference,e)?hn(n,t,e):_(n,t,e)}function sn(n,t,e,r,i){if(!t.isRelative)return w(n,r,i);const{spatialReference:o}=r,a=T(n,t,e,o);return r.equals(t.getOriginPoint(o))?_(a,r,i):w(a,r,i)}function cn({positions:n,transform:t,vertexSpace:e,inSpatialReference:r,outSpatialReference:i,outPositions:o,local:a}){const s=e.isRelative?e.origin:v,c=e.isRelative?(t==null?void 0:t.localMatrix)??h:h;if(e.isGeoreferenced){const f=o??b(n.length);if(E(c,h)?K(f,n):m(f,n,c),!J(s,v)){const[G,B,C]=s;for(let g=0;g<f.length;g+=3)f[g]+=G,f[g+1]+=B,f[g+2]+=C}return F(f,r,0,f,i,0,f.length/3),f}const l=O(r),x=!a&&N(r,l)?l:r;$(r,s,u,x),W(u,u,c);const p=o??b(n.length);return m(p,n,u),F(p,x,0,p,i,0,p.length/3),p}function fn(n,t,e){const r=new Float64Array(n.position.length),i=n.position,o=t.x,a=t.y,s=t.z??0,c=R(e?e.unit:null,t.spatialReference);for(let l=0;l<i.length;l+=3)r[l]=i[l]*c+o,r[l+1]=i[l+1]*c+a,r[l+2]=i[l+2]*c+s;return{position:r,normal:n.normal,tangent:n.tangent}}function un(n,t,e){const r=t.spatialReference,i=M(t,e,u),o=new Float64Array(n.position.length),a=pn(n.position,i,r,o),s=S(j,i);return{position:a,normal:gn(a,o,n.normal,s,r),tangent:mn(a,o,n.tangent,s,r)}}function pn(n,t,e,r){m(r,n,t);const i=new Float64Array(n.length);return U(r,i,e)}function gn(n,t,e,r,i){if(e==null)return null;const o=new Float32Array(e.length);return y(o,e,r),V(o,n,t,i,o),o}function mn(n,t,e,r,i){if(e==null)return null;const o=new Float32Array(e.length);y(o,e,r,4);for(let a=3;a<o.length;a+=4)o[a]=e[a];return nn(o,n,t,i,o),o}function _(n,t,e){const r=new Float64Array(n.position.length),i=n.position,o=t.x,a=t.y,s=t.z??0,c=R(e?e.unit:null,t.spatialReference);for(let l=0;l<i.length;l+=3)r[l]=(i[l]-o)/c,r[l+1]=(i[l+1]-a)/c,r[l+2]=(i[l+2]-s)/c;return{position:r,normal:n.normal,tangent:n.tangent}}function hn(n,t,e){const r=t.spatialReference;M(t,e,u);const i=I(Rn,u),o=new Float64Array(n.position.length),a=yn(n.position,r,i,o),s=S(j,i);return{position:a,normal:wn(n.normal,n.position,o,r,s),tangent:An(n.tangent,n.position,o,r,s)}}function M(n,t,e){$(n.spatialReference,[n.x,n.y,n.z??0],e,O(n.spatialReference));const r=R(t?t.unit:null,n.spatialReference);return L(e,e,[r,r,r]),e}function yn(n,t,e,r){const i=en(n,t,r),o=new Float64Array(i.length);return m(o,i,e),o}function wn(n,t,e,r,i){if(n==null)return null;const o=tn(n,t,e,r,new Float32Array(n.length));return y(o,o,i),o}function An(n,t,e,r,i){if(n==null)return null;const o=rn(n,t,e,r,new Float32Array(n.length));return y(o,o,i,4),o}function R(n,t){if(n==null)return 1;const e=Q(t);return 1/D(e,"meters",n)}const u=d(),Rn=d(),j=H(),Tn=Object.freeze(Object.defineProperty({__proto__:null,georeference:A,georeferenceApplyTransform:T,georeferenceByTransform:ln,project:cn,ungeoreference:w,ungeoreferenceByTransform:sn},Symbol.toStringTag,{value:"Module"}));export{w as D,sn as E,cn as I,A as O,T,Tn as g,zn as o,ln as q,z as r};

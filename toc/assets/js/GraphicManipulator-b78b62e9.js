import{cO as I,a7 as q,gb as L,f$ as Z,cW as P,D as v,v as j,i8 as J,hq as Q,b3 as U,a$ as W,fQ as $,i9 as A,ia as O,ib as T,ic as B,ed as K,ee,id as te,gx as ne,E as _,F as ie,bD as se,ie as le}from"./index-d502c71f.js";function G(e,i,n,t){if(t==null||e.hasZ||(t=void 0),e.type==="point")return e.x+=i,e.y+=n,e.hasZ&&t!=null&&(e.z+=t),e;if(e.type==="multipoint"){const y=e.points;for(let a=0;a<y.length;a++)y[a]=R(y[a],i,n,t);return e}if(e.type==="extent")return e.xmin+=i,e.xmax+=i,e.ymin+=n,e.ymax+=n,t!=null&&(e.zmin??(e.zmin=0),e.zmin+=t,e.zmax??(e.zmax=0),e.zmax+=t),e;const o=I(e),s=e.type==="polyline"?e.paths:e.rings;for(let y=0;y<o.length;y++){const a=o[y];for(let l=0;l<a.length;l++)a[l]=R(a[l],i,n,t)}return"paths"in e?e.paths=s:e.rings=s,e}function re(e,i,n,t,o){const s=e.clone(),y=t.resolution;if(s.type==="point"){if(o)G(s,i*y,-n*y);else{const a=t.state.transform,l=t.state.inverseTransform,r=a[0]*s.x+a[2]*s.y+a[4],h=a[1]*s.x+a[3]*s.y+a[5];s.x=l[0]*(r+i)+l[2]*(h+n)+l[4],s.y=l[1]*(r+i)+l[3]*(h+n)+l[5]}return s}if(s.type==="multipoint"){if(o)G(s,i*y,-n*y);else{const a=s.points,l=t.state.transform,r=t.state.inverseTransform;for(let h=0;h<a.length;h++){const p=a[h],m=l[0]*p[0]+l[2]*p[1]+l[4],d=l[1]*p[0]+l[3]*p[1]+l[5],u=r[0]*(m+i)+r[2]*(d+n)+r[4],g=r[1]*(m+i)+r[3]*(d+n)+r[5];a[h]=D(p,u,g,void 0)}}return s}if(s.type==="extent"){if(o)G(s,i*y,-n*y);else{const a=t.state.transform,l=t.state.inverseTransform,r=a[0]*s.xmin+a[2]*s.ymin+a[4],h=a[1]*s.xmin+a[3]*s.ymin+a[5],p=a[0]*s.xmax+a[2]*s.ymax+a[4],m=a[1]*s.xmax+a[3]*s.ymax+a[5];s.xmin=l[0]*(r+i)+l[2]*(h+n)+l[4],s.ymin=l[1]*(r+i)+l[3]*(h+n)+l[5],s.xmax=l[0]*(p+i)+l[2]*(m+n)+l[4],s.ymax=l[1]*(p+i)+l[3]*(m+n)+l[5]}return s}if(o)G(s,i*y,-n*y);else{const a=I(s),l=s.type==="polyline"?s.paths:s.rings,r=t.state.transform,h=t.state.inverseTransform;for(let p=0;p<a.length;p++){const m=a[p];for(let d=0;d<m.length;d++){const u=m[d],g=r[0]*u[0]+r[2]*u[1]+r[4],f=r[1]*u[0]+r[3]*u[1]+r[5],S=h[0]*(g+i)+h[2]*(f+n)+h[4],x=h[1]*(g+i)+h[3]*(f+n)+h[5];m[d]=D(u,S,x,void 0)}}"paths"in s?s.paths=l:s.rings=l}return s}function he(e,i,n,t){if(e.type==="point"){const{x:u,y:g}=e,f=t?t[0]:u,S=t?t[1]:g,x=e.clone(),C=(u-f)*i+f,c=(g-S)*n+S;return x.x=C,x.y=c,x}if(e.type==="multipoint"){const u=I(e),g=q(),[f,S,x,C]=L(g,[u]),c=t?t[0]:(f+x)/2,M=t?t[1]:(C+S)/2,z=e.clone(),E=z.points;for(let w=0;w<E.length;w++){const H=E[w],[k,F]=H,N=(k-c)*i+c,V=(F-M)*n+M;E[w]=D(H,N,V,void 0)}return z}if(e.type==="extent"){const{xmin:u,xmax:g,ymin:f,ymax:S}=e,x=t?t[0]:(u+g)/2,C=t?t[1]:(S+f)/2,c=e.clone();if(c.xmin=(u-x)*i+x,c.ymax=(S-C)*n+C,c.xmax=(g-x)*i+x,c.ymin=(f-C)*n+C,c.xmin>c.xmax){const M=c.xmin,z=c.xmax;c.xmin=z,c.xmax=M}if(c.ymin>c.ymax){const M=c.ymin,z=c.ymax;c.ymin=z,c.ymax=M}return c}const o=I(e),s=q(),[y,a,l,r]=L(s,o),h=t?t[0]:(y+l)/2,p=t?t[1]:(r+a)/2,m=e.clone(),d=m.type==="polyline"?m.paths:m.rings;for(let u=0;u<o.length;u++){const g=o[u];for(let f=0;f<g.length;f++){const S=g[f],[x,C]=S,c=(x-h)*i+h,M=(C-p)*n+p;d[u][f]=D(S,c,M,void 0)}}return"paths"in m?m.paths=d:m.rings=d,m}function ce(e,i,n,t,o,s){const y=Math.sqrt((n-e)*(n-e)+(t-i)*(t-i));return Math.sqrt((o-e)*(o-e)+(s-i)*(s-i))/y}function ye(e,i,n,t=!1){const o=Math.atan2(i.y-n.y,i.x-n.x)-Math.atan2(e.y-n.y,e.x-n.x),s=Math.atan2(Math.sin(o),Math.cos(o));return t?s:Z(s)}function R(e,i,n,t){return D(e,e[0]+i,e[1]+n,e[2]!=null&&t!=null?e[2]+t:void 0)}function D(e,i,n,t){const o=[i,n];return e.length>2&&o.push(t??e[2]),e.length>3&&o.push(e[3]),o}function ae(e){let i=0,n=0,t=0;return e?(e.type==="cim"&&e.data.symbol&&"symbolLayers"in e.data.symbol&&e.data.symbol.symbolLayers&&e.data.symbol.symbolLayers.map(o=>{o.type==="CIMVectorMarker"&&o.anchorPoint&&(Math.abs(o.anchorPoint.x)>i&&(i=o.anchorPoint.x),Math.abs(o.anchorPoint.y)>n&&(n=o.anchorPoint.y),o.size!=null&&o.size>t&&(t=o.size))}),i=P(i),n=P(n),t=P(t),{offsetX:i,offsetY:n,size:t}):{offsetX:i,offsetY:n,size:t}}let b=class extends j{set graphic(e){this._circleCollisionCache=null,this._originalSymbol=e.symbol,this._set("graphic",e),this.attachSymbolChanged()}get elevationInfo(){const{layer:e}=this.graphic,i=e&&"elevationInfo"in e?e.elevationInfo:null,n=J(this.graphic),t=i?i.offset:0;return new Q({mode:n,offset:t})}set focusedSymbol(e){e!==this._get("focusedSymbol")&&(this._set("focusedSymbol",e),this._updateGraphicSymbol(),this._circleCollisionCache=null)}grabbableForEvent(){return!0}set grabbing(e){e!==this._get("grabbing")&&(this._set("grabbing",e),this._updateGraphicSymbol())}set hovering(e){e!==this._get("hovering")&&(this._set("hovering",e),this._updateGraphicSymbol())}set selected(e){e!==this._get("selected")&&(this._set("selected",e),this._updateGraphicSymbol(),this.events.emit("select-changed",{action:e?"select":"deselect"}))}get _focused(){return this._get("hovering")||this._get("grabbing")}constructor(e){super(e),this.layer=null,this.interactive=!0,this.selectable=!1,this.grabbable=!0,this.dragging=!1,this.cursor=null,this.events=new U.EventEmitter,this._circleCollisionCache=null,this._graphicSymbolChangedHandle=null,this._originalSymbol=null}destroy(){this.detachSymbolChanged(),this._resetGraphicSymbol(),this._set("view",null)}intersectionDistance(e){const i=this.graphic;if(i.visible===!1)return null;const n=i.geometry;if(n==null)return null;const t=this._get("focusedSymbol"),o=t??i.symbol;return this.view.type==="2d"?this._intersectDistance2D(this.view,e,n,o):this._intersectDistance3D(this.view,e,i)}attach(){this.attachSymbolChanged(),this.layer!=null&&this.layer.add(this.graphic)}detach(){this.detachSymbolChanged(),this._resetGraphicSymbol(),this.layer!=null&&this.layer.remove(this.graphic)}attachSymbolChanged(){this.detachSymbolChanged(),this._graphicSymbolChangedHandle=W(()=>{var e;return(e=this.graphic)==null?void 0:e.symbol},e=>{e!=null&&e!==this.focusedSymbol&&e!==this._originalSymbol&&(this._originalSymbol=e,this._focused&&this.focusedSymbol!=null&&(this.graphic.symbol=this.focusedSymbol))},$)}detachSymbolChanged(){this._graphicSymbolChangedHandle!=null&&(this._graphicSymbolChangedHandle.remove(),this._graphicSymbolChangedHandle=null)}onElevationChange(){}onViewChange(){}_updateGraphicSymbol(){this.graphic.symbol=this._focused&&this.focusedSymbol!=null?this.focusedSymbol:this._originalSymbol}_resetGraphicSymbol(){this.graphic.symbol=this._originalSymbol}_intersectDistance2D(e,i,n,t){var y,a;if((t=t||A(n))==null)return null;const o=1;let s=this._circleCollisionCache;if(n.type==="point"&&t.type==="cim"&&((y=t.data.symbol)==null?void 0:y.type)==="CIMPointSymbol"&&t.data.symbol.symbolLayers){const{offsetX:l,offsetY:r,size:h}=ae(t),p=O(i,Y),m=h/2,d=e.toScreen(n),u=d.x+l,g=d.y+r;return T(p,[u,g])<m*m?o:null}if(n.type!=="point"||t.type!=="simple-marker")return B(i,n,e)?o:null;if(s==null||!s.originalPoint.equals(n)){const l=n,r=e.spatialReference;if(K(l.spatialReference,r)){const h=ee(l,r);s={originalPoint:l.clone(),mapPoint:h,radiusPx:P(t.size)},this._circleCollisionCache=s}}if(s!=null){const l=O(i,Y),r=(a=e.toScreen)==null?void 0:a.call(e,s.mapPoint);if(!r)return null;const h=s.radiusPx,p=r.x+P(t.xoffset),m=r.y-P(t.yoffset);return T(l,[p,m])<h*h?o:null}return null}_intersectDistance3D(e,i,n){const t=e.toMap(i,{include:[n]});return t&&te(t,X,e.renderSpatialReference)?ne(X,e.state.camera.eye):null}};v([_({constructOnly:!0,nonNullable:!0})],b.prototype,"graphic",null),v([_()],b.prototype,"elevationInfo",null),v([_({constructOnly:!0,nonNullable:!0})],b.prototype,"view",void 0),v([_({value:null})],b.prototype,"focusedSymbol",null),v([_({constructOnly:!0})],b.prototype,"layer",void 0),v([_()],b.prototype,"interactive",void 0),v([_()],b.prototype,"selectable",void 0),v([_()],b.prototype,"grabbable",void 0),v([_({value:!1})],b.prototype,"grabbing",null),v([_()],b.prototype,"dragging",void 0),v([_()],b.prototype,"hovering",null),v([_({value:!1})],b.prototype,"selected",null),v([_()],b.prototype,"cursor",void 0),b=v([ie("esri.views.interactive.GraphicManipulator")],b);const X=se(),Y=le();export{b as S,ce as a,ae as b,re as i,ye as m,G as r,he as s};

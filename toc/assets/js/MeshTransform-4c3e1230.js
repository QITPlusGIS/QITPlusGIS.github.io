import{fY as d,fZ as p,f_ as w,f$ as j,g0 as D,g1 as I,g2 as B,g3 as E,g4 as F,g5 as x,D as a,E as s,dg as L,bD as O,g6 as Z,de as _,bZ as i,g7 as q,g8 as z,cD as $,g9 as b,ga as P,F as T}from"./index-285b86bc.js";function e(t=N){return[t[0],t[1],t[2],t[3]]}function c(t,o,n=e()){return d(n,t),n[3]=o,n}function f(t,o,n=e()){return p(l,t,h(t)),p(A,o,h(o)),w(l,A,l),Y(n,j(D(n,l)))}function C(t,o,n,y=e()){return c(I,t,u),c(B,o,M),c(E,n,v),f(u,M,u),f(u,v,y),y}function G(t){return t}function U(t){return t[3]}function h(t){return F(t[3])}function Y(t,o){return t[3]=o,t}const N=[0,0,1,0],l=x(),A=x();e();const u=e(),M=e(),v=e();var g;let r=g=class extends L{constructor(t){super(t),this.translation=O(),this.rotationAxis=Z(N),this.rotationAngle=0,this.scale=_(1,1,1)}get rotation(){return c(this.rotationAxis,this.rotationAngle)}set rotation(t){this.rotationAxis=i(t),this.rotationAngle=U(t)}get localMatrix(){const t=$();return p(m,this.rotation,h(this.rotation)),q(t,m,this.translation,this.scale),t}get localMatrixInverse(){return z($(),this.localMatrix)}applyLocal(t,o){return b(o,t,this.localMatrix)}applyLocalInverse(t,o){return b(o,t,this.localMatrixInverse)}equals(t){return this===t||t!=null&&P(this.localMatrix,t.localMatrix)}clone(){const t={translation:i(this.translation),rotationAxis:i(this.rotationAxis),rotationAngle:this.rotationAngle,scale:i(this.scale)};return new g(t)}};a([s({type:[Number],nonNullable:!0,json:{write:!0}})],r.prototype,"translation",void 0),a([s({type:[Number],nonNullable:!0,json:{write:!0}})],r.prototype,"rotationAxis",void 0),a([s({type:Number,nonNullable:!0,json:{write:!0}})],r.prototype,"rotationAngle",void 0),a([s({type:[Number],nonNullable:!0,json:{write:!0}})],r.prototype,"scale",void 0),a([s()],r.prototype,"rotation",null),a([s()],r.prototype,"localMatrix",null),a([s()],r.prototype,"localMatrixInverse",null),r=g=a([T("esri.geometry.support.MeshTransform")],r);const m=x(),H=r;export{H as N,U as b,f as g,e as h,C as l,h as w,G as x};

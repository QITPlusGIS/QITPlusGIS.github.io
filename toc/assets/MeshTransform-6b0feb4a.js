import{fD as w,fE as p,fF as d,fG as j,fH as I,fI as F,fJ as L,fK as O,fL as z,fM as x,a,b as s,bF as B,bj as D,fN as E,bG as G,cX as i,fO as P,fz as Q,bQ as y,fP as $,fQ as q,c as H}from"./index-58dffe5f.js";function e(t=m){return[t[0],t[1],t[2],t[3]]}function c(t,o,n=e()){return w(n,t),n[3]=o,n}function A(t,o,n=e()){return p(l,t,f(t)),p(M,o,f(o)),d(l,M,l),K(n,j(I(n,l)))}function U(t,o,n,b=e()){return c(F,t,u),c(L,o,g),c(O,n,v),A(u,g,u),A(u,v,b),b}function X(t){return t}function J(t){return t[3]}function f(t){return z(t[3])}function K(t,o){return t[3]=o,t}const m=[0,0,1,0],l=x(),M=x();e();const u=e(),g=e(),v=e();var h;let r=h=class extends B{constructor(t){super(t),this.translation=D(),this.rotationAxis=E(m),this.rotationAngle=0,this.scale=G(1,1,1)}get rotation(){return c(this.rotationAxis,this.rotationAngle)}set rotation(t){this.rotationAxis=i(t),this.rotationAngle=J(t)}get localMatrix(){const t=y();return p(N,this.rotation,f(this.rotation)),P(t,N,this.translation,this.scale),t}get localMatrixInverse(){return Q(y(),this.localMatrix)}applyLocal(t,o){return $(o,t,this.localMatrix)}applyLocalInverse(t,o){return $(o,t,this.localMatrixInverse)}equals(t){return this===t||t!=null&&q(this.localMatrix,t.localMatrix)}clone(){const t={translation:i(this.translation),rotationAxis:i(this.rotationAxis),rotationAngle:this.rotationAngle,scale:i(this.scale)};return new h(t)}};a([s({type:[Number],nonNullable:!0,json:{write:!0}})],r.prototype,"translation",void 0),a([s({type:[Number],nonNullable:!0,json:{write:!0}})],r.prototype,"rotationAxis",void 0),a([s({type:Number,nonNullable:!0,json:{write:!0}})],r.prototype,"rotationAngle",void 0),a([s({type:[Number],nonNullable:!0,json:{write:!0}})],r.prototype,"scale",void 0),a([s()],r.prototype,"rotation",null),a([s()],r.prototype,"localMatrix",null),a([s()],r.prototype,"localMatrixInverse",null),r=h=a([H("esri.geometry.support.MeshTransform")],r);const N=x(),_=r;export{_ as N,J as b,A as g,e as h,U as l,f as w,X as x};
